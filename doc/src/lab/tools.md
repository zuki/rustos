# ツール

## デバッグチップ

### カーネル

GDBはあなたの味方です。`qemu-gdb`ターゲット（またはその亜種である
`qemu-gdb-nox`）を使用してQEMUにGDBのアタッチを待機させます。カーネルの
デバッグの際に便利なコマンドについては以下のGDBリファレンスを参照してください。

予期しない割り込み、例外、トリプルフォールトが発生した場合は`-d`引数を使用
して割り込みの詳細なログを生成するようQEMUに要求できます。

仮想メモリの問題をデバッグするにはQEMUのモニタコマンドである`info mem`
（高レベルの概要）または`info pg`（詳細）を試してみてください。これらの
コマンドは現在のページテーブルしか表示しないことに注意してください。

（ラボ4以後）複数のCPUをデバッグするには`thread`や`info threads`などの
GDBのスレッド関連コマンドを使用してください。

### ユーザ環境（ラボ3以降）

GDBはユーザ環境についてもデバッグできますが、気をつけなければならないことが
いくつかあります。GDBは複数のユーザ環境の違いやユーザとカーネルに区別がある
ことを知らないからです。

ユーザコードもカーネルコードと同じようにシンボリックデバッグできますが、
GDBはシンボルテーブルを一度に1つしか使用できないので[symbol-file](https://tc.gts3.org/cs3210/2020/spring/lab/tools.html#gdb-symbol-file)
コマンドで使用する[シンボルテーブル](https://tc.gts3.org/cs3210/2020/spring/lab/tools.html#obj-elf)を
GDBに指示する必要があります。提供しいる`.gdbinit`はカーネルシンボルテーブル
である`obj/kern/kernel`をロードします。ユーザ環境のシンボルテーブルはその
ELFバイナリなので`symbol-file obj/user/name`でロードできます。`.o`ファイルから
シンボルを _ロードしない_ でください。それらはリンカによって再配置されていない
からです（ライブラリはJOSのユーザバイナリに静的にリンクされるのでそれらの
シンボルはすでにユーザバイナリに含まれています）。_正しい_ ユーザライブラリが
得られていることを確認してください。ライブラリ関数はバイナリごとに異なるEIPで
リンクされますが、GDBはそれ以上のことを知りません。

（ラボ4以降）GDBは仮想マシン全体にアタッチされているため、クロック割り込みを
単なる制御転送と見なします。そのため、ユーザコードをステップスルーすることは
基本的に不可能です。クロック割り込みはVMを再び実行させた瞬間に発生することが
事実上保証されているためです。[stepi](https://tc.gts3.org/cs3210/2020/spring/lab/tools.html#gdb-si)コマンドは
割り込みを抑制するので機能しますが、アセンブリ命令1つごとにしかステップ
できません。一般に[ブレークポイント](https://tc.gts3.org/cs3210/2020/spring/lab/tools.html#gdb-b)は
機能しますが同じEIPが別の環境（実際、まったく別のバイナリ）でヒットしてしまう
可能性があるので注意が必要です。

### Raspberry Piボードでのデバッグ

Raspberry Pi 3B+ボードをデバッグするにはJ-Linkと呼ばれるJTAG信号を使用する
特別なデバイスが必要です。ここではJ-Link for Raspberry Piの接続方法と設定
方法を説明します。J-Linkを使いたい方はRaspberry Pi 3B+ボードとCP2102 USB
モジュールをお持ちの上、オフィスアワーにお越しください。

1. 接続方法

    物理的な配線から始めます。Raspberry Pi 3B+ボードとCP2102 USBモジュール、
    j-link EDU、ジャンパーケーブル8本が必要です。

    以下は、RPiとJ-Linkの接続方法です。

    ![rpi_jlinkの接続](rpi_jlink.png)
