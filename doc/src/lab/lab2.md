# Lab 2: Shellとブートローダ

## 目次

- [はじめに](#はじめに)
- [フェーズ 1: 酸化](#フェーズ-1-酸化)
    * [サブフェーズ A：StackVec]("サブフェーズ-a-stackvec)
    * [サブフェーズ B: volatile](#サブフェーズ-b-volatile)
    * [サブフェーズ C: xmodem](#サブフェーズ-c-xmodem)
    * [サブフェーズ D: ttywrite](#サブフェーズ-d-ttywrite)
- [フェーズ 2: 貝殻ではない](#フェーズ-2-貝殻ではない)
    * [サブフェーズ A: 始める前に](#サブフェーズ-a-始める前に)
    * [サブフェーズ B: システムタイマー](#サブフェーズ-b-システムタイマー)
    * [サブフェーズ C: GPIO](#サブフェーズ-c-gpio)
    * [サブフェーズ D: UART](#サブフェーズ-d-uart)
    * [サブフェーズ E: シェル](#サブフェーズ-e-シェル)
- [フェーズ 3: 起動](#フェーズ-3-起動)

## はじめに

この課題ではRaspberry Pi用の便利なユーティリティとライブラリ、
簡単なシェルを書きます。また、GPIO、UART、内蔵タイマー用の汎用ドライバも
書きます。最後に新しいドライバを使った「ブートローダ」を書きます。
これはXMODEMプロトコルを使ってUART経由でプログラムバイナリをロードして
実行します。

### スケルトンコードの取得

[一部省略]

```bash
.
├── bin : common binaries/utilities
├── doc : reference documents
├── ext : external files (e.g., resources for testing)
├── tut : tutorial/practices
│    ├── 0-rustlings
│    ├── 1-blinky
│    └── 2-shell : questions for lab2 *
├── boot : bootloader *
├── kern : the main os kernel *
└── lib  : required libraries
     ├── pi *
     ├── shim
     ├── stack-vec *
     ├── ttywrite *
     ├── volatile *
     └── xmodem *
```

以下のようなディレクトリ構成を勧めます。`kern`ディレクトリで`make`を
実行してディレクトリが適切に配置されていることを確認してください。
問題がなければコマンドは成功します。問題がなければリポジトリの中身を
自由に調べてください。

今回と今後の課題には回答しなければならない*質問*が含まれています。
以下はそのような質問の例です。

``質問 (1-blinky): 他のGPIOピンの設定はどのようにしますか**
> 課題1-blinkyではレジスタ`GPFSEL1`, `GPSET0`, `GPCLR0`に書き込む
> ことで、GPIOピン16を出力として有効にしてセットとクリアを繰り返し
> ました。GPIOピン27に対して同じことを行うにはどの3つのレジスタに
> 書き込みますか? Raspberry Piのどの物理ピンがGPIOピン27に対応して
> いますか。

質問にある括弧内の単語は質問が出題されているラボ名相対の`questions/`
ディレクトリにあるファイル名を示しています。たとえば、この
`Lab2: Shellとブーロローダ`のすべての質問は`tut/2-shell/questions/`
サブディレクトリに回答する必要があります。すべての質問に対して
あらかじめ空のファイルが生成されていることに注意してください。

上の`1-blinky`の質問に答えて質問に回答する練習をしてください。

## フェーズ 1: 酸化

このフェーズでは2つのライブラリと1つのコマンドラインユーティリティを
書き、1つのライブラリをレビューします。`lib`ディレクトリにある
`stack-vec`, `volatile`, `ttywrite`, `xmodem`の各スケルトンサブ
ディレクトリで作業することになります。

すべてのプロジェクトはCargoで管理されています。以下の`cargo`コマンドが
便利です。

- `cargo build` - アプリケーションやライブラリをビルドします
- `cargo test` - アプリケーションやライブラリをテストします
- `cargo run` - アプリケーションを実行します
- `cargo run -- $flags` - アプリケーションを実行し、任意のフラグを渡します

Cargoの使い方やCargoの動作についての詳細は[Cargo Book](https://doc.rust-lang.org/cargo/index.html)を参照してください。

### サブフェーズ A: `StackVec`

オペレーティングシステムが提供する重要な機能のひとつはメモリの割り当て
です。C、Rust、Java、Pythonなど、*どんな*アプリケーションも`malloc()`
を呼び出します。`malloc()`はOSからのメモリーを使い果たした場合、最終
的にはシステムコールで追加のメモリーを要求します。OSは利用可能な
メモリがあるか判断して、あればメモリの要求を満たします。

**注記: メモリの割り当ては複雑な話です**
> 実際、Linuxなどの現代のオペレーティングシステムはメモリ割り当てと
> 複雑な関係にあります。たとえば、最適化のためメモリ割り当ての要求の
> ほとんどは「仮想的に」処理されるだけです。物理メモリへの割り当ては
> アプリケーションが新しく割り当てられたメモリを使おうとするまでは
> 実際には行われません。そうではありますが、ほとんどのOSはこれまで
> 説明したような単純化された方法でメモリを割り当てているかのように
> *錯覚させる*ことを目指しています。OSはウソつきの名人です（🍰）。

`Vec`, `String`, `Box`などのヒープに割り当てられる構造体は必要に応じて
内部的に`malloc()`を呼び出してメモリを割り当てます。これはこれらの
構造体が機能するためにはOSのサポートが必要であることを意味します。
中でもOSがメモリ割り当てをサポートすることを必要とします。私たちは
まだOSを書き始めてはいません。私たちの小さなベアメタルプログラムが
利用できるメモリ割り当てのサポートがないのは明らかです。そのため、
私達のOSが進化するまでは`Vec`のようなヒープ割り当ての構造体を使う
ことはできません。

`Vec`は素晴らしい抽象化なのでこれは本当に残念です。Vecを使えば自分で
メモリを管理することなく要素の`push`と`pop`を考えることができます。
*メモリ割り当てをサポートすることなく`Vec`の抽象化の利点を得るにはどうすればいいでしょうか？*

一般的なテクニックのひとつはメモリを*事前に割り当て*、そのメモリを
構造体に渡して抽象化する方法です。メモリを事前に割り当てる方法には
`static`宣言を使ってバイナリのstatic sectionにメモリを割り当てる方法や
ローカル変数を宣言してスタック割り当てを使う方法などがあります。
いずれにせよ、割り当ては事前に決めた固定サイズで行われます。

このサブフェーズでは`StackVec`構造体を実装します。この構造体は事前に
割り当てられたメモリを与えられると`Vec`ライクなAPIを提供します。
`StackVec`型はフェーズ 2でRaspberry Pi用のシェルを実装する際に使用
します。`lib/stack-vec`スケルトンサブディレクトリで作業します。この
サブディレクトリには以下のファイルがあります：

- Cargo.toml` - Cargoの構成ファイルです
- `src/lib.rs` - ここにコードを記述します
- `src/tests.rs` - `cargo test`が呼ばれたときに実行されるテストです

#### `StackVec`インタフェース

`StackVec<T>`は`StackVec::new()`に任意の型`T`の値の可変スライスを
渡して呼び出すことで生成されます。`StackVec<T>`型は[Vec](https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html)が
実装しているメソッドの多くを実装しており、ほとんど同じように使われます。
以下は`StackVec<u8>`の使用例です。

```rust
let mut storage = [0u8; 10];
let mut vec = StackVec::new(&mut storage);

for i in 0..10 {
    vec.push(i * i).expect("can push 10 times");
}

for (i, v) in vec.iter().enumerate() {
    assert_eq!(*v, (i * i) as u8);
}

let last_element = vec.pop().expect("has elements");
assert_eq!(last_element, 9 * 9);
```

`StackVec`構造体はすでに宣言してあります。

```rust
pub struct StackVec<'a, T: 'a> {
    storage: &'a mut [T],
    len: usize
}
```

#### `StackVec`の理解

以下の質問は`StackVec`インタフェースについての理解度をテストする
ものです。

**質問 (push-fails): なぜ`push`は`Result`を返すのか**
> 標準ライブラリにある`Vec`の`push`メソッドには戻り値がありませんが
> `StackVec`の`push`メソッドには戻り値があります。失敗する可能性が
> あることを示す`Result`を返します。`Vec::push()`は失敗しないのに
> なぜ`StackVec::push()`は失敗する可能性があるのですか。

    Vecはあらかじめ確保した領域を超えてpushすると自動的にメモリを
    割り当て直すため失敗しない。一方、StackVecの割り当て領域は
    静的に決められているのでこの領域を超えてpushしようとすると失敗
    する。

**質問 (lifetime): `T`に`'a`を束縛する必要があるのはなぜか**
> `struct StackVec<'a, T> { buffer: &'a mut [T], len: usize }`
>
> Rustは束縛`T: 'a`を自動的に強制し、`T`型のライフタイムが`'a`より
> 短いと文句を言います。たとえば、`T`が`&'b str`で`'b`が`'a`より
> 実際に短い場合、Rustは`StackVec<'a, &'b str>`のインスタンスの作成を
> 許しません。
>
> この束縛が必要なのはなぜですか。この束縛をRustが強制しなかったと
> したら何が問題になりますか？

**質問 (clone-for-pop): `StackVec`が`pop()`に`T: Clone`を必要とするのはなぜですか？**

> 標準ライブラリの`Vec<T>`の`pop`メソッドはすべての`T`に対して実装されて
> いますが、`StackVec`の`pop`メソッドは`T`が`Clone`トレイトを実装して
> いるときにしか実装されていません。なぜですか。この束縛を取り除くと
> 何が問題になりますか。

#### `StackVec`の実装

`stack-vec/src/lib.rs`にある`StackVec`の`unimplemented()` メソッドをすべて
実装してください。各メソッドはソースコードに記述されています。また、実装が
正しいことを確認するためのテストが`src/tests.rs`に用意されています。
これらのテストは`cargo test`で実行できます。また、`cargo test`にすべて
パスするためには`StackVec`の`Deref`, `DerefMut`, `IntoIteratorPトレイトと
`&StackVec`の`IntoIterator`も実装する必要があります。実装が正しいと確信し、
このサブフェーズの質問に答えられたら、次のサブフェーズに進んでください。

**質問 (deref-in-tests): 度のテストが`Deref`の実装を使用していますか**
> `src/tests.rs`にあるテストに目を通してください。`Deref`の実装がないと
> どのテストがコンパイルに失敗しますか。`DerefMut`の実装についてはどう
> ですか。それはなぜですか。

**警告: 提供したユニットテストは不完全です**
> 提供したユニットテストは*基準となる*真実を提供しますが完全ではありません。
> 課題を採点する際には追加のテストを実施します。これらのテストの違いを
> 見つけて、それを埋めるためにあなた自身のテストを追加したらよいかも
> しれません。

### サブフェーズ B: `volatile`

このサブフェーズではvolatileメモリアクセスについて学び、スケルトンサブ
ディレクトリ`volatile`にあるソースコードを読み、ソースコードに関連する
質問に答えます。このサブフェーズではコードを書くことはありません。

OS同様、コンパイラはあなたが考えていることをあたかも実際にやっているかの
ように*見せる*名人です。実際には最適化のためにまったく別のことをやっています。
そのような最適化のひとつがデッドアクセスの除去です。コンパイラはそうする
ことがプログラムの実行に観察できる影響を与えないことが証明できる場合、
メモリアクセス (Read/Write) を削除します。たとえば、次のようなプログラムを
考えます。

```rust
fn f() {
    let mut x = 0；
    let y = &mut x；
    *y = 10;
}
```

コンパイラは`*y`は書き込み後に読まれることはないと推論することで`*y`への
書き込みを完全に排除することができます。その結果、コンパイラは書き込みが
プログラムに影響を与えることはあり得ないと結論づけ、コンパイル済みバイナリ
から削除します。同じ理由で`y`の宣言、`x`の宣言、そして`f()`の呼び出しも
完全に削除することができます。

このような最適化はほぼ例外なく有益です。その結果に影響を与えることなく
プログラムを高速化するからです。ただし、こうした最適化が意図しない結果を
もたらすこともあります。たとえば、`y`が書き込み専用のメモリマップド
レジスタを指しているとします。その場合、`*y`への書き込みはその後`*y`を読み
込ま*なくても*観測可能な効果を持つことに*なる*。コンパイラがこのことに
気づかなければこれらの書き込みを最適化で削除してしまいプログラムは正しく
機能しなくなります。

ソースコードレベルでは何の影響もないように見える読み書きを保持するよう
コンパイラに強制するにはどうすればいいでしょうか。ここで`volatile`メモリ
アクセスの出番です。コンパイラはvolatileメモリアクセスを最適化で除去*しない*
ことを約束します。したがって、実行時に確実に読み書きが行われるようにしたい
のであればvolatileメモリアクセスを行う必要があります。

#### Rust流`valatile`

Rustでは生ポインタへのvolatile読み書きを行うのに`read_volatile`メソッドと
`write_volatile`メソッドを使用ます。

``注記: 生ポインタとはなにか**
> 参照（`&T`と`&mut T`）についてはもうお馴染みでしょう。Rustの生ポインタ
> （`*const T`と`*mut T`）はRustの借用チェッカがライフタイムを追跡しない
> 「参照」です。このため、これらのポインタへの読み書きはC言語と同じく不正に
> なる可能性があります。Rustはこれらのポインタを`unsafe`であるとみなします。
> これらを読み書きするコードにはそのことを示す`unsafe`アノテーションを付ける
> 必要があります。詳細は[rustdocsの生ポインタの項](https://doc.rust-lang.org/nightly/std/primitive.pointer.html)を
> 参照してください。

volaite読み書きを行うたびに`read_volatile`や`write_volatile`を呼び出すのは
エラーの原因であり、面倒です。ありがたいことにRustはこれを簡単かつ安全に
するツールを提供しています。理想は（C言語のように）単にポインタをvolatileと
宣言するとそれ以降のすべての読み書きがvolatileであることが保証されることです。
さらに良いのは、（C言語とは異なり）ポインタを読み取り専用、書き込み専用、
読み書き可能と宣言し、適切なメモリアクセスだけが行えるようにすることです。

#### `Volatile`, `ReadVolatile`, `WriteVolatile`, `UniqueVolatile`の導入

スケルトンサブディレクトリ`volatile/`にある`volatile`クレートはこれだけを
行うことができる4つの型を実装しています。`volatile/`ディレクトリで
`cargo doc --open`を実行しこれらの型のドキュメントを読んでください。

**質問 (unique-volatile): `Unique<Volatile>`が存在するのはなぜ**
> `Volatile`も`Unique<Volatile>`も裏にあるポインタへのvolatile read/write
> アクセスを許可します。ドキュメントによるとこの2つの型の違いは何ですか。

    `Unique<Volatile>`はラップしている`Volatile`型のジェネリックが
    `T: Sync`の場合、Syncトレイトが実装される。

`src/lib.rs`, `src/traits.rs`, `src/macros.rs`のソースコードを開いて
ください。力の及ぶ限りソースコードに目を通してください。準備ができたら
以下の質問に答えてください。これらの質問に答えることができたら次の
サブフェーズに進む準備ができています。

**注記: `#[repr(c)]`とはなんですか**
> `[repr(C)]`アノテーションは構造体のフィールドをC言語と同じようにレイアウト
> するようRustに強制します。一般にRustは構造体のフィールドの順序や
> パディングを不特定の方法で最適化します。生のアドレスを構造体へのポインタに
> キャストする場合、通常は特定のメモリレイアウトを念頭に置いています。
> `[repr(C)]`アノテーションを使うことでRustが思い通りに構造体を配置する
> のではなく、私たちが意図したとおりに配置することができます。

**質問 (enforcing): Read-onlyとWrite-onlyのアクセスはどのように強制されていますか**
> `ReadVolatile`型と`WriteVolatile`型はそれぞれ裏にあるポインタへの
> 書き込みと読み込みを不可能にします。これはどのようにして実現されて
> いますか。

    内部の生ポインタをread-onlyでは*const T、write-onlyでは*mut Tに解決する
    ことで対象外の利用を防いでいる

**質問 (macros): マクロは何をするものですか**
> `readable!`, `writeable!`, `readable_writeable!`マクロはそれぞれ
> 何をしますか。

    readbleとwriteableは内部の生ポインタを解決して取り出すinner()を定義して
    いる。readable_writeableはジェネリック型TにBitAnd, BitOrトレイト境界を
    設定している。

### サブフェーズ C: `xmodem`

このサブフェーズでは`xmodem/`スケルトンサブディレクトリの`xmodem`
ライブラリにXMODEMファイル転送プロトコルを実装します。主に
`xmodem/src/lib.rs`で作業することになります。

XMODEMはもともと1977年に開発されたシンプルなファイル転送プロトコルです。
パケットチェックサム、キャンセル、自動再送の機能を持っています。広く
実装されておりシリアルインタフェース経由の転送に使われています。しかし、
このプロトコルの最大の特徴はそのシンプルさです。その歴史の詳細については
Wikipediaの[XMODEMの記事](https://ja.wikipedia.org/wiki/XMODEM)を参照
してください。

ここではRaspberry Piへのファイル転送にXMODEMプロトコルを使います。
Piへのデータ*送信*には既存のXMODEMプロトコルの実装を使つこともできました
が、それでも独自のレシーバを書く必要はあります。そこでついでにXMODEMの
送信も実装することにします。

#### プロトコル

XMODEMプロトコルの詳細は[Understanding The X-Modem File Transfer Protocol](https://cs140e.sergio.bz/assignments/1-shell/data/XMODEM.txt)
テキストファイルに記載されています。後世のためにここでもう一度言って
おきます。

**警告: ウィキペディアの説明に基づいて実装してはいけません**
> ウィキペディアの説明は高いレベルでは役に立ちますがそこに記載されている
> 詳細の多くはここで実装しようとしているプロトコルとは異なります。
> そのため、このサブフェーズのリファレンスとしてこの記事を使用しては
> いけません。

XMODEMはバイナリプロトコルです。バイトは生で送受信されます。また
"半二重"です。どの時点でも送信側か受信側のいずれかがデータを送信して
いますが、一度に両方が送信することはありません。最後にこのプロトコルは
パケットベースです。データはパケットと呼ばれる128バイトのチャンクに
分割されます。プロトコルはどのバイトがいつ送信され、それが何を意味し、
どのように解釈されるかを規定しています。

まず、いくつかの定数を定義します。

```rust
const SOH: u8 = 0x01;
const EOT: u8 = 0x04;
const ACK: u8 = 0x06;
const NAK: u8 = 0x15;
const CAN: u8 = 0x18;
```

ファイル転送を開始するために受信側は`NAK`バイトを送信し、送信側は`NAK`
バイトを待ちます。送信側が`NAK`バイトを受信するとパケット送信が開始します。
受信側はファイル転送を開始するためにだけ`NAK`バイトを送信します。すべての
パケットごとに送信することはありません。

ファイル転送が開始されると各パケットの送受信は同じものになります。
パケットには1から始まる連番が振られ、255の次は0に折り返されます。

![XMODEMプロトコル図](xmodem.png)

パケットを送信するために送信側は以下を実行します。

1. `SOH`バイトを送信する
2. パケット番号を送信する
3. パケット番号の1の補数 (`255 - $packet_number`) を送信する
4. パケットを送信する
5. パケットのチェックサムを送信する
    * チェックサムはパケットのすべてのバイトの合計のmod 256である
6. 受信側から1バイト読み込む
    * そのバイトが`NAK`の場合、同じパケットの送信を最大10回再試行する
    * そのバイトが`ACK`の場合、次のパケットを送信する

パケットを受信するために受信側はこれと逆のことを行います。

1. 送信側から`SOH`または`EOT`が送信されるのを待つ
    * これとは違うバイトを受信した場合、受信側は転送をキャンセルする
    * `EOT`バイトを受信した場合、受信側は転送を終了する
2. 次のバイトを読み取り、現在のパケット番号と比較する
    * 間違ったパケット番号を受信した場合、受信側は転送をキャンセルする
3. 次のバイトを読み取り、パケット番号の1の補数と比較する
    * 間違った数を受信した場合、受信側は転送をキャンセルする
4. 送信側からパケット（128バイト）を読み取る
5. パケットのチェックサムを計算する
    * チェックサムはパケットのすべてのバイトの合計のmod 256である
6. 次のバイトを読み取り、計算したチェックサムと比較する
    * チェックサムが異なる場合、`NAK`を送信し、同じパケットの受信を再試行する
    * チェックサムが等しい場合、`ACK`を送信し、次のパケットを受信する

転送をキャンセルするには、受信側、送信側のいずれかが`CAN`バイトを送信
します。いずれの側も`CAN`バイトを受信したら、エラーとして接続を中参します。

転送を終了するために送信側は以下を実行します。

1. `EOT`バイトを送信する
2. `NAK`バイトを待つ。異なるバイトを受信した場合、送信側はエラーとする
3. 2回目の`EOT`バイトを送信する
4. `ACK`バイトを待つ。異なるバイトを受信した場合、送信側はエラーとする

転送を終了するために受信側は以下を実行します。

1. `NAK`バイトを送信する
2. 2回目の`EOT`バイトを待つ。異なるバイトを受信した場合、受信側はエラーとする
3. `ACK`バイトを送信する

#### XMODEMの実装

XMODEMプロトコルの未完成の実装を`xmodem`スケルトンサブディレクトリに
用意しました。あなたの課題は`src/lib.rs`にある`expect_byte`,
`expect_byte_or_cancel`, `read_packet`, `write_packet`の各メソッドを
書いて実装を完成させることです。実装は`Xmodem`型の内部状態である`packet`と
`started`を利用する必要があります。始める前に既存のコードに目を通す
ことを勧めます。

まず、`expect_byte`メソッドと`expect_byte_or_cancel`メソッドの実装から
始めてください。次に、`read_byte`と`write_byte`を含む4つのヘルパー
メソッドをすべて使用して`read_packet`と`write_packet`を実装してください。
これらのメソッドがどのように使用されるかを知るにはこれらのメソッドを介して
XMODEMを使用した完全なデータストリームを送信または受信する`transmit`と
`receive`の実装を読んでください。ドキュメントコメントにある仕様に注意して
ください。作成した実装は`cargo test`を使ってテストすることができます。
実装が正しいと確信したら次のサブフェーズに進んでください。

**警告: `std`のその他のアイテムは使ってはいけません**

> 実装で使用できるのは`shim::io`のアイテムだけです。`std`やその他の
> ライブラリのアイテムを使用してはいけません。

**ヒント**
> `{read,write}_packet`のリファレンス実装はそれぞれおよそ43行のコードです。

**ヒント**
> `io::Read`と`io::Write`のrustdocsが役に立つでしょう。

**ヒント**
> `?`演算子は惜しみなく使いましょう。

**ヒント**
> テストソースコードが参考になります。

**ヒント**
> `ioerr!`マクロを使うと新たら`io::Error`を簡単に作成して返すことが
> できます。`shim/src/macros.rs`を参照するとさらに便利なマクロを
> 見つけることができます。

### サブフェーズ D: `ttywrite`

このサブフェーズではRaspberry Piに生データまたはXMODEMプロトコルで
データを送信できるコマンドラインユーティリティ`ttywrite`を作成します。
このユーティリティの実装にはサブフェーズ Cで作成した`xmodem`ライブラリを
使用します。コードは`ttywrite/src/main.rs`に書きます。`ttywrite`の実装の
テストには提供した`test.sh`スクリプトを使ってください。

**注記: シリアルデバイスとは何か**
> シリアルデバイスとは一度に1ビットの通信を受け付けるデバイスのことです。
> これは*シリアル通信*と呼ばれています。対して*パラレル通信*は一度に複数の
> ビットが並行して転送されます。ここではシリアル通信デバイスであるUART
> デバイスを介してRaspberry Piと通信します。

**注記: TTYとは何か**
> TTYは「テレタイプライター」のことです。コンピュータ端末を表す言葉として
> コンピューティング分野で採用された歴史的な言葉です。その後、この用語は
> より一般的になり、シリアル通信を目的としたあらゆる機を指すように
> なりました。このため、コンピュータはRaspberry Piにマッピングされた
> デバイスをTTYと呼んでいます。

#### コマンドラインインタフェース

提供している`ttywrite`のスケルトンコードではすでにコマンドライン引数の
解析と検証を行っています。これを行うために[crates.io](https://crates.io/)の
[structopt crate](https://github.com/TeXitoi/structopt)を使用しています。
structoptは[clap](https://clap.rs/)を使用しています。これらは`Cargo.toml`
ファイルの依存関係にリストされていることに気づくでしょう。structoptはコード
生成により動作します。構造体とそのフィールドにコマンドライン引数の宣言を
アノテーションするだけで、structoptがコマンドラインフラグを実際にパースする
コードを生成します。

structoptが生成するインタフェースは`--help`を付けてアプリケーションを
呼び出すと見ることができます。`cargo run`を使用する際には次のようにすると
任意のフラグを渡せることを思い出してください: `cargo run -- --help`。
ではインタフェースを見てください。そして、`main.rs`にある`Opt`構造体を
見て、インタフェースとその定義を比べてみてください。

**質問 (invalid): 無効なフラグが入力された場合はどうなるか**
> フラグとして無効な値をいくつか渡してみてください。たとえば、`-f`に`idk`を
> 設定することはできないはずです。どのようにして`structopt`は無効な値を
> 拒否することを知るのでしょうか。

たくさんのオプションがあることに気づくでしょう。これらはすべてシリアル
デバイスで利用できる設定に対応しています。今のところ、これらの設定が何を
するのかを正確に知ることは重要ではありません。

#### シリアルデバイスとの会話

`main`では[serial::open](https://docs.rs/serial/0.4.0/serial/fn.open.html)を
呼び出しています。これは同じく`crates.io`にある[serial](https://docs.rs/serial/0.4.0/serial/)クレート
の`open`関数を呼び出しています。この`open`関数は[TTYPort](https://docs.rs/serial-unix/0.4.0/serial_unix/struct.TTYPort.html)を
返します。これを使うと（その`io::Read`トレイトと`io::Write`トレイトの実装に
より）シリアルデバイスとの読み書きができ、（`SerialDevice`トレイとの実装に
より）シリアルデバイスの設定の読み書きができます。

#### コードを書く

`ttywrite`ユーティリティを実装します。実装は`main`にある`opt`変数に格納
されたコマンドライン経由で渡された適切な設定をすべて設定する必要があります。
入力ファイルが渡されなかった場合は標準入力から、渡された場合はその入力
ファイルから読み込みます。シリアルデバイスに渡すために入力データを書き込み
ます。`-r`フラグがセットされていた場合はデータをそのまま送信します。そうで
ない場合は前サブフェーズで作成した`xmodem`実装を使用して`XMODEM`プロトコルを
使ってデータを送信する必要があります。送信に成功した場合は送信したバイト数を
表示する必要があります。

XMODEMプロトコルを使用して送信するには`xmodem`ライブラリの`Xmodem::transmit`
メソッドまたは`Xmodem::transmit_with_progress`メソッドを使用します。
ユーティリティが送信の進行状況を示せるように`transmit_with_progress`を
使用することを勧めます。最も単純な形は次のようになります。

```rust
fn progress_fn(progress: Progress) {
    println!("Progress: {:?}", progress);
}

Xmodem::transmit_with_progress(data, to, progress_fn)
```

実装のベースラインの正しさは`ttywrite`ディレクトリにある`test.sh`スクリプトを
使ってテストすることができます。実装が少なくともある程度は正しい場合、
スクリプトを実行すると次のように表示されます。

```bash
Opening PTYs...
Running test 1/10.
wrote 333 bytes to input
...
Running test 10/10.
wrote 232 bytes to input
SUCCESS
```

**ヒント**
> `stdin`のハンドルは[io::stdin()](https://doc.rust-lang.org/nightly/std/io/fn.stdin.html)で取り出すことができます。

**ヒント**
> [io::copy()](https://doc.rust-lang.org/nightly/std/io/fn.copy.html)関数が役に立つでしょう。


**ヒント**
> `main()`関数のリファレンス実装はそれぞれおよそ35行のコードです。

**ヒント**
> コードを書いている間は[TTYPort](https://docs.rs/serial-unix/0.4.0/serial_unix/struct.TTYPort.html)のドキュメントを開いておくと良いでしょう。

**質問 (bad-tests): `test.sh`スクリプトが常に`-r`を設定するのはなぜか**
> 提供した`test.sh`スクリプトは常に`-r`フラグを使用しています。それが要求
> された時にユーティリティがXMODEMプロトコルを使用することをテストして
> いません。それはなぜですか。XMODEMプロトコルはrawでデータを送信する
> ことを想定していないためその機能をテストするのが難しいのでしょうか。

#### `ttywrite`ユーティリティのインストール

`ttywrite`ユーティリティを書き終えたら、`cargo install --path .`コマンドで
ツールをインストールしてください。このコマンドは後でブートローダと通信する
ために使用します。

## フェーズ 2: *貝殻では*ない*

このフェーズでは内蔵タイマー、GPIO、UARTデバイス用のドライバを実装します。
そして、これらのドライバを使って簡単なシェルを実装します。次のフェーズ
では、同じドライバを使ってブートローダを実装します。

**注記: ドライバとは何か**
> *ドライバ*、または、*デバイスドライバ*という用語はハードウェアデバイスと
> 直接相互作用し、制御するソフトウェアを表します。ドライバは制御する
> ハードウェアに対する高レベルなインタフェースを公開します。OSはデバイス
> ドライバと相互作用してさらに高レベルなインタフェースを公開することが
> できます。たとえば、LinuxカーネルはオーディオAPIであるALSA (Advanced
> Linux Sound Architecture) を公開しており、ALSAはデバイスドライバと相互
> 作用し、デバイスドライバはサウンドカードと直接相互作用します。

### サブフェーズ A: 始める前に

#### プロジェクト構成

この課題の最初に見たリポジトリの構成を思い出してみましょう。

```bash
.
├── ...
├── boot : bootloader *
├── kern : the main os kernel *
└── lib  : required libraries
     ├── pi *
     ├── shim
     ├── stack-vec *
     ├── ttywrite *
     ├── volatile *
     └── xmodem *
```

ブートとカーネルが使用するライブラリはすべて`lib`ディレクトリにあります。

`shim`ライブラリは`std`と`no_std`のいずれかのライブラリに選択的に依存
します。`#[cfg(feature = "no_std")]`を指定すると`shim`は`core_io`と
`ffi`, `path`, `syncなどの必要最小限のライブラリを持つカスタム`no_std`
モジュールを使用します。それ以外の場合は（ほとんどはテストコードです）
`shim`は`std`ライブラリを使用します。

`pi`サブディレクトリにはすべてのドライバコードが含まれています。`pi`
ライブラリは`volatile`ライブラリを使用します。また、`shim`ライブラリにも
依存しています。

`boot`と`kernel`は`pi`ライブラリを使用してハードウェアと通信します。
`shim`にも依存しています。さらに、`boot`は`xmodem`ライブラリに依存し、
`kernel`は`stack-vec`ライブラリに依存します。`volatile`ライブラリには
依存関係がありません。下図はこれらの関係を示しています。

![ライブラリ関係図](lib_relationship.png)

#### カーネル

`kern`ディレクトリにはオペレーティングシステムの中核となる
オペレーティングシステムカーネルのコードが含まれています。この
ディレクトリで`make`を実行するとカーネルがビルドされます。ビルド出力は
`build/`ディレクトリに格納されます。カーネルを実行するには
`build/kernel.bin`ファイルを`kernel8.img`とリネームしてMicroSDカードの
ルートにコピーします。`make install`コマンドでカーネルイメージをSD
カードにコピーするスクリプトを使用することもできます。`Makefile`の詳細に
ついては[Toolsページ](https://tc.gts3.org/cs3210/2020/spring/lab/tools.html)を
参照してください。

現時点ではカーネルはまったく何もしません。このフェーズが終わるころには
カーネルはシェルを起動して会話することができるようになります。

上で見たように`kernel`クレートは`pi`ライブラリに依存しています。そのため、
`pi`ライブラリのすべての型とアイテムをカーネルで使うことができます。


#### ドキュメント

デバイスドライバを書いている間は[BCM2837 ARM Peripherals Manual](file:///Users/dspace/xv6_memos/book/arm/bcm2837/index.html)を
開いておくとよいでしょう。

### サブフェーズ B: システムタイマー

このサブフェーズではARMシステムタイマーのデバイスドライバを作成します。
主に`lib/pi/src/timer.rs`と`kern/src/main.rs`で作業します。ARMシステム
タイマーについては[BCM2837 ARM Peripherals Manualの172ページ（セクション12）](file:///Users/dspace/xv6_memos/book/arm/bcm2837/12_system_timer.html)に記載されています。

`lib/pi/src/timer.rs`にある既存のコードを見ることから始めてください。
特に、以下のセクションの関係に注意してください。

```rust
onst TIMER_REG_BASE: usize = IO_BASE + 0x3000;

  #[repr(C)]
  struct Registers {
      CS: Volatile<u32>,
      CLO: ReadVolatile<u32>,
      CHI: ReadVolatile<u32>,
      COMPARE: [Volatile<u32>; 4]
  }

  pub struct Timer {
      registers: &'static mut Registers
  }

  impl Timer {
      pub fn new() -> Timer {
          Timer {
              registers: unsafe { &mut *(TIMER_REG_BASE as *mut Registers) },
          }
      }
  }
```

このプログラムの`unsafe`で囲まれた1行は非常に重要です。そこでは
`TIMER_REG_BASE`のアドレスを`*mut Registers`にキャストし、それを
`&'static mut Registers`にキャストしています。これはアドレス
`TIMER_REG_BASE`にある`Registers`構造体への静的参照があることを
Rustに伝えています。

`TIMER_REG_BASE`アドレスには何があるのでしょうか。[BCM2837 ARM Peripherals Manualの172ページ](file:///Users/dspace/xv6_memos/book/arm/bcm2837/12_system_timer.html)には`0x3000`がARMシステムタイマーの
ペリフェラルオフセットであることが記載されています。したがって、
`TIMER_REG_BASE`はARMシステムタイマーレジスタの開始アドレスです。この
`unsafe`で囲んだ1行の後では`registers`フィールドを使ってタイマーの
レジスタに安全にアクセスできます。`self.registers.CLO.read()`を使って
`CLO`レジスタを読むことができ、`self.registers.CS.write()`を使って
`CS`レジスタに書き込むことができ、そして、これらを組み合わせることで
経過マイクロ秒数を表すことができます。

**質問 (restricted-reads): なぜCLOやCHIには書き込めないのか**
> BCM2837のドキュメントによると`CLO`と`CHI`レジスタはリードオンリーです。
> 私たちのコードはこのプロパティを強制します。どのようにしてですか。
> CLOやCHIへの書き込みを妨げるものは何ですか。

    読み書きができるVolatile<T>方でなく、VaolatileRead<T>方を
    使用している

**注記: `unsafe`とは一体何か**
> 手短に言うと`unsafe`はRustコンパイラに自分がメモリ安全性の制御を行う
> ことを示すマーカーです。コンパイラはメモリ問題から守ってくれなく
> なります。その結果、`unsafe`セクションではRustはCでできることなら
> 何でもできるようになります。特に、型間の自由なキャスト、生ポインタの
> 逆参照、ライフタイムの生成ができます。
>
> ただし、`unsafe`はまったく安全でないことに注意してください。`unsafe`
> セクションで行うすべてのことが実際に*安全*であることを保証しなければ
> なりません。これは想像以上に難しいです。特に、Rustの`safe`の考え方は
> 他の言語よりもずっと厳格だからです。そのため、`unsafe`はなるべく使わない
> ようにするべきです。残念ながらOSではハードウェアと直接対話できるように
> するために`unsafe`を*使わざるを得ません*が、通常、使用はドライバごとに
> 1行に制限します
>
> `unsafe`について詳しく知りたい場合は["Nomicon"の第1章](https://doc.> rust-lang.org/nightly/nomicon/meet-safe-and-unsafe.html)を
> 読んでください。

#### ドライバの実装

`lib/pi/src/timer.rs`の`Timer::read()`, `current_time()`, `spin_sleep()`
を実装してください。これらの関数のシグネチャが期待される機能を示して
います。`Timer::read()`を実装するにはBCMマニュアルのタイマーに関する
ドキュメントを読む必要があります。特に、タイマーの現在のu64値を取得する
ためにはどのレジスタを読めばよいかを理解する必要があります。`pi`
ライブラリは`cargo build`でビルドできます。また、`cargo check`を使用
するとライブラリを実際にコンパイルせずに型チェックを行うこともできます。

**ヒント**
> `core::time::Duration`のページが役に立ちます。

#### ドライバのテスト

`spin_sleep()`が正確であることを確認することでドライバをテストしましょう。
そのためのコードを`kern/src/main.rs`に書きます。

ラボ1/フェーズ4のLED点滅コードを`main.rs`にコピーしてください。`for`
ループベースのsleep関数の代わりに新しく作成した`spin_sleep()`関数を
点滅を一時停止する`Duration`を指定して使用してください。カーネルを
コンパイルして`kernel8.img`とリネームしてMicroSDカードにロードし、
Raspberry Piで実行します。LEDが意図した頻度で点滅することを確認して
ください。他の休止時間も試してみて期待通りに動作することを確認してください。
フェーズ3でブートローダを作成するまではMicroSDカードをPiとコンピュータの
間で交換して異なるバイナリを試す必要があります。

タイマードライバが期待通りに動作したら次のサブフェーズに進んでください。

### サブフェーズ C: GPIO

このサブフェーズでは汎用的かつピンに依存しないGPIOデバイスドライバを
作成します。主に`lib/pi/src/gpio.rs`と`kern/src/main.rs`で作業します。
GPIOサブシステムについては[BCM2837 ARM Peripherals Manualの89ページ（セクション6）](file:///Users/dspace/xv6_memos/book/arm/bcm2837/06_gpio.html)に
記載されています。

#### ステートマシン

すべてのハードウェアデバイスは[ステートマシン](https://ja.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E3%82%AA%E3%83%BC%E3%83%88%E3%83%9E%E3%83%88%E3%83%B3)
です。あらかじめ決められた状態から始まり、明示的または暗黙的な入力に
基づいて異なる状態に遷移します。デバイスは今いる状態にあわせて異なる
機能を提供します。言い換えれば、ある状態においては*ある遷移*しか有効で
ありません。重要なことはデバイスがある状態にある時、ある遷移は*無効*で
あるということです。

ほとんどのプログラミング言語ではハードウェアの持つステートマシンの
セマンティクスを忠実にエンコードすることはできませんがRustは違います。
Rustはステートマシンのセマンティクスを*完全に*エンコードすることが
できます。これを利用してGPIOサブシステム用のより安全なデバイスドライバを
実装します。私たちのドライバはGPIOピンが決して誤用されないことを保証し、
それをコンパイル時に実行します。

下図は1つのピンのGPIOステートマシンのサブセットの状態図です。

![GPIO状態図](gpio_state.png)

ここでの目的はこのステートマシンをRustでエンコードすることです。
図を解釈することから始めましょう。

- GPIOは`START`ステートから始まる
- `START`ステートから次の3つのステートのいずれかに遷移できる
    1. `ALT` - このステートからはどこにも遷移できない
    2. `OUTPUT` - 2つの"self"遷移が可能: `SET`と`CLEAR`
    3. `INPUT` - 1つの"self"遷移が可能: `LEVEL`

**質問 (blinky-states): ラボ1の`blinky`ではどの遷移に従いましたか**
> でblinkyコードを実装した再、あなたは暗黙のうちにこの
> サブセットを実装しました。あなたのコードはどの遷移を
> 実装しましたか。

Rustの型システムを使用して、ピンが`OUTPUT`ステートに遷移した場合は
`SET`と`CLEAR`しかできないことを、`INPUT`ステートに遷移した場合は
`LEVEL`の読み取りしかできないことを保証します。`lib/pi/src/gpio.rs`にある
`GPIO`構造体の宣言を見てください。

```rust
pub struct Gpio<State> {
    pin: u8,
    registers: &'static mut Registers,
    _state: PhantomData<State>
}
```

この構造体には`State`というジェネリック引数が1つあります。`PhantomData`を
除いてこの引数を実際に使うものはありません。これが`PhantomData`がそこに
ある理由です。つまり、構造体はジェネリックを使用していないにもかかわらず、
何らかの形でジェネリックを使用しているとRustに思わせるためです。`State`
ジェネリックを使って`Gpioデ`バイスがどの状態にあるかをエンコードします。
他のジェネリックとは異なり、ここではこのパラメータを制御してクライアントが
このパラメタを作れないようにしなければなりません。

`State！`マクロは`Gpio`がいることのできるステートを表す型を生成します。

```rust
states! {
    Uninitialized, Input, Output, Alt
}

// 各パラメタは次のような`enum`を拡張する
enum Input { }
```

これも*また*奇妙です。なぜバリアントを持たない`enum`を作成しなければ
いけないのでしょうか。バリアントを持たない`enum`にはけっしてインスタンス化
されないという素晴らしい性質があります。このようにこれらの型は純粋に
マーカーとして機能します。`Input`型の値はだれも渡すことができません。
そのような値は作ることができないからです。Input型は純粋に型レベルでのみ
存在します。

これで`Gpio`があるステートにあるときの有効な遷移に対応するメソッドを
実装することができます。

```rust
impl Gpio<Output> {
    /// ピンをセット（オンに）する
    pub fn set(&mut self) { ... }

    /// ピンをクリア（オフに）する
    pub fn clear(&mut self) { ... }
}

impl Gpio<Input> {
    /// ピンの値を読み取る
    pub fn level(&mut self) -> bool { ... }
}
```

これは、`Gpio`が`Gpio<Output>`であるときは`set`と`clear`だけ、
`Gpio<input>`にあるときは`level`の読み取りだけ、しかできないように
強制します。完璧です。しかし、実際にどのように状態を遷移させるので
しょうか。そこで`Gpio::transition()`です。

```rust
impl<T> Gpio<T> {
    fn transition<S>(self) -> Gpio<S> {
        Gpio {
            pin: self.pin,
            registers: self.registers,
            _state: PhantoData
        }
    }
}
```

このメソッドを使うと`Gpio`を任意の状態から他の任意の状態に遷移させることが
できます。ステート｀T`にある`Gpio`を与えるとこのメソッドはステート`S`の
`Gpio`を返します。*すべて*の`S`と`T`で動作することに注意してください。
このメソッドを呼び出す際には十分注意する必要があります。呼び出しは状態図の
遷移の仕様をエンコードしています。仕様やエンコーディングを間違えると
ドライバは間違ってしまいます。

`transition()`メソッドを使うには`Gpio<S>`のoutput `S`としてどの型が欲しい
かをRustに伝える必要があります。そのためにはRustに十分な情報を与えて、
`S`型を推論できるようにします。たとえば、`into_output`メソッドの実装を
考えてみます。

```rust
pub fn into_output(self) -> Gpio<Output> {
    self.into_alt(Function::Output).transition();
}
```

このメソッドは戻り値の型として`Gpio<Output>`を要求しています。Rustの
型システムは`transition()`の呼び出しを検査する際、要件を満たす
`Gpio<Output>`を返す`Gpio::transition()`メソッドを探します。私たちの
`transition`メソッドは任意の`S`に対して`Gpio<S>`を返すので、Rustは
`S`を`Output`に置き換えてこのメソッドを使用します。その結果、
（`into_alt()`呼び出しで）`Gpio<Alt>`が`Gpio<Output>`に変換されます。

**質問 (fke0stats): クライアントがステートを捏造した場合、何が問題になりますか**
> `Gpio`構造体の初期ステートをユーザに選ばせたらどうなるか考えてみて
> ください。どんな問題が起きるでしょうか。

**注記: これはなぜRustでしかできないのでしょうか**
> `into_`遷移メソッドは移動によって`Gpio`を受け取ることに注目してください。
> これは`Gpio`はいったん別のステートに遷移したら前のステートには決して
> アクセスできないことを意味します。Rustのムーブセマンティクスがこれを
> 可能にしています。型が`Clone`や`Copy`などの複製手段を実装していない限り、
> 遷移から戻ることはできません。このような保証をコンパイル時に提供して
> くれる言語はC++を含めても他にはありません。

#### ドライバの実装

`lib/pi/src/gpio.rs`にある`unimplemented!()`メソッドを実装してください。
これらの関数のシグネチャは期待される機能を示しています。ドライバを実装
するには[BCM2837 ARM Peripherals Manualの89ページ（セクション6）](file:///Users/dspace/xv6_memos/book/arm/bcm2837/06_gpio.html)を
読む必要があるでしょう。ライブラリを実際にコンパイルしなくても
`cargo check`を使えば型チェックを行えることを覚えておいてください。

#### ドライバのテスト

ドライバが期待通りに動作することを確認するために再度`kern/src/main.rs`に
コードを書きます。

生のメモリアドレスを読み書きする代わりに、新しいGPIOドライバを使ってGPIO
ピン16のセット/クリアをしてください。コードがかなりすっきりするはずです。
カーネルをコンパイルし、`kernel8.img`とリネームしてMicroSDカードにロードし、
Raspberry Piで実行してLEDが以前と同じように点滅することを確認してください。

さらにLEDをRaspberry Piに接続します。GPIOピン5, 6, 13, 19, 26を使います。
課題0の[ピン番号図](https://cs140e.sergio.bz/assignments/0-blinky/#powering-the-pi)を
参照してピンの物理的な位置を決定してください。カーネルにすべてのLEDを
お好みのパターンで点滅させてください。

**質問 (led-patter): どんなパターンを選びましたか**
> どんなパターンでLEDを点滅させましたか。まだ決めていないのなら、
> LEDを円形に並べて、順に円形パターンで点灯/消灯させることで
> 「ローディングスピナー」を模倣させるのも楽しいアイデアの1つです。

GPIOドライバが期待通りに動作したら次のサブフェーズに進んでください。

### サブフェーズ D: UART

このサブフェーズではRaspberry Piのmini UARTデバイス用のデバイスドライバを
作成します。主に`lib/pi/src/uart.rs`と`kern/src/main.rs`で作業します。
mini UARTは[BCM2837 ARM Peripheralsマニュアルの8ページと10ページ（セクション2.1と2.2）](file:///Users/dspace/xv6_memos/book/arm/bcm2837/02_auxiliaries.html)に記載されています。

#### UART: Universal Asynchronous RX/TX

[UART](https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter)
(Universal Asynchronous Receiver-Transmitter) は、2本のケーブルで通信する
デバイスであり、シリアルプロトコルです。ラボ0のフェーズ1でCP2102 USB
モジュールのUARTデバイスとPiのUARTデバイスの接続に使用した2本のケーブル
（rx/tx）です。テキスト、バイナリ、画像など、どんな種類のデータでもUART
経由で送ることができます。例として、次のサブフェーズではPiのUARTデバイス
から読み込んでCP2102 USBモジュールのUARTデバイスに書き込むシェルを実装
します。フェーズ3ではPiのUARTから読み込んでCP2102 USBモジュールのUART
経由で送信されるバイナリをダウンロードします。

UARTプロトコルにはいくつかの設定パラメータがありますが通信するためには
レシーバとトランスミッタの双方を同じ設定にする必要があります。パラメタは
次の通りです。

- **データサイズ**: 1つのデータフレームの長さ（8ビットまたは9ビット）
- **パリティビット**: データの後にパリティ（チェックサム）ビットを送るか否か
- **ストップビット**: データの終わりを何ビットで知らせるか（1または2）
- **ボーレート**: (ビット/秒)単位の伝送速度

Piのmini UARTはパリティビットをサポートせず、1ストップビットしかサポート
していません。そのため、ボーレートとデータフレーム長だけを設定する必要が
あります。UARTの詳細については[UART通信の基礎](https://cs140e.sergio.bz/notes/lec4/uart-basics.pdf)の記事を参照してください。

#### ドライバの実装

この時点で背景情報を追加することなくデバイスドライバを書くためのツールは
すべて揃っています（おめでとう 🎉）。

`lib/pi/src/uart.rs`にmini UARTデバイスドライバを実装してください。
`Registers`構造体の定義を完了する必要があります。各レジスタには*最小限度のケーパビリティ*
を持つ`Volatile`型を使用します。すなわち、read-onlyレジスタには
`ReadVolatile`、write-onlyレジスタに`WriteVolatile`、予約領域には`Reserved`
を使用します。次に、`new()`でデバイスをボーレートを115200（分周比`270`）、
データ長を`8`ビットに設定して初期化します。最後に、残りの`unimplemented!()`
メソッドと`MiniUart`用に`fmt::Write`、`io::Read`、`io::Write`の各トレイトを
実装します。

**ヒント**
> `new`で`LCR`, `BAUD`, `CNTL`の各レジスタに書き込む必要があります。

**ヒント**
> 前のサブフェーズで作成したGPIOドライバを使用してください。

#### ドライバのテスト

`kern/src/main.rs`に簡単な "echo" プログラムを書いてドライバをテストして
ください。擬似コードでは次のようになります。

```rust
loop {
    write_byte(read_byte())
}
```

UARTとの通信には`screen /dev/<your-path> 115200`を使ってください。
`screen`はキー入力をすべてTTYで送信するのでechoプログラムが正しく動作
していれば入力したすべての文字を見ることができます。期待通りに動作して
いることを自分自身に納得させるために、バイトを受信するたびに1文字か2文字を
追加で送信するとよいかもしれません。

```rust
loop {
    werite_byte(read_byte())
    write_str("<-")
}
```

ドライバが期待通りに動いたら、次のサブフェーズに進んでください。

### サブフェーズ E: シェル

このサブフェーズでは新しいUARTドライバを使用してOSのインタフェースとなる
シンプルなシェルを実装します。`kern/src/console.rs`と`kern/src/shell.rs`、
`kernel/src/main.rs`で作業します。

#### `Console`

シェルを書くにはグローバルなデフォルトの入出力という概念が必要です。Unixや
その仲間は通常、これを`stdin`と`stdout`と呼びます。ここではこれを`Console`と
呼びます。`Console`を使うとおなじみの`print!`と`println!`のカーネル空間
バージョンである`kprint!`と`kprintln!`マクロを実装することができ、ユーザ
入力を読み取るためのデフォルトソースを得ることができます。シェルを実装する
ために`Console`とこれらのマクロを使います。

`kernel/src/console.rs`を見てください。このファイルには`Console`構造体に
未完成の実装が含まれています。`Console`は`MiniUart`をラップした*シングルトン*
であり、カーネルには`Console`のインスタンスは1つしか存在しません。この
インスタンスはグローバルに利用でき、どこででも何にでも利用できます。これに
より、`MiniUart`や`Console`のインスタンスを明示的に渡さなくてもmini UARTの
読み書きができるようになります。

#### グローバルな可変性

グローバルに変更可能な構造体という概念は恐ろしい考えです。特にRustにおいては
なおさらです。結局のところ、Rustは1つの値に対して複数の可変な参照を許し
ません。では、どうやって*望むだけの数*を許可するよう説得することができる
のでしょうか。もちろんそのトリックは`unsafe`に依存しています。アイデアは
こうです。Rustには不変な参照を使って値を読み取るだけだと*伝え*ます。しかし、
実際には`unsafe`を使って不変な参照を可変な参照に「キャスト」します。
不変な参照はいくつでも作ることができるのでRustは何も気にしません。このようにして
望むだけの可変な参照をすべて手にすることができます。

そのような関数は次のようになるでしょう。

```rust
// この関数は絶対に存在してはならない
fn make_mut<T>(value: &T) -> &mut T {
    unsafe { /* マジック */ }
}
```

警鐘が鳴り響くはずです。これまで提案してきたものは安全性に問題があるからです。
`unsafe`の中で行うすべてのことは必ずRustのルールを守る必要があることを
思い出してください。これまで提案してきたことは明らかにそうではありません。
現状では「可変な参照は一度に最大1つ」、すわなち、プログラムのどの時点においても
値は最大1つしか可変な参照をもてないというルールに違反しています。

我々の要求を満たした上でこのルールを守るための重要な洞察は次の通りです。
*コンパイラ*に所有権と借用チェッカーでルールをチェックさせる代わりにルールが
*実行時に動的に*維持されることを保証することです。これにより、構造体への参照を
（`&`参照経由で）何度でも共有できるようになり、同時に必要なときには
（`&T -> $mut T` 動的借用チェック関数により）可変な参照を安全に取り出すことが
できるようになります。

このアイデアの具体的な実装はたくさんあります。そのような実装の1つは、ロックを使って
可変な参照を一度に1つしか返さないようにするものです。

```rust
fn lock<T>(value: &T) -> Locked<&mut T> {
    unsafe { lock(value); cast value to Locked<&mut T> }
}

impl Drop for Locked<$mut T> {
    fn drop(&mut self) { unlock(self.value) }
}
```

これは`RefCell::borrow_mut()`です。さらにもう1つは排他的であることが分かって
いる場合にだけ可変な参照を返すことです。

```rust
fn get_mut<T>(value: &T) -> Option<Mut<&mut T>> {
    unsafe {
        if ref_count(value) !=0 { None }
        else {
            ref_count(vaue) += 1;
            Some(cast value to Mut<&mut T>)
        }
    }
}

impl Drop for Mut<&mut T> {
    fn drop(&mut self) { ref_coount(value) -= 1; }
}
```

これは`RefCell::try_borrow_mut()`です。これらの例はすべて何らかの形で
「内部可変性」を実装しています。すなわち、不変な参照を通じて値を可変な
ものにしています。私たちの`Console`では`Mutex`を使ってこの目的を達成します。
`std::Mutex`の実装にはOSのサポートが必要なので`kern/src/mutex.rs`に独自の
`Mutex`を実装しました。この実装は今のところ正しいのですが、キャッシュや並行
性を導入する際にはRustのルールを守るために修正する必要があります。
現時点では`Mutex`の実装を理解する必要はありませんがその使い方は理解して
おく必要があります。

グローバルなシングルトンは`kern/src/console.rs`において`CONSOLE`として宣言されて
います。このグローバル変数は以下で定義する`kprint!`マクロと`kprintln!`
マクロで使用されています。`Console`を実装したら`kprint!`と`kprintln!`を使って
コンソールに表示きるようになります。また、`CONSOLE`を使ってグローバルに
コンソールにアクセスすることもできるようになります。

**注記: Rustでは`static`なグローバルは`Sync`であることも要求します**
> 型`T`の値を`static`なグローバルに格納するためには`T`は`Sync`を実装する必要が
> あります。これはRustがコンパイル時にデータの競合安全性も保証するためです。
> グローバル値は任意のスレッドからアクセスできるため、Rustはそれらのアクセスが
> スレッドセーフであることを保証しなければなりません。`Send`トレイトと`Sync`
> トレイトはRustの所有権システムとともにデータ競合がおきないことを保証します。

**質問 (drop-container): なぜ`&mut T`を直接返してはいけないのですか**
> これまで紹介したすべての例で可変な参照はコンテナにラップされ、そのコンテナには
> `Drop`が実装されていることに気づいたと思います。代わりに`&mut T`を直接
> 返したら何が問題になるでしょうか。

**質問 (write-fmt): `write_fmt`を呼び出すとどのメソッドが実行されますか**
> `_print`ヘルパー関数は`Mutex<Console>::lock()`の戻り値である
> `MutexGuard<Console>`のインスタンスに対して`write_fmt`を呼び出しています。
> 呼び出さる`write_fmt`メソッドはどの型が持っていて、そのメソッドは
> どこで実装されていますか。

    Rust Programming Language: 16.3 応対共有並行性を参照

#### `Console`の実装とテスト

`kern/src/console.rs`の`unimplemental!()`メソッドをすべて実装してください。
すべてを実装したら`kern/src/main.rs`で`kprint!!`マクロと`kprintln!`
マクロを使って受け取った文字をコンソールに書き込んでください。これらの
マクロは`print!`や`println!`とまったく同じように使うことができます。
`screen /dev/<your-path> 115200`を使ってpiと通信してカーネルが期待どおりに
どうすることを確かめてください。

**注記: これがC言語だったら**
> 労力をかけることなく自由に`println!`の実装を手に入れられたという事実は
> Rustを使うもう1つの利点です。これがC言語だったら自分で`printf`を実装する
> 必要があります。Rustではコンパイラが汎用的で抽象化されたOSに依存しない
> 安全な実装を提供してくれます。やったね。

**ヒント**
> `Console`の実装は非常に短いはずです。各関数1行程度でしょう。

#### シェルの実装

これで`kern/src/shell.rs`にシェルを実装する準備ができました。`Command`
構造体を用意しました。`Command::parse()`メソッドは簡単なコマンドライン
引数パーサであり、`Command`構造体を返します。このパースメソッドは渡された
文字列を空白で分割し、渡された`buf`をストレージとして使い、空でない引数を
すべて`StackVec`として`args`フィールドに格納します。`Command::path()`は
自分で実装する必要があります。

利用可能なライブラリ（`Command`, `StackVec`, `CONSOLE`経由の`Console`,
`kprint!`, `kprintln!`などすべて）のすべてを使って`shell`関数にシェルを
実装してください。作成するシェルは入力を待つ各行に`prefix`文字列を表示
する必要があります。たとえば上のGIFではprefixとして`"> "`が使用されて
います。作成するシェルは次にユーザ入力を1行読み込んでコマンドにパースし、
その実行を試みます。シェルはこれを無限に繰り返します。私たちのOSはまだ
始まったばかりなので、まだ面白いコマンドを実行することはできません。
しかし、`echo`などの既知のコマンドをシェルに組み込むことはできます。

実装を完成させるにシェルは次のようにする必要があります。

- ビルトイン`echo`の実装: `echo $a $b $c`は`$a $b $c`を表示する
- 行の終わりを示す"入力文字"として`\r`と`\n`を共に受け付ける
- 一文字消去としてbackspaceとdelete (ASCIIの`8`と`127`) を共に受け付ける
- 認識できない非可視文字が入力された場合はベル（ASCII `7`）を鳴らす
- 未知のコマンド `$command`に対しては`unknown command: $command`を表示する
- prefixを超えるバックスペースは禁止する
- 許可された文字数以上の入力は禁止する
- 最大512バイトのコマンドを受け付ける
- コマンドあたり最大64個の引数を受け付ける
- ユーザが空コマンドを入力した場合はエラーとせずprefixをつけて新規入力行を表示する
- 引数が多すぎる場合は`error: too many arguments`と表示する。

`kern/src/main.rs`から新しい`shell()`関数を呼び出して作成した実装を
テストしてください。"SOS"バナーを除けば上のGIFを再現できるはずです。
また、設定したすべての要件をテストできるはずです。シェルが期待通りに
動いたら達成感に浸ってください。そして次の段階に進んでください。

**ヒント**
> バイトリテラル`b'a'`は文字`'a'`の`u8`ASCII値です。

**ヒント**
> ASCIIバイト値`b`を持つ任意の文字を表示するには文字列リテラルである`\u{b}`を使ってください。

**ヒント**
> 新しい行を始めるにはその行の開始地点で`\r`と`\n`を共に出力する必要が
> あります。

**ヒント**
> 文字を削除するには、バックスペース、空白文字出力、再度バックスペースを
> 出力してください。

**ヒント**
> ユーザの入力バッファには`StackVec`を使ってください。

**ヒント**
> [core::str::from_utf8()](https://doc.rust-lang.org/nightly/core/str/fn.from_utf8.html)が参考になるでしょう。

**質問 (shelll-lookback): 作成したシェルはこれまで作成した多くのピースをどのように結びつけていますか**
> 作成したシェルはこれまでに回たコードの多くを利用しています。どの部分を
> どのように使っているか、簡単に説明してください。

## フェーズ 3: 起動

このフェーズではこれまでに作成したものをすべて使ってRaspberry Pi用の
ブートローダを実装します。主に`boot/src/main.rs`で作業します。

新しいバイナリをPiにロードするためにMicroSDカードを交換する単調な動作に
うんざりしているでしょう。このフェーズで書くブートローダはこのプロセスを
完全に排除します。MicroSDにあるバイナリを*もう一回だけ*入れ替えます。
ここではブートローダでロードします。これ以降はMicroSDカードに触れること
なくコンピュータからリモートで新しいバイナリをロードできるように
なります。

ブートローダ自体はUART経由でXMODEMファイル転送を受け付ける「カーネル」の
ようなものです。受け取ったデータを既知のアドレスのメモリに書き込んで
実行します。`ttywrite`ユーティリティを使ってバイナリを送信します。
これにより新しいバイナリをPiにロードするプロセスは以下のように簡単に
なります。

1. Piをリセットしてブートローダーを起動する
2. (`kern`ディレクトリで)`make transmit`コマンドを実行する。これは
   カーネルをビルドし、`ttywrite -i build/kern.bin /dev/ttyUSB0`
   コマンドで送信する。

### バイナリのロード

Raspberry Pi 3はデフォルトでは`kernel8.img`という名前のファイルを
アドレス`0x80000`にロードします。言い換えると、Piは`kernel8.img`の
内容を`0x80000`に順次コピーし、初期化した後、ARMのプログラムカウンタを
`0x80000`に設定します。そのため、バイナリがこのアドレスにロードされる
ことを期待できるようにする必要があります。これはバイナリ内のすべての
アドレスが`0x80000`から始まることを意味します。

バイナリ内のすべてのシンボルのアドレスを決定するのはリンカなので、
何らかの方法でリンカにこの希望を伝える必要があります。これを行うために
*リンカスクリプト*を使用します。これはリンカが読み込むファイルであり、
バイナリ内のシンボルにどのようにアドレスを割り当ててほしいかを記述
します。カーネルのリンカスクリプトは`kern/.cargo/layout.ld`にあります。
2行目にアドレス`0x80000`があることに気付いたでしょう。実際、この行は
アドレスの割り当てを`0x80000`から開始するようリンカに指示しています。

このデフォルトとの互換性を維持するためにブートローダのバイナリ*も*
アドレス`0x80000`にロードします。しかし、これは問題を発生します。
ブートローダのバイナリがアドレス`0x80000`にあると同じアドレスに別の
バイナリをロードすると*ブーロローダを実行する*とブートローダが上書き
されてしまいます。この衝突を避けるにはブートローダとブートローダが
ロードするバイナリとで異なる開始アドレ スを使わなければなりません。
Piのデフォルトとの互換性を維持したいのでブートローダの開始アドレスを
変更する必要があります。どのようにすればよいのでしょうか。

### スペースを作る

第一段階は新しいアドレスを選択することです。`boot/.cargo/layout.ld`を
みるとわかるようにブートローダの開始アドレスとして`0x4000000`を選択
しました。これでバイナリのアドレスは固定されましたが、Piは引き続き
それを`0x80000`にロードしようとします。ありがたいことにファームウェアの
`config.txt`の`kernel_address`パラメータを使うと、別のアドレスで
バイナリをロードするようにPiに要求することができます。microSDにある
`config.txt`を修正して`kernel_address=0x4000000`の行があることを確認
してください。

この変更により`0x80000`と`0x4000000`の間のメモリはブートローダによって
完全に使用されなくなり、`0x4000000 - 0x80000`バイトまでのバイナリを
コンフリクトなしにロードできるようになります。

**質問 (small-kernales): 63.5MiBで本当に十分ですか**
> この空きスペースでは足りないと思うかもしれません。その懸念は正しい
> ものです。この質問に答える一つの方法は成功しているOSのカーネルの
> ファイルサイズを見ることです。収まるでしょうか。
>
> あなたが今動かしているOSのカーネルバイナリがどれくらいの大きさかを
> 調べてください。新しいバージョンのmacOSのバイナリは`/System/Library/> Kernels/kernel`です。
> 古いバージョンのmacOSのバイナリは`/mach_kernel`です。Linuxの場合は
> 通常、バイナリは`/boot/`にあり、その名前は`vmlinuz`, `vmlinux`,
> `bzImage`のいずれかです。あなたのカーネルのバイナリの大きさはどれ
> くらいですか。私たちが作成した63.5MiBの空き領域に収まるでしょうか。

    Macは`/System/Library/Kernels/kernel`で`17.773.224`バイト。
    Linuxは`/boot/vmlinuz-5.15.0-101-generic`で`11.634.824`バイト

### ブートローダの実装

`boot/src/main.rs`にブートローダを実装します。ファイルの先頭の
`const`宣言でブートローダの開始アドレス、ロードされるバイナリの開始
アドレス、最大バイナリサイズを宣言しました。また、アドレス`addr`に
無条件に分岐する`jump_to`関数も用意しました。この関数はプログラム
カウンタをそのアドレスに設定します。ブートローダはこれらの宣言と
`pi`ライブラリと`xmodem`ライブラリの既存のコードを使用してUART経由で
送信されるバイナリを受信し、そのバイナリがロードされると期待するメモリ
アドレスに書き込みます。送信が完了したらブートローダは新しいバイナリを
実行します。

ブートローダは低いタイムアウト値（たとえば、750ms）を設定し、タイム
アウトが発生したら新たな受信を試みるようにして、継続的にXMODEMの
受信を開始するようにする必要があることに注意してください。それ以外の
理由で受信に失敗した場合は、エラーメッセージを表示して再試行して
ください。ブートローダを実装したら`ttywrite`ユーティリティを使って
`kern/build/kernel.bin`からPiにカーネルバイナリを送ってテストして
ください。すべてが上手く行けばPiに`screen`で接続するとシェルが表示
されるはずです。

**質問 (bootloader-timeout): タイムアウトはなぜ必要ですか**
> ブートローダがタイムアウトして受信を再試行することがないと何らかの
> 条件下で送信が無期限にストールする可能性があります。その条件はどの
> ようなもので、なぜ送信が無期限にストールするのでしょうか。

**config.txt**
> ブートローダのバイナリと互換性のあるバージョンの`config.txt`を使う
> ことを忘れないでください。

**ヒント**
> `main()`関数のレフアレンス実装のコードは15行でした。

**ヒント**
> `core::slice::from_raw_parts_mut()`関数が役にたちます。

**ヒント**
> `mut [u8]`型は`io::Write`を実装しています。
