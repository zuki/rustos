# Lab 2: Shellとブートローダ

## はじめに

この課題ではRaspberry Pi用の便利なユーティリティとライブラリ、
簡単なシェルを書きます。また、GPIO、UART、内蔵タイマー用の汎用ドライバも
書きます。最後に新しいドライバを使った「ブートローダ」を書きます。
これはXMODEMプロトコルを使ってUART経由でプログラムバイナリをロードして
実行します。

### スケルトンコードの取得

[一部省略]

```bash
.
├── bin : common binaries/utilities
├── doc : reference documents
├── ext : external files (e.g., resources for testing)
├── tut : tutorial/practices
│    ├── 0-rustlings
│    ├── 1-blinky
│    └── 2-shell : questions for lab2 *
├── boot : bootloader *
├── kern : the main os kernel *
└── lib  : required libraries
     ├── pi *
     ├── shim
     ├── stack-vec *
     ├── ttywrite *
     ├── volatile *
     └── xmodem *
```

以下のようなディレクトリ構成を勧めます。`kern`ディレクトリで`make`を
実行してディレクトリが適切に配置されていることを確認してください。
問題がなければコマンドは成功します。問題がなければリポジトリの中身を
自由に調べてください。

今回と今後の課題には回答しなければならない*質問*が含まれています。
以下はそのような質問の例です。

``質問 (1-blinky): 他のGPIOピンの設定はどのようにしますか**
> 課題1-blinkyではレジスタ`GPFSEL1`, `GPSET0`, `GPCLR0`に書き込む
> ことで、GPIOピン16を出力として有効にしてセットとクリアを繰り返し
> ました。GPIOピン27に対して同じことを行うにはどの3つのレジスタに
> 書き込みますか? Raspberry Piのどの物理ピンがGPIOピン27に対応して
> いますか。

質問にある括弧内の単語は質問が出題されているラボ名相対の`questions/`
ディレクトリにあるファイル名を示しています。たとえば、この
`Lab2: Shellとブーロローダ`のすべての質問は`tut/2-shell/questions/`
サブディレクトリに回答する必要があります。すべての質問に対して
あらかじめ空のファイルが生成されていることに注意してください。

上の`1-blinky`の質問に答えて質問に回答する練習をしてください。

## フェーズ 1: 酸化

このフェーズでは2つのライブラリと1つのコマンドラインユーティリティを
書き、1つのライブラリをレビューします。`lib`ディレクトリにある
`stack-vec`, `volatile`, `ttywrite`, `xmodem`の各スケルトンサブ
ディレクトリで作業することになります。

すべてのプロジェクトはCargoで管理されています。以下の`cargo`コマンドが
便利です。

- `cargo build` - アプリケーションやライブラリをビルドします
- `cargo test` - アプリケーションやライブラリをテストします
- `cargo run` - アプリケーションを実行します
- `cargo run -- $flags` - アプリケーションを実行し、任意のフラグを渡します

Cargoの使い方やCargoの動作についての詳細は[Cargo Book](https://doc.rust-lang.org/cargo/index.html)を参照してください。

### サブフェーズ A：`StackVec`

オペレーティングシステムが提供する重要な機能のひとつはメモリの割り当て
です。C、Rust、Java、Pythonなど、*どんな*アプリケーションも`malloc()`
を呼び出します。`malloc()`はOSからのメモリーを使い果たした場合、最終
的にはシステムコールで追加のメモリーを要求します。OSは利用可能な
メモリがあるか判断して、あればメモリの要求を満たします。

**注記: メモリの割り当ては複雑な話です**
> 実際、Linuxなどの現代のオペレーティングシステムはメモリ割り当てと
> 複雑な関係にあります。たとえば、最適化のためメモリ割り当ての要求の
> ほとんどは「仮想的に」処理されるだけです。物理メモリへの割り当ては
> アプリケーションが新しく割り当てられたメモリを使おうとするまでは
> 実際には行われません。そうではありますが、ほとんどのOSはこれまで
> 説明したような単純化された方法でメモリを割り当てているかのように
> *錯覚させる*ことを目指しています。OSはウソつきの名人です（🍰）。

`Vec`, `String`, `Box`などのヒープに割り当てられる構造体は必要に応じて
内部的に`malloc()`を呼び出してメモリを割り当てます。これはこれらの
構造体が機能するためにはOSのサポートが必要であることを意味します。
中でもOSがメモリ割り当てをサポートすることを必要とします。私たちは
まだOSを書き始めてはいません。私たちの小さなベアメタルプログラムが
利用できるメモリ割り当てのサポートがないのは明らかです。そのため、
私達のOSが進化するまでは`Vec`のようなヒープ割り当ての構造体を使う
ことはできません。

`Vec`は素晴らしい抽象化なのでこれは本当に残念です。Vecを使えば自分で
メモリを管理することなく要素の`push`と`pop`を考えることができます。
*メモリ割り当てをサポートすることなく`Vec`の抽象化の利点を得るにはどうすればいいでしょうか？*

一般的なテクニックのひとつはメモリを*事前に割り当て*、そのメモリを
構造体に渡して抽象化する方法です。メモリを事前に割り当てる方法には
`static`宣言を使ってバイナリのstatic sectionにメモリを割り当てる方法や
ローカル変数を宣言してスタック割り当てを使う方法などがあります。
いずれにせよ、割り当ては事前に決めた固定サイズで行われます。

このサブフェーズでは`StackVec`構造体を実装します。この構造体は事前に
割り当てられたメモリを与えられると`Vec`ライクなAPIを提供します。
`StackVec`型はフェーズ 2でRaspberry Pi用のシェルを実装する際に使用
します。`lib/stack-vec`スケルトンサブディレクトリで作業します。この
サブディレクトリには以下のファイルがあります：

- Cargo.toml` - Cargoの構成ファイルです
- `src/lib.rs` - ここにコードを記述します
- `src/tests.rs` - `cargo test`が呼ばれたときに実行されるテストです

### `StackVec`インタフェース

`StackVec<T>`は`StackVec::new()`に任意の型`T`の値の可変スライスを
渡して呼び出すことで生成されます。`StackVec<T>`型は[Vec](https://doc.rust-lang.org/nightly/std/vec/struct.Vec.html)が
実装しているメソッドの多くを実装しており、ほとんど同じように使われます。
以下は`StackVec<u8>`の使用例です。

```rust
let mut storage = [0u8; 10];
let mut vec = StackVec::new(&mut storage);

for i in 0..10 {
    vec.push(i * i).expect("can push 10 times");
}

for (i, v) in vec.iter().enumerate() {
    assert_eq!(*v, (i * i) as u8);
}

let last_element = vec.pop().expect("has elements");
assert_eq!(last_element, 9 * 9);
```

`StackVec`構造体はすでに宣言してあります。

```rust
pub struct StackVec<'a, T: 'a> {
    storage: &'a mut [T],
    len: usize
}
```

### `StackVec`の理解

以下の質問は`StackVec`インタフェースについての理解度をテストする
ものです。

**質問 (push-fails): なぜ`push`は`Result`を返すのか**
> 標準ライブラリにある`Vec`の`push`メソッドには戻り値がありませんが
> `StackVec`の`push`メソッドには戻り値があります。失敗する可能性が
> あることを示す`Result`を返します。`Vec::push()`は失敗しないのに
> なぜ`StackVec::push()`は失敗する可能性があるのですか。

    Vecはあらかじめ確保した領域を超えてpushすると自動的にメモリを
    割り当て直すため失敗しない。一方、StackVecの割り当て領域は
    静的に決められているのでこの領域を超えてpushしようとすると失敗
    する。

**質問 (lifetime): `T`に`'a`を束縛する必要があるのはなぜか**
> `struct StackVec<'a, T> { buffer: &'a mut [T], len: usize }`
>
> Rustは束縛`T: 'a`を自動的に強制し、`T`型のライフタイムが`'a`より
> 短いと文句を言います。たとえば、`T`が`&'b str`で`'b`が`'a`より
> 実際に短い場合、Rustは`StackVec<'a, &'b str>`のインスタンスの作成を
> 許しません。
>
> この束縛が必要なのはなぜですか。この束縛をRustが強制しなかったと
> したら何が問題になりますか？

**質問 (clone-for-pop): `StackVec`が`pop()`に`T: Clone`を必要とするのはなぜですか？**

> 標準ライブラリの`Vec<T>`の`pop`メソッドはすべての`T`に対して実装されて
> いますが、`StackVec`の`pop`メソッドは`T`が`Clone`トレイトを実装して
> いるときにしか実装されていません。なぜですか。この束縛を取り除くと
> 何が問題になりますか。

### `StackVec`の実装

`stack-vec/src/lib.rs`にある`StackVec`の`unimplemented()` メソッドをすべて
実装してください。各メソッドはソースコードに記述されています。また、実装が
正しいことを確認するためのテストが`src/tests.rs`に用意されています。
これらのテストは`cargo test`で実行できます。また、`cargo test`にすべて
パスするためには`StackVec`の`Deref`, `DerefMut`, `IntoIteratorPトレイトと
`&StackVec`の`IntoIterator`も実装する必要があります。実装が正しいと確信し、
このサブフェーズの質問に答えられたら、次のサブフェーズに進んでください。

**質問 (deref-in-tests): 度のテストが`Deref`の実装を使用していますか**
> `src/tests.rs`にあるテストに目を通してください。`Deref`の実装がないと
> どのテストがコンパイルに失敗しますか。`DerefMut`の実装についてはどう
> ですか。それはなぜですか。

**警告: 提供したユニットテストは不完全です**
> 提供したユニットテストは*基準となる*真実を提供しますが完全ではありません。
> 課題を採点する際には追加のテストを実施します。これらのテストの違いを
> 見つけて、それを埋めるためにあなた自身のテストを追加したらよいかも
> しれません。

### サブフェーズ B: `volatile`

このサブフェーズではvolatileメモリアクセスについて学び、スケルトンサブ
ディレクトリ`volatile`にあるソースコードを読み、ソースコードに関連する
質問に答えます。このサブフェーズではコードを書くことはありません。

OS同様、コンパイラはあなたが考えていることをあたかも実際にやっているかの
ように*見せる*名人です。実際には最適化のためにまったく別のことをやっています。
そのような最適化のひとつがデッドアクセスの除去です。コンパイラはそうする
ことがプログラムの実行に観察できる影響を与えないことが証明できる場合、
メモリアクセス (Read/Write) を削除します。たとえば、次のようなプログラムを
考えます。

```rust
fn f() {
    let mut x = 0；
    let y = &mut x；
    *y = 10;
}
```

コンパイラは`*y`は書き込み後に読まれることはないと推論することで`*y`への
書き込みを完全に排除することができます。その結果、コンパイラは書き込みが
プログラムに影響を与えることはあり得ないと結論づけ、コンパイル済みバイナリ
から削除します。同じ理由で`y`の宣言、`x`の宣言、そして`f()`の呼び出しも
完全に削除することができます。

このような最適化はほぼ例外なく有益です。その結果に影響を与えることなく
プログラムを高速化するからです。ただし、こうした最適化が意図しない結果を
もたらすこともあります。たとえば、`y`が書き込み専用のメモリマップド
レジスタを指しているとします。その場合、`*y`への書き込みはその後`*y`を読み
込ま*なくても*観測可能な効果を持つことに*なる*。コンパイラがこのことに
気づかなければこれらの書き込みを最適化で削除してしまいプログラムは正しく
機能しなくなります。

ソースコードレベルでは何の影響もないように見える読み書きを保持するよう
コンパイラに強制するにはどうすればいいでしょうか。ここで`volatile`メモリ
アクセスの出番です。コンパイラはvolatileメモリアクセスを最適化で除去*しない*
ことを約束します。したがって、実行時に確実に読み書きが行われるようにしたい
のであればvolatileメモリアクセスを行う必要があります。

### Rust流`valatile`

Rustでは生ポインタへのvolatile読み書きを行うのに`read_volatile`メソッドと
`write_volatile`メソッドを使用ます。

``注記: 生ポインタとはなにか**
> 参照（`&T`と`&mut T`）についてはもうお馴染みでしょう。Rustの生ポインタ
> （`*const T`と`*mut T`）はRustの借用チェッカがライフタイムを追跡しない
> 「参照」です。このため、これらのポインタへの読み書きはC言語と同じく不正に
> なる可能性があります。Rustはこれらのポインタを`unsafe`であるとみなします。
> これらを読み書きするコードにはそのことを示す`unsafe`アノテーションを付ける
> 必要があります。詳細は[rustdocsの生ポインタの項](https://doc.rust-lang.org/nightly/std/primitive.pointer.html)を
> 参照してください。

volaite読み書きを行うたびに`read_volatile`や`write_volatile`を呼び出すのは
エラーの原因であり、面倒です。ありがたいことにRustはこれを簡単かつ安全に
するツールを提供しています。理想は（C言語のように）単にポインタをvolatileと
宣言するとそれ以降のすべての読み書きがvolatileであることが保証されることです。
さらに良いのは、（C言語とは異なり）ポインタを読み取り専用、書き込み専用、
読み書き可能と宣言し、適切なメモリアクセスだけが行えるようにすることです。

### `Volatile`, `ReadVolatile`, `WriteVolatile`, `UniqueVolatile`の導入

スケルトンサブディレクトリ`volatile/`にある`volatile`クレートはこれだけを
行うことができる4つの型を実装しています。`volatile/`ディレクトリで
`cargo doc --open`を実行しこれらの型のドキュメントを読んでください。

**質問 (unique-volatile): `Unique<Volatile>`が存在するのはなぜ**
> `Volatile`も`Unique<Volatile>`も裏にあるポインタへのvolatile read/write
> アクセスを許可します。ドキュメントによるとこの2つの型の違いは何ですか。

    `Unique<Volatile>`はラップしている`Volatile`型のジェネリックが
    `T: Sync`の場合、Syncトレイトが実装される。

`src/lib.rs`, `src/traits.rs`, `src/macros.rs`のソースコードを開いて
ください。力の及ぶ限りソースコードに目を通してください。準備ができたら
以下の質問に答えてください。これらの質問に答えることができたら次の
サブフェーズに進む準備ができています。

**注記: `#[repr(c)]`とはなんですか**
> `[repr(C)]`アノテーションは構造体のフィールドをC言語と同じようにレイアウト
> するようRustに強制します。一般にRustは構造体のフィールドの順序や
> パディングを不特定の方法で最適化します。生のアドレスを構造体へのポインタに
> キャストする場合、通常は特定のメモリレイアウトを念頭に置いています。
> `[repr(C)]`アノテーションを使うことでRustが思い通りに構造体を配置する
> のではなく、私たちが意図したとおりに配置することができます。

**質問 (enforcing): Read-onlyとWrite-onlyのアクセスはどのように強制されていますか**
> `ReadVolatile`型と`WriteVolatile`型はそれぞれ裏にあるポインタへの
> 書き込みと読み込みを不可能にします。これはどのようにして実現されて
> いますか。

    内部の生ポインタをread-onlyでは*const T、write-onlyでは*mut Tに解決する
    ことで対象外の利用を防いでいる

**質問 (macros): マクロは何をするものですか**
> `readable!`, `writeable!`, `readable_writeable!`マクロはそれぞれ
> 何をしますか。

    readbleとwriteableは内部の生ポインタを解決して取り出すinner()を定義して
    いる。readable_writeableはジェネリック型TにBitAnd, BitOrトレイト境界を
    設定している。

### サブフェーズ C: `xmodem`

このサブフェーズでは`xmodem/`スケルトンサブディレクトリの`xmodem`
ライブラリにXMODEMファイル転送プロトコルを実装します。主に
`xmodem/src/lib.rs`で作業することになります。

XMODEMはもともと1977年に開発されたシンプルなファイル転送プロトコルです。
パケットチェックサム、キャンセル、自動再送の機能を持っています。広く
実装されておりシリアルインタフェース経由の転送に使われています。しかし、
このプロトコルの最大の特徴はそのシンプルさです。その歴史の詳細については
Wikipediaの[XMODEMの記事](https://ja.wikipedia.org/wiki/XMODEM)を参照
してください。

ここではRaspberry Piへのファイル転送にXMODEMプロトコルを使います。
Piへのデータ*送信*には既存のXMODEMプロトコルの実装を使つこともできました
が、それでも独自のレシーバを書く必要はあります。そこでついでにXMODEMの
送信も実装することにします。

### プロトコル

XMODEMプロトコルの詳細は[Understanding The X-Modem File Transfer Protocol](https://cs140e.sergio.bz/assignments/1-shell/data/XMODEM.txt)
テキストファイルに記載されています。後世のためにここでもう一度言って
おきます。

**警告: ウィキペディアの説明に基づいて実装してはいけません**
> ウィキペディアの説明は高いレベルでは役に立ちますがそこに記載されている
> 詳細の多くはここで実装しようとしているプロトコルとは異なります。
> そのため、このサブフェーズのリファレンスとしてこの記事を使用しては
> いけません。

XMODEMはバイナリプロトコルです。バイトは生で送受信されます。また
"半二重"です。どの時点でも送信側か受信側のいずれかがデータを送信して
いますが、一度に両方が送信することはありません。最後にこのプロトコルは
パケットベースです。データはパケットと呼ばれる128バイトのチャンクに
分割されます。プロトコルはどのバイトがいつ送信され、それが何を意味し、
どのように解釈されるかを規定しています。

まず、いくつかの定数を定義します。

```rust
const SOH: u8 = 0x01;
const EOT: u8 = 0x04;
const ACK: u8 = 0x06;
const NAK: u8 = 0x15;
const CAN: u8 = 0x18;
```

ファイル転送を開始するために受信側は`NAK`バイトを送信し、送信側は`NAK`
バイトを待ちます。送信側が`NAK`バイトを受信するとパケット送信が開始します。
受信側はファイル転送を開始するためにだけ`NAK`バイトを送信します。すべての
パケットごとに送信することはありません。

ファイル転送が開始されると各パケットの送受信は同じものになります。
パケットには1から始まる連番が振られ、255の次は0に折り返されます。

![XMODEMプロトコル図](xmodem.png)

パケットを送信するために送信側は以下を実行します。

1. `SOH`バイトを送信する
2. パケット番号を送信する
3. パケット番号の1の補数 (`255 - $packet_number`) を送信する
4. パケットを送信する
5. パケットのチェックサムを送信する
    * チェックサムはパケットのすべてのバイトの合計のmod 256である
6. 受信側から1バイト読み込む
    * そのバイトが`NAK`の場合、同じパケットの送信を最大10回再試行する
    * そのバイトが`ACK`の場合、次のパケットを送信する

パケットを受信するために受信側はこれと逆のことを行います。

1. 送信側から`SOH`または`EOT`が送信されるのを待つ
    * これとは違うバイトを受信した場合、受信側は転送をキャンセルする
    * `EOT`バイトを受信した場合、受信側は転送を終了する
2. 次のバイトを読み取り、現在のパケット番号と比較する
    * 間違ったパケット番号を受信した場合、受信側は転送をキャンセルする
3. 次のバイトを読み取り、パケット番号の1の補数と比較する
    * 間違った数を受信した場合、受信側は転送をキャンセルする
4. 送信側からパケット（128バイト）を読み取る
5. パケットのチェックサムを計算する
    * チェックサムはパケットのすべてのバイトの合計のmod 256である
6. 次のバイトを読み取り、計算したチェックサムと比較する
    * チェックサムが異なる場合、`NAK`を送信し、同じパケットの受信を再試行する
    * チェックサムが等しい場合、`ACK`を送信し、次のパケットを受信する

転送をキャンセルするには、受信側、送信側のいずれかが`CAN`バイトを送信
します。いずれの側も`CAN`バイトを受信したら、エラーとして接続を中参します。

転送を終了するために送信側は以下を実行します。

1. `EOT`バイトを送信する
2. `NAK`バイトを待つ。異なるバイトを受信した場合、送信側はエラーとする
3. 2回目の`EOT`バイトを送信する
4. `ACK`バイトを待つ。異なるバイトを受信した場合、送信側はエラーとする

転送を終了するために受信側は以下を実行します。

1. `NAK`バイトを送信する
2. 2回目の`EOT`バイトを待つ。異なるバイトを受信した場合、受信側はエラーとする
3. `ACK`バイトを送信する

### XMODEMの実装

XMODEMプロトコルの未完成の実装を`xmodem`スケルトンサブディレクトリに
用意しました。あなたの課題は`src/lib.rs`にある`expect_byte`,
`expect_byte_or_cancel`, `read_packet`, `write_packet`の各メソッドを
書いて実装を完成させることです。実装は`Xmodem`型の内部状態である`packet`と
`started`を利用する必要があります。始める前に既存のコードに目を通す
ことを勧めます。

まず、`expect_byte`メソッドと`expect_byte_or_cancel`メソッドの実装から
始めてください。次に、`read_byte`と`write_byte`を含む4つのヘルパー
メソッドをすべて使用して`read_packet`と`write_packet`を実装してください。
これらのメソッドがどのように使用されるかを知るにはこれらのメソッドを介して
XMODEMを使用した完全なデータストリームを送信または受信する`transmit`と
`receive`の実装を読んでください。ドキュメントコメントにある仕様に注意して
ください。作成した実装は`cargo test`を使ってテストすることができます。
実装が正しいと確信したら次のサブフェーズに進んでください。

**警告: `std`のその他のアイテムは使ってはいけません**

> 実装で使用できるのは`shim::io`のアイテムだけです。`std`やその他の
> ライブラリのアイテムを使用してはいけません。

**ヒント**
> `{read,write}_packet`のリファレンス実装はそれぞれおよそ43行のコードです。

**ヒント**
> `io::Read`と`io::Write`のrustdocsが役に立つでしょう。

**ヒント**
> `?`演算子は惜しみなく使いましょう。

**ヒント**
> テストソースコードが参考になります。

**ヒント**
> `ioerr!`マクロを使うと新たら`io::Error`を簡単に作成して返すことが
> できます。`shim/src/macros.rs`を参照するとさらに便利なマクロを
> 見つけることができます。
