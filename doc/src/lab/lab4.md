# Lab 4: プリエンプティブマルチタスク

- [フェーズ 0: 始めよう](#フェーズ-0-始めよう)
- [フェーズ 1: ARMとLeg](#フェーズ-1-armとleg)
  - [サブフェーズ A: ARMv8概要](#サブフェーズ-a-armv8概要)
  - [サブフェーズ B: 命令](#サブフェーズ-b-命令)
  - [サブフェーズ C: EL1への切り替え](#サブフェーズ-c-el1への切り替え)
  - [サブフェース D: 例外ベクタ](#サブフェース-d-例外ベクタ)
  - [サブフェーズ E: 例外からの復帰](#サブフェーズ-e-例外からの復帰)
- [フェーズ 2: それはプロセス](#フェーズ-2-それはプロセス)
  - [サブフェーズ A: プロセス](#サブフェーズ-a-プロセス)
  - [サブフェーズ B: 最初のプロセス](#サブフェーズ-b-最初のプロセス)
  - [サブフェーズ C: タイマー割り込み](#サブフェーズ-c-タイマー割り込み)
  - [サブフェーズ D: スケジューラ](#サブフェーズ-d-スケジューラ)
  - [サブフェーズ E: スリープ](#サブフェーズ-e-スリープ)
- [フェーズ 3: メモリ管理ユニット](#フェーズ-3-メモリ管理ユニット)
  - [サブフェーズ A: 仮想メモリ](#サブフェーズ-a-仮想メモリ)
  - [サブフェーズ B: ページテーブル](#サブフェーズ-b-ページテーブル)
- [フェーズ 4: ディスクのプログラム](#フェーズ-4-ディスクのプログラム)
  - [サブフェーズ A: プログラムのロード](#サブフェーズ-a-プログラムのロード)
  - [サブフェーズ B: ユーザプロセス](#サブフェーズ-b-ユーザプロセス)

## はじめに

この課題ではプロセスとその関連するインフラストラクチャを実装することで
ユーザレベルのアプリケーションを実現します。特権レベルの切り替えコード、
コンテキストスイッチコード、単純なラウンドロビンスケジューラ、システム
コールハンドラ、仮想メモリサブシステムを作成します。また、いくつかの
ユーザプログラムを書き、それらをロードして新しいプロセスを開始します。

## フェーズ 0: 始めよう

ラボ4用のアップデートをgitリポジトリから開発マシンに取得します。

```bash
$ git fetch skeleton
$ git merge skeleton/lab4
```

リポジトリのディレクトリ構造は次のようになります。この課題で作業する
ディレクトリには`*`がついています。

```bash
.
├── bin : common binaries/utilities
├── doc : reference documents
├── ext : external files (e.g., resources for testing)
├── tut : tutorial/practices
│    ├── 0-rustlings
│    ├── 1-blinky
│    ├── 2-shell
│    ├── 3-fs
│    └── 4-spawn : questions for lab4 *
├── boot : bootloader
├── kern : the main os kernel *
├── lib  : required libraries
│     ├── aarch *
│     ├── kernel_api *
│     ├── fat32
│     ├── pi
│     ├── shim
│     ├── stack-vec
│     ├── ttywrite
│     ├── volatile
│     └── xmodem
└── user  : user level program *
      ├── fib *
      └── sleep *
```

作業を進める前にコンフリクトを解決する必要があるかもしれません。
たとえば、次のようなメッセージが表示された場合です。

```bash
Auto-merging kern/src/main.rs
CONFLICT (content): Merge conflict in kern/src/main.rs
Automatic merge failed; fix conflicts and then commit the result.
```

コンフリクトを解決するには`main.rs`を手動で修正する必要があります。
ラボ 3で変更した内容がすべて保持されていることを確認してください。
すべてのコンフリクトが解決したら解決したファイルを`git add`して
コミットしてください。マージコンフリクトの解決方法については
githowto.com のチュートリアルを参照してください。

### ARMドキュメント

この課題では次の3つのARM公式文書を参照します。

- [ARMv8リファレンスマニュアル](../arm_docs/ARMv8-Reference-Manual.pdf)

  ARMv8アーキテクチャの公式リファレンス マニュアルです。これは一般的な
  方法でアーキテクチャ全体をカバーする包括的なマニュアルです。Raspberry
  Pi 3向けのアーキテクチャの具体的な実装についてはARM Cortex-A53
  マニュアルを参照してください。このマニュアルのセクションを参照する
  場合は([ref:](../arm_docs/ARMv8-Reference-Manual.pdf) C5.2) という形で示します。これは[ARMv8リファレンスマニュアル](../arm_docs/ARMv8-Reference-Manual.pdf)の
  セクション C5.2を参照する必要があることを示します。

- [ARM Cortex-A53マニュアル](../arm_docs/ARM-Cortex-A53-Manual.pdf)

  Raspberry Pi 3で使用されているARMv8 (v8.0-A)アーキテクチャの具体的な
  実装に関するマニュアルです。このマニュアルのセクションを参照する
  場合は([A53](../arm_docs/ARM-Cortex-A53-Manual.pdf): 4.3.30)という形で示します。これは[ARMv8リファレンスマニュアル](../arm_docs/ARM-Cortex-A53-Manual.pdf)の
  セクション 4.3.30を参照する必要があることを示します。

- [ARMv8-Aプログラマガイド](../arm_docs/ARMv8-A-Programmer-Guide.pdf)

  ARMv8-Aプロセスのプログラミング方法に関する高水準手引きドです。
  このマニュアルのセクションを参照する
  場合は([guide](../arm_docs/ARMv8-A-Programmer-Guide.pdf): 10.1)という形で示します。これは[ARMv8-Aプログラマガイド](../arm_docs/ARMv8-A-Programmer-Guide.pdf)の
  セクション 10.1を参照する必要があることを示します。

これら3つのドキュメントはすべて`doc/src/arm_docs`サブディレクトリに
あります。今すぐこれら3つのドキュメントをダウンロードしてすぐ手の届く
ところに置いておくことを勧めます。

## フェーズ 1: ARMとLeg

このフェーズではARMv8アーキテクチャについて学び、下位特権レベルへの
切り替え、例外ベクタのインストールし、タイマー割り込みの有効化、
デバッグシェルの起動によるブレークポイント例外の処理を行います。ARM
アーキテクチャの例外レベルについて学習し、アーキテクチャが例外、割り込み、
特権レベルをどのように扱うかを学びます。

### サブフェーズ A: ARMv8概要

このサブフェーズではARMv8アーキテクチャについて学習します。コードを書く
ことはありませんが、アーキテクチャに関するいくつかの質問に答えることに
なります。

ARM (Acorn RISC Machine) CPUアーキテクチャは30年以上の歴史があります。
主要なリビジョンが8つあり、最新のリビジョンが2011年に導入されたARMv8-A
です。Broadcom BCM2837 SOCにはARMv8.0-AベースのCPUであるARM Cortex-A53が
搭載されています。Cortex-A53（やその他の特定のCPU）はこのアーキテクチャの
実装と呼ばれます。これはこれまで3回の課題でプログラミングしてきたた
CPUです。

**注記: モバイル市場を支配するARM CPU**
> ARM CPUはモバイル市場を支配しており、世界中で販売されているスマート
> フォンの95％以上、アップルのiPhoneやグーグルのPixelを含むフラッグシップ
> スマートフォンのほぼ100％に搭載されています。

これまでは基礎となるアーキテクチャーの詳細については不問とし、Rust
コンパイラーに任せてきました。しかし、ユーザ空間でプロセスを実行できる
ようにするには最下位レベルでCPUを直接プログラミングする必要があります。
CPUを直接プログラミングするにはCPUネイティブのアセンブリ言語と全体的な
概念に精通する必要があります。まず、アーキテクチャの概要から説明し、
次に、いくつかの主要なアセンブリ命令について説明します。

#### レジスタ

ARMv8アーキテクチャには以下のレジスタがあります (ref: B1.2.1)。

- `r0`...`r30` - 64ビットの汎用レジスタ

  これらのレジスタはエイリアスによりアクセスされます。レジスタ
  `x0`...`x30`はこれらのレジスタの64ビット全体のエイリアスです。レジスタ
  `w0`...`w30`はこれらのレジスタの最下位32ビットのエイリアスです。

- `lr` - 64ビットのリンクレジスタ: `x30`のエイリアス

  _リンクアドレス_ の格納に使用されます。`bl <addr>`命令は次の命令の
  アドレスを`lr`に格納し、`addr`に分岐します。`ret`命令は`lr`の
  アドレスをPCにセットします。

- `sp` - スタックポインタとして使用

  スタックポインタの下位32ビットは`wsp`でアクセスできます。スタック
  ポインタは常に16バイトアラインされていなければなりません。

- `pc` - プログラムカウンタ

  このレジスタは読み込みはできますが、書き込むことはできません。`pc`は
  分岐命令と例外のエントリ/リターンで更新されます。

- `v0`...`v31` - 128ビットのSIMD/FPポイントレジスタ

  これらのレジスタはベクトル化SIMD命令と浮動小数点演算に使用されます。
  これらのレジスタはエイリアスによりアクセスされます。レジスタ
  `q0`...`q31`はこれらのレジスタの128ビットすべてのエイリアスです。
  レジスタ`d0`...`d31`はこれらのレジスタの下位64ビットのエイリアスです。
  また、これらのレジスタのそれぞれ、下位32ビット、16ビット、8ビットを示す
  `s`、`h`、`b`を前置詞とするエイリアスがあります。

- `xzr` - read-onlyのゼロレジスタ

  この擬似レジスタは（ハードウェアレジスタである場合とそうでない場合が
  ありますが）常に値`0`を保持します。

また、_多くの特殊_ レジスタもあります。これらのレジスタについては
次のセクションのように、必要に応じて説明します。

#### PSTATE

ARMv8 CPUはすべての時点で _プログラムの状態_ をPSTATEという疑似レジスタに
取り込みます (ref: D1.7)。PSTATEは実際のレジスタではなく、直接読み書きする
方法はありません。代わりに、PSTATE擬似レジスタの様々なフィールドを読み書き
するために使用できる特殊レジスタがあります。ARMv8.0では以下が該当します。

- `NZCV` - 条件フラグ
- `DAIF` - 例外マスクビット。例外が発行されないようにするために使用
- `CurrentEL` - 現在の例外レベル（後で説明）
- `SPSel` - スタックポインタセレクタ

これらのレジスタは _システムレジスタ_ または _特殊レジスタ_ として
知られるレジスタクラスに属します (ref: C5.2)。通常、レジスタは`ldr`
命令を使ってメモリからロードし、`str`命令を使ってメモリにストア
することができます。システムレジスタはこれらの命令では読み書きできません。
代わりに、特殊目的命令の`mrs`と`msr`を使用する必要があります
(ref: C6.2.162～C6.2.164)。たとえば、`NZCV`を`x1`に読み込むには
次の命令を実行します。

```
mrs x1, NZCV
```

#### 実行状態

ARMv8 CPUはすべての時点で所定の _実行状態_ で実行されています。このような
実行状態は2つあります。32ビットのARMv7互換モードに対応するAArch32と
64ビットのARMv8モードのAArch64です (guide: 3.1)。私たちは常にAArch64で
実行します。

#### セキュアモード

ARMv8 CPUはすべての時点で所定の _セキュリティ状態_ （ほかでは
_セキュリティモード_ または _セキュリティワールド_ と呼ばれています）で
実行されています。セキュリティ状態には _セキュア_ と _ノーマル_
としても知られている _非セキュア_ （non-secure）の2つの状態が
あります。私たちは常に非セキュア（ノーマル）モードで実行します。

#### 例外レベル

ARMv8 CPUはすべての時点で所定の _例外レベル_ (guide: 3) で実行されて
います。各例外レベルは _特権レベル_ に対応しており、例外レベルが高いほど
そのレベルで実行されているプログラムの特権が大きくなります。例外レベル
には次の4つがあります。

- `EL0`（ユーザ） - 通常、信頼されないユーザアプリケーションの実行に
  使用されます
- `EL1`（カーネル） - 通常、特権を持つOSカーネルを実行するために使用されます
- `EL2`（ハイパーバイザ） - 通常、仮想マシンハイパーバイザの実行に使用されます
- `EL3`（モニタ） - 通常、低レベルファームウェアの実行に使用されます

Raspberry PiのCPUはEL3で起動します。その時点ではRaspberry Pi財団が
提供するファームウェアが実行され、ファームウェアはCPUをEL2に切り替え、
`kernel8.img`ファイルを実行します。したがって、私たちのカーネルはEL2で
実行を開始します。その後、私たちのカーネルが適切な例外レベルで実行される
ようにEL2からEL1に切り替えることになります。

#### #Lxレジスタ

`ELR`、`SPSR`、`SP`など、いくつかのシステムレジスタは例外レベルごとに
重複して存在してます。例外レベル`n`用のレジスタを示すためにレジスタ名の
末尾には`_ELn`が付いています。たとえば、`ELR_EL1`は_EL1用の例外リンクレジスタ_ で
あり、`ELR_EL2`はEL2用の例外リンクレジスタです。

_ターゲット_ 例外レベル`x`のレジスタに言及する場合は`ELR_ELx`のように
接尾辞に`x`を使用します。ターゲット例外レベルとは例外ベクタを実行する
ためにCPUが必要に応じて切り替える例外レベルのことです。_ソース_ 例外
レベル`x`のレジスタに言及する場合は`SP_ELs`のように接尾辞に`s`を使用
します。ソース例外レベルとは例外が発生したときにCPUが実行していた例外
レベルのことです。

#### 例外レベルの切り替え

例外レベルを増加させるメカニズムは1つしか存在しません。また、例外レベルを
減少させるメカニズムも1つしか存在しません。

高いレベルから低いレベルに切り替える（特権を減らす）には実行中の
プログラムが`eret`命令 (ref: D1.11) を使用して例外レベルから _return_
しなければなりません。現在の例外レベルが`ELx`のときに`eret`命令を実行
すると、CPU は次のようになります。

- 特殊システムレジスタ`ELR_ELx`の値をPCにセットする
- 特殊システムレジスタ`SPSR_ELx`の値をPSTATEにセットする

`SPSR_ELx`レジスタ (ref: C5.2.18) にはリターンすべき例外レベルも格納
されています。例外レベルの変更には次のような影響もあることに注意して
ください。

- `Els`にリターンする際、`sp`には`SPSR_ELx[0] == 1`の場合は`SP_ELs`が、
  `SPSR_ELx[0] == 0`の場合は`SP_EL0`がセットされます。

下位レベルから上位レベルへの切り替えは例外の結果としてしか発生しません
(guide: 10)。特に設定しない限り、CPUは例外を次の例外レベルでトラップ
します。たとえば、`EL0`で動作中に割り込みを受けた場合、CPUは`EL1`に
切り替えて例外を処理します。`ELx`への切り替えが発生するとCPUは次のように
なります。

- `PSTATE.DAIF=0b1111`とセットすることですべての例外と割り込みを
  マスクします
- `PSTATE`などのフィールドを`SPSR_ELx`に保存します
- _優先例外リンクアドレス_ を`ELR_ELx`に保存します (ref: D1.10.1)
- `SPSel`が`1`に設定されていた場合は`sp`に`SP_ELx`をセットします
- _例外シンドローム_ （後述）を`ESR_ELx`に保存します (ref: D1.10.4)
- 例外ベクタ(後述)に対応するアドレスを`PC`にセットします（後述）

例外シンドロームレジスタが有効なのは例外が _同期_ （後述）であった
場合だけであることに注意してください。すべての汎用レジスタとSIMD/FP
レジスタは例外が発生したときの値を維持します。

#### 例外ベクタ

例外が発生するとCPUはその例外に対応する _例外ベクタ_ にジャンプします
(ref: D1.10.2)。例外には4つのタイプがあり、それぞれ4つの例外発生源が
考えられるため合計16個の例外ベクタが存在します。例外の4タイプは次の
とおりです。

- **同期** - `svc`や`brk`などの命令により発生する例外
- **IRQ** - 外部ソースからの非同期割り込み要求
- **FIQ** - 外部ソースからの非同期高速割り込み要求
- **SError** - 「システムエラー」割り込み

4つの発生源は次のとおりです。

- ソースが`SP = SP_EL0`で同じ例外レベル
- ソースが`SP = SP_ELxPで同じ例外レベル
- AArch64で実行中の下位の例外レベル
- AArch32で実行中の下位の例外レベル

プログラムガイド (guide: 10.4) では次のように記述されています。

例外が発生するとプロセッサは例外に対応するハンドラコードを実行
しなければなりません。[例外]ハンドラが格納されるメモリ上の場所は
_例外ベクタ_ と呼ばれています。ARMアーキテクチャでは例外ベクタは
_例外ベクタテーブル_ と呼ばれるテーブルに格納されます。各例外レベルは
独自のベクタテーブルを持っています。つまり、EL3、EL2、EL1のそれぞれに
1つずつテーブルがあります。このテーブルには[x86がそうであるような]
アドレスの集合ではなく、実行されるべき命令が格納されています。ベクタ
テーブルの各エントリは16命令長です。個々の例外用のベクタはテーブルの
先頭から固定オフセットに配置されます。各テーブルのベースとなる仮想
アドレスはベクタベースアドレス[特殊]レジスタの`VBAR_EL3`, `VBAR_EL2`,
`VBAR_EL1`によりセットされます。

ベクターは物理的に次のように配置されます。

- ソースが`SP = SP_EL0`でターゲットとソースが同一の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x000 | 同期例外 |
| 0x080 | IRQ |
| 0x100 | FIQ |
| 0x180 | SError |

- ソースが`SP = SP_ELx`でターゲットとソースが同一の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x200 | 同期例外 |
| 0x280 | IRQ |
| 0x300 | FIQ |
| 0x380 | SError |

- AArch64で実行中でソースが下位の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x400 | 同期例外 |
| 0x480 | IRQ |
| 0x500 | FIQ |
| 0x580 | SError |

- AArch32で実行中でソースが下位の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x600 | 同期例外 |
| 0x680 | IRQ |
| 0x700 | FIQ |
| 0x780 | SError |

ベクタテーブルは連続しています。

#### Rustとのインタフェース

システムに関する低レベルの詳細にアクセスするためのRustyインタフェースを
提供するために`aarch64`ライブラリ (`lib/aarch64`) を用意しました。
次のサブフェーズに移る前に`regs.rs`で定義されているレジスタとあなたの
理解を比較してください。ライブラリ内の他のファイルについては次のサブ
フェーズの最後に再検討します。

#### まとめ

とりあえず、ARMv8アーキテクチャについて知っておくべきことは以上です。
次に進む前に以下の質問に答えてください。

**質問 (arm-x30): x30はどのレジスタのエイリアスか**
> `x30`に`0xFFFF`という値が書き込まれた場合、その値を取り出すために
> 使用できる他の2つのレジスタ名は何ですか.

**質問 (arm-pc): 特定のアドレスをPCにセットする方法は**
> `ret`命令を使ってどのようにアドレス`A`をPCにセットしますか。
> `eret`命令を使ってどのようにアドレス`A`をPCにセットしますか。
> どのレジスタにどの値をセットするか、具体的に答えてください。

**質問 (arm-el): どのようにして現在の例外レベルを知るか**
> 現在の例外レベルを知るために具体的にどの命令を実行しますか。

**質問 (arm-sp-el): どのようにして例外からの復帰時にスタックポインタを変更するか**
> 例外が発生した際に実行中のプログラムのスタックポインタは`A`です。
> 例外を処理した後、プログラムが実行されていた場所に戻りたいが
> スタックポインタは`B`に変更したい。どのようにしますか。

**質問 (arm-svc): 下位ELからのシステムコールに使用されるベクタはどれか**
> `svc`命令を発行した時プロセスは`EL0`で実行中でした。CPUは具体的に
> どのアドレスにジャンプしますか。

**質問 (arm-int): 下位のELからの割り込みに使用されるベクタはどれか**
> タイマー割り込みが発生した時プロセスは`EL0`で実行中でした。
> CPUは具体的にどのアドレスにジャンプしますか。

**質問 (arm-mask): IRQ例外のマスクを解除するには**
> IRQ割り込みのマスクだけを解除するにはどのレジスタにどんな値を
> 書き込みますか。

**質問 (arm-aarh32): どのようにしてAArch32実行状態に`eret`するか**
> ソースがAArch64で実行中に例外が発生しました。ターゲットもAArch64で
> 実行中です。`eret`によって例外から復帰する際にCPUをAArch32実行状態に
> 切り替えるにはどのレジスタのどの値を変更しますか。

       ヒント
       (guide: 10.1)を参照してください。

### サブフェーズ B: 命令

このサブフェーズではARMv8命令セットについて学習します。コードを書く
ことはありませんが、命令セットに関するいくつかの質問に答えることに
なります。

#### メモリへのアクセス

ARMv8はロード/ストアRISC (Reduced Instruction Set Computer) 命令
セットです。このような命令セットの決定的な特徴はメモリのアクセスが
特定の命令でしかできないことです。つまり、メモリの読み込みはロード
命令でレジスタに読み込むことしかできず、メモリへの書き込みはストア
命令でレジスタからメモリに書き込むことしかできません。

ロード命令とストア命令には多くの種類があり、特定の命令にはバリエーションも
あります。最も単純なものから説明します。

- `ldr <ra>, [<rb>]` : <rb>のアドレスの値を<ra>にロードする
- `str <ra>, [<rb>]` : <ra>の値を<rb>のアドレスにストアする

レジスタ `<rb>` は _基底アドレス_ と呼ばれます。`r3 = 0x1234` の場合、

```
ldr r0, [r3]    // r0 = *r3 (すなわち、r = *(0x1234))
str r0, [r3]    // *r3 = r0 （すなわち、*(0x1234) = r0
```

`[-256, 255]`の範囲のオフセットを指定することもできます。

```
ldr r0, [r3, #64]     // r0 = *(r3 + 64)
str r0, [r3, #-12]    // *(r3 - 12) = r0
```

ポストインデックスを指定することもできます。これはロードまたはストアの
_後に_ 基底アドレスの値を変更します。

```
ldr r0, [r3], #30     // r0 = *r3; r3 += 30
str r0, [r3], #-12    // *r3 = r0; r3 -= 12
```

プリインデックスを指定することもできます。これはロードまたはストアの
_前に_ 基底アドレスの値を変更します。

```
ldr r0, [r3, #30]!    // r3 += 30; r0 = *r3
str r0, [r3, #012]!   // r3 -= 12; *r3 = r0
```

オフセット、ポストインデックス、プリインデックスは _アドレッシングモード_
と呼ばれます。

最後に、`ldp`命令と`stp`命令 (load pair, store pair) を使うと一度に2つの
レジスタからロードとストアができます。これらの命令には`ldr`と`str`と同じ
アドレッシングモードを使用することができます。

```
// `x0` と `x1` をスタックに積む。 操作後のスタックは次のようになる
//
//   |------| <- SP
//   |  x0  |
//   |------|
//   |  x1  |
//   |------| <x (original SP)
//
stp x0, x1, [SP, #-16]!

// pop `x0` と `x1` をスタックから下ろす。操作後のスタックは次のようになる
//
//   |------| <x (original SP)
//   |  x0  |
//   |------|
//   |  x1  |
//   |------| <- SP
//
ldp x0, x1, [SP], #16

// 次の4つの操作は上の2つの操作と同じことをする
sub SP, SP, #16
stp x0, x1, [SP]
ldp x0, x1, [SP]
add SP, SP, #16

// 上と同じだが、x0, x1, x2, x3の保存と復元をする
sub SP, SP, #32
stp x0, x1, [SP]
stp x2, x3, [SP, #16]

ldp x0, x1, [SP]
ldp x2, x3, [SP, #16]
add SP, SP, #32
```

#### 即値のロード

_即値_ とは計算なしで値がわかる整数の別名です。16ビットの即値を、任意に
16ビットの倍数だけ左にシフトして、レジスタにロードするには`mov` (move)
を使用します。16ビットの即値を、他のビットは置き換えることなく数ビット
左にシフトして、ロードするには`movk`（move/keep）命令を使用します。
使用例は次の通り。

```
mov   x0, #0xABCD, LSL #32    // x0 = 0xABCD00000000
mov   x0, #0x1234, LSL #16    // x0 = 0x12340000

mov   x1, #0xBEEF             // x1 = 0xBEEF
movk  x1, #0xDEAD, LSL #16    // x1 = 0xDEADBEEF
movk  x1, #0xF00D, LSL #32    // x1 = 0xF00DDEDBEEF
movk  x1, #0xFEED, LSL #48    // x1 = 0xFEEDF00DDEADBEEF
```

即値の前には`#`が付くこと、ディスティネーションレジスタは左に置くこと、
`LSL`は左シフトを指定することに注意してください。

レジスタにロードできるのは任意のシフトを伴う16ビット即値だけです。
多くの場合、アセンブラは正しいシフト値を見つけ出すことができます。
たとえば、アセンブラは`mov x12, #(1 << 21)`を`mov x12, 0x20, LSL #16`に
自動的に変換することができます。

#### ラベルからのアドレスのロード

アセンブリコードのセクションは`<label>;`を使って _ラベル付け_ する
ことができます。

```
add_30:
    add x1, x1, #10
    add x1, x1, #20
```

ラベル後の最初の命令のアドレスをロードするには`adr`命令か`ldr`命令を
使用することができます。

```
adr x0, add_30      // x0 = add_30の最初の命令のアドレス
ldr x0, =add_30     // x0 = add_30の最初の命令のアドレス
```

ラベルが命令と同じリンカセクションにない場合は`ldr`を使用する必要が
あります。ラベルが同じセクション内にある場合は`adr`を使用するべきです。

#### レジスタ間の移動

`mov`命令でレジスタ間の値の移動をすることもできます。

```
mov x13, #23    //          x13 = 23
mov sp, x13     // sp = 23, x13 = 23
```

#### 特殊レジスタからのロード

`ELR_EL1`などの特殊/システムレジスタは`mrs`命令と`msr`命令を使って
別のレジスタへのロード/ストアしかできません。

別のレジスタから特殊レジスタへ書き込むには`msr`命令を使用します。

```
msr ELR_EL1, x1     // ELR_EL1 = x1
```

特殊レジスタからへ別のレジスタに読み込むには`mrs`命令を使用します。

```
mrs x0, CurrentEL   // x0 = CurrentEL
```

#### 算術演算

`add`命令と`sub`命令を使って算術演算をすることができます。構文は次の通り。

```
add <dest> <a> <b>      // dest = a + b
sub <dest> <a> <b>      // dest = a - b
```

たとえば、

```
mov x2, #24
mov x3, #36
add x1, x2, x3    // x1 = 24 + 36 = 60
sub x4, x3, x2    // x4 = 36 - 24 = 12
```

パラメタ`<b>`には即値も使用できます。

```
sub sp sp, #120   // sp -= 120
add x3, x1, #120  // x3 = x1 + 120
add x3, x3, #88   // x3 += 88
```

#### 論理演算

`and`命令と`orr`命令はビット単位の`AND`と`OR`を行います。使用法は
`add`と`sub`と同じです。

```
mov x1, 0b11001
mov x2, 0b10101

and x3, x1, x2    // x3 = x1 & x2 = 0b10001
orr x3, x1, x2    // x3 = x1 | x2 = 0b11101
orr x1, x1, x2    // x1 |= x2
and x2, x2, x1    // x2 &= x1

and x1, x1, #0b110    // x1 &= 0b110
orr x1, x1, #0b101    // x1 |= 0b101
```

#### 分岐

_分岐_ はあるアドレスへのジャンプを指す用語です。_分岐_ はPCを指定された
アドレスまたはラベルアドレスに変更します。無条件にラベルにジャンプする
には`b`命令を使用します。

```
b label   // labelにジャンプ
```

次のアドレスをリンクレジスタに格納してラベルにジャンプするには`bl`命令を
使用します。`ret`命令は`lr`のアドレスにジャンプします。

```
my_function:
    add x0, x0, x1
    ret

mov x0, #4
mov x1, #30
bl  my_function     // lr = `mov x3, x0のアドレス
mov x3, x0          // x3 = x0 = 4 + 30 = 34
```

`br`命令と`blr`命令は各々`b`と`bl`と同じですがレジスタが持つ
アドレスにジャンプします。

```
ldr x0, =label
blr x0            // bl label と同じ
br  x0            // b  label と同じ
```

#### 条件分岐

`cmp`命令は2つのレジスタの値、または、レジスタの値と即値を比較して
`bne` (branch not equal), `beq` (branch if equal), `blt` (branch
if less than) などの条件分岐命令のためのフラグをセットします (ref:
C1.2.4)。

```
// x1と等しくなるまでx0に１を足し、等しくなったら`function_when_eq`を
// 呼び出し、ついでexitを実行する
not_equal:
    add x0, x0, #1
    cmp x0, x1
    bne not_equal
    bl  function_when_eq

exit:
    ...

// x0 == x1 のときに呼ばれる
function_when_eq:
    ret
```

即値を使用した例

```
cmp x1, #0
beq x1_is_eq_to_zero
```

分岐が選択されなかった場合は単に次の命令を実行することに注意してください。

#### Rustとのインタフェース

ここで再び`aarch64`サブディレクトリに移動して残りのファイルの確認を
始めてください。ライブラリの各ファイルの簡単な説明は以下のとおりです。

- `asm.rs` - 内部的に使用するインラインアセンブリを関数としてラップ
- `macros.rs` - このライブラリで使用するマクロを定義
- `regs.rs` - マクロを使ってレジスタを定義し、そのインタフェースを提供
- `sp.rs` - スタックポインタへのアクセス
- `vmsa.rs` - 仮想メモリのサポート（後述）
- `lib.rs` - 上記のモジュールをインクルード。`current_el()`などの便利な
  関数を持つ

たとえば、`sp.rs`の`get()`関数と`set()`関数を使うと任意の時点で現在の
スタックポインタを取得したり変更したりすることができます。同様に、
`lib.rs`の`current_el()`関数は _カレント例外レベル_ と呼ばれている
CPUが現在実行している例外レベルを返します。

#### まとめ

ARMv8命令セットにはまだまだ多くの命令があります。これらをベースにすれば
残りの命令のほとんどを簡単にピックアップできるはずです。命令は (ref: C3)
に記載されています。上で紹介した命令の簡潔なリファレンスについては、Griffin Dietz氏による[ISAチートシート](https://tc.gts3.org/cs3210/2020/spring/r/AArch64-ISA-Cheat-Sheet.pdf)を
参照してください。先に進む前に次の質問に答えてください：

**質問 (asm-memcpy): ARMv8アセンブリでmemcpyはどう書きますか**
> ソースアドレスが`x0`に、ディスティネーションアドレスが`x1`に、
> コピーするバイト数（これは非ゼロの8の倍数であることが保証されている）
> が`x2`に置かれているとすると、ARMv8アセンブリで`memcpy`をどのように
> 実装しますか。`ret`することも忘れないでください。

    ヒント
    わずか6、7行で実装できます。

```
memcpy:
    ldr  x3, [x0], #8
    str  x3, [x1], #8
    subs x2, #8
    bne  memcpy
exit:
    ret
```

**質問 (asm-movk): どのように`ELR_EL1`に`0xABCDE`を書くか**
> EL1で実行していると仮定するとARMv8アセンブリを使用してどのようにして
> `ELR_EL1`に即値`0xABCDE`を書きますか

    ヒント
    3命令が必要です。

```
mov   x0, 0xBCDE
movk  x0, 0xA, LSL #16
msr   ELR_EL1, x0
```

**質問 (asm-cbz): cbz命令は何をしますか**
> (ref: C6.2.36) の`cbz`命令のドキュメントを読んでください。
> この命令は何をしますか、どのように使いますか。

**質問 (init): init.rsは何をしていますか**
> ラボ3まで`kern/src/init/init.s`をカーネルで実行される最初のコードと
> して使っていました。ここからはその役目は`kern/src/init.rs`に置き
> 換わりました。特に、`_start`関数はRaspberry Piの起動時に`0x80000`
> 番地にあり、ファームウェアはシステムの初期化を終えるとすぐにこの
> アドレスにジャンプします。まもなくこのファイルを修正してEL1に切り替え、
> 例外ベクタをセットアップするすることになります。
>
> `kern/src/init.rs`のコードをすべて読んでください。ファイルの
> すべての関数について、そのコードが何をしているのかを説明して
> ください。たとえば、`_start`関数の説明は次のように言うことができます。
>
> 「`MPIDR_EL1`レジスタの[7:0]ビット (ref: D7.2.74) を読み込んで
> (`Aff0`)、現在コードを実行しているコア番号を取得する。番号が0の場合、
> KERN_STACK_BASE(0x80_000) をスタックポインタに設定して、kinit() を
> 呼び出す。」

    ヒント
    まだよく知らない命令やレジスタについてはマニュアルを参照してください。

    ヒント
    `init.rs`をレビューするには`aarch64`ライブラリと
    `kern/src/param.rs`が必要になります。

### サブフェーズ C: EL1への切り替え

このサブフェーズではEL2からEL1に切り替えるためのRustコードを書きます。
主に`kern/src/init.rs`と`kern/src/main.rs`で作業します。このサブ
フェーズに進むのは前のサブフェーズの質問に答えてからにすることを
勧めます。

#### 現在の例外レベル

すでに説明したようにカーネルが呼び出された時、CPUはEL2で動作している
はずです。`kmain()`で現在の例外レベルを表示することでこのことを確認して
ください。`current_el()`を呼び出すには`unsafe`を使用する必要があることに
注意してください。EL1に正常に切り替えたことを確認できたらこの呼び出しは
削除します。`current_el()`は`lib/aarch64`ライブラリにあります。依存問題を
解決するにはこのライブラリを追加する必要があります。

#### 切り替え

EL1に切り替えるためのアセンブリコードを完成させる時間です。
`kern/src/init.rs`で次の行を見つけてください。

```rust
// FIXME: eret to itself, expecting current_el() == 1 this time
```

この行の上には次のコードがあります。

```rust
SPSR_EL2.set(
    (SPSR_EL2::M & 0b0101)
    | SPSR_EL2::F
    | SPSR_EL2::I
    | SPSR_EL2::D
    | SPSR_EL2::A,
);
```

前のサブフェーズで学んだのでこれらのビットが何をするのかを知っている
はずです。特に、`SPSR_EL2`のどのビットをセットするとその後に`eret`
したらその結果どうなるかを知っているはずです。

`FIXME`を適切なコードに置き換えることで切り替えルーチンを完成させて
ください。EL1に切り替えた際、CPUが適切な例外レベルで再帰的に
`switch_to_el1`にジャンプして、内部チェックの`current_el() == 2`を
バイパスして`kmain()`に進むことを確認してください。このルーチンを
完了するのに必要なコードは2行です。例外レベルを下げる唯一の方法は
`eret`であることを思い出してください。ルーチンを完了したら今度は
`current_el()`が`1`を返すことを確認してください。

**ヒント**
> 例外からリターンする際にPCをセットするにはどのレジスタを使用しますか.

#### サブフェース D: 例外ベクタ

このサブフェーズでは例外ベクタと例外ハンドラを設定してインストールします。
これはカーネルが任意の例外や割り込みを処理できるようにするための第一歩と
なります。作成した例外ベクタと例外ハンドラは`brk #n`命令に応答して起動する
小さなデバッガを実装することでテストします。主に`kernel/src/init/vectors.s`,
`kernel/src/traps.rs`, `kernel/src/traps`ディレクトリで作業します。

#### 概要

ベクトルテーブルは16個のベクトルで構成され、各ベクトルは最大16個の一連の
命令であることを思い出してください。`vectors.s`の中にこれらのベクタ用の
スペースを確保し、`vectors`ラベルをテーブルの先頭に配置しました。この
`vectors.s`ファイルは`init.rs`で`global_asm!`マクロによりインクルード
されます。あなたの課題は16個のベクタでテーブルを埋め、最終的に例外が
発生した際に`kernel/src/traps.rs`にある`handle_exception`Rust関数が適切な
引数で呼び出されるようにすることです。すべての例外は`handle_exception`
関数にルーティングされます。この関数は例外がなぜ発生したかを判断し、
必要に応じてより上位のハンドラに例外をディスパッチします。

#### 呼び出し規約

Rustで宣言された`handle_exception`関数を適切に呼び出すにはその関数が
どのように呼び出されることを期待しているかを知っておく必要があります。
特に、その引数である`info`, `esr`, `tf`の値を関数はどこで見つけるのか、
関数が呼び出された後のマシンの状態についてどんな約束があるのか、関数を
呼び出した場所にどのように戻るのかを知っておく必要があります。

この外部の関数を呼び出す方法を知るという問題は（ラボ3でC言語とRust言語
の間で行ったような）ある言語が別の言語を呼び出す際にはいつでも発生します。
すべての言語が関数をどのように呼び出すかを知っておかなくても良いように
_呼び出し規約_ が確立されています。_呼び出し規約_（または、
_プロシジャ呼び出し規約_）とは以下を定めた一連の規則のことです。

- **どのように関数に引数を渡すか**

  AArch64では最初の8つの引数は左から右の順でレジスタ`r0`...`r7`で渡します。

- **どのように関数から値を返すか**

  AArch64では最初の8つの返り値はレジスタ`r0`...`r7`で渡されます。

- **関数はどの状態（レジスタ、スタックなど）を保存する必要があるか**

  レジスタは通常 _caller-saved_ と _callee-saved` に分類されます。

  _caller-saved_ レジスタは関数呼び出しの前後で保存されることは保証
  されていません。したがって、callerはレジスタ値を保存する必要がある
  場合は関数を呼び出す前にレジスタ値を保存する必要があります。

  逆に、_callee-saved_ レジスタは関数呼び出しの前後で保存されることが
  保証されています。したって、関数呼び出し中に対象のレジスタを使用したい
  場合、calleeはそのレジスタを使用する前にレジスタ値を保存し、リターン
  する前にそのレジスタ値を復元する必要があります。

  レジスタ値の保存と復元は通常、スタックへのpushとpopで行われます。

  AArch64ではレジスタ`r19`...`r29`と`SP`がcaller-savedで、残りの汎用
  レジスタはcallee-savedです。これには`lr` (`x30`) も含まれることに注意
  してください。SIMD/FPレジスタには複雑な保存規則があります。私たちの
  目的のためにはこれらはすべてcaller-savedであると言えば十分です。

- **どのように呼び出し元に帰るのか**

  AArch64では`lr`レジスタが _リンクアドレス_ （calleeがリターンする際に
  ジャンプすべきアドレス）を保持します。`ret`命令は`lr`に分岐するので
  通樹はそれで関数は終了します。

AArch64の呼び出し規約は公式の[プロシジャコール標準](https://tc.gts3.org/cs3210/2020/spring/r/AArch64-Procedure-Call-Standard.pdf)
ドキュメントと共に (guide: 9) でも説明されています。アセンブリから
`handle_exception` Rust関数を呼び出す場合はこの呼び出し規約を確実に
守る必要があります。

**注記: Rustはどの規約を使えばよいかをどのようにして知るのか**
> 呼び出し規約を厳密に守ると関数呼び出しや関数本体のあらゆる最適化が
> できなくなります。そのため、Rustの関数はデフォルトでは特定の呼び出し
> 規約に従うことが保証されていません。対象となるプラットフォームの呼び
> 出し規約に完全に従うように関数をコンパイルするには`extern`関数修飾子を
> 使用します。`handle_exception`はすでに`extern`として宣言しているので
> Rustが関数を適切にコンパイルすることを保証することができます。

#### ベクタテーブル

ベクタテーブルを埋めるための手助けをするマクロ `HANDLER source, kind` を
用意しました。このマクロは次の有効なベクタエントリにアラインする8命令に
展開します。`HANDLER a, b`を"命令"として使用すると`.macro`と`.endm`の
間に展開されます。すなわち、

```rust
vectors:
    HANDLER 32, 39
```

は、次のように展開されます。

```rust
vectors:
    .align 7
    stp   lr, xzr, [SP, #-16]!
    stp   x28, x29, [SP, #16]!

    mov   x29, #32
    movk  x29, #39, LSL #16
    bl    context_save

    ldp   x28,x29, [SP], #16
    ldp   lr, xzr, [SP], #16
    eret
```

展開されたコードは`lr`, `xzr`, `x28`, `x29`をスタックにプッシュし、
下位16ビットが`source`、上位16ビットが`kind`となる32ビットの値を
`x29`に作成し、アセンブリ関数`context_save`（`vectors.s`で`vectors`の
上で宣言されています）を呼び出します。この関数が復帰したらスタックから
保存した4つのレジスタを復元し、最後に例外から復帰します。

`context_save`関数は今のところ何もしません。単に下の`context_restore`
からの`ret`に進むだけです。後で関数`context_save`を修正してRust関数
`handle_exception`を正しく呼び出すようにします。

#### Syndrome構造体

_同期例外_（命令の実行または試行によって発生する例外）が発生すると
CPUは例外の原因を記述する値をシンドロームレジスタ（`ESR_ELx`）にセット
します (ref: D1.10.4)。`kernel/src/traps/syndrome.rs`にシンドローム値を
解析して意味のある`Syndrome enum`に変換する構造体を設定しました。この後
すぐに`ESR_ELx`値を`esr`パラメータとしてRust関数に渡すコードを書くことに
なります。そして、`Syndrome::from(esr)`を使って次に何をすべきかを決定する
シンドロームの値を解析します。

#### Info構造体

Rust関数`handle_exception`は第1パラメータとして`Info`構造体を受け取ります。
この構造体には2つの16ビットフィールドがあります。最初のフィールドはソースに、
2番目のフィールドは例外の種類に対応します。もうおわかりだと思いますが
これは`HANDLE`マクロが`x29`で設定する`32ビット`値そのものです。この値を
第1パラメータとして渡すには`context_save`コードブロック内で`x29`を`x0`に
移動する必要があります。さらに、`Info`構造体が正しく作成されるように
正しいエントリに対して正しく`HANDLE`を呼び出すようにしてください。

#### 実装

これで予備的な例外処理コードを実装する準備ができました。最初に扱う例外は
`brk`例外（ソフトウェアブレークポイント）です。この例外が発生した場合は
理論的にはそれを実行した時点でのマシンの状態を調べることができるシェルを
起動することになります。

`main.rs`に`brk`の呼び出しを挿入することから始めます。インラインアセンブリを
使う代わりに`aarch64`ライブラリの`asm.rs`で定義されている`brk`マクロを
呼び出すことができます。

その後は次のように進めます。

1. **`HANDLE`マクロを使って`vectors`テーブルを埋める**

    エントリが`Info`構造体を正しく作成するようにしてください。
    (guide: 10.4) を参照してエントリの順序をチェックしてください。
    ハンドラの`source`と`kind`は`src/traps.rs`にある`Source`と`Kind`
    enumにマッチするようにしてください。

2. **`context_save`内で`handle_exception`関数を呼び出す**

    必要に応じてcaller-savedレジスタを保存/復元して適切なパラメータを
    渡すようにしてください。今のところ`tf`パラメータには`0`を渡しておく
    ことができます。これは後で使うことになります。引数に何を渡すかは
    `src/traps.rs`を参照してください。

    **注意**: AArch64では`SP`レジスタをロード/ストアの一部として使用
    する場合、常に16バイトアラインにする必要があります。常に`SP`を
    16バイトアラインに保つようにしてください。

3. **`init.rs`にある次のコメントでマークされている位置で正しい`VBAR`レジスタをセットアップする**

    ```rust
    // FIXME: load `vectors` addr into appropriate register (guide: 10.4)
    ```

4. **この時点で例外が発生するたびに`handle_exception`関数が呼び出される
  はず**

    `handle_exception`でパラメタ`info`と`esr`の値を表示し、それらが期待
    通りであることを確認してください。その後、ハンドラ内で無限ループ
    させます。ループの中では`aarch64::nop()`を呼び出して最適化で削除
    されないようにします。例外ハンドラから適切に戻るにはさらにコードを
    書く必要がありますが、今は単にループさせることにします。これは次の
    サブフェーズで修正することになります。

5. **`Syndrome::from()`メソッドと`Fault::from()`メソッドを実装する**

    前者は後者を呼び出す必要があります。これらを正しく実装するには (ref:
    D1.10.4, ref: Table D1-8) を参照する必要があるでしょう。テーブルの
    "ISS encoding description"をクリックすると特定の例外クラスの
    シンドロームのデコード方法と`Fault`のデコード方法の詳細がわかります。
    たとえば、`brk 12`は`Syndrome::Brk(12)`とデコードされることが確認できる
    はずです。同様に、`svc 77`は`Syndrome::Svc(77)`と解析します。いくつかの
    例外の32ビット値を省略していたり、同じ例外だが異なる例外クラスで発生
    した例外は合体させていることに注意してください。

    **警告**: aarch64ライブラリを使用してください
    インラインアセンブリを使用したり、各レジスタで生のビット操作を
    行なったりせずに`aarch64`ライブラリで定義されているレジスタや関数を
    使用すると便利です。`REG_NAME::get_value(raw_value, REG_NAME::MASK)`
    関数が便利なことがわかるでしょう。

6. **`brk`例外が発生したらシェルを起動する**

    `brk`例外の検出には`handle_exception`の`Syndrome::from()`メソッドを
    使用してください。このような例外が発生したらシェルを起動します。
    シェルを区別するために異なるシェルプレフィックスを使用するとよいで
    しょう。`Syndrome::from()`の呼び出しは同期例外に対してだけにするべきで
    あることに注意してください。それ以外の場合は`ESR_ELx`レジスタが有効な
    値を保持している保証はないからです。

    この時点でシェルを変更して新しいコマンド`exit`を実装する必要があります。
    `exit`が呼ばれたらシェルはループを終了して復帰する必要があります。
    これにより後で`brk`例外から抜けることができるようになります。この変更の
    ため、カーネルが終了してクラッシュするのを防ぐためにkmain内の`shell()`
    への呼び出しを`loop { }`でラップする必要もあります。

これらの実装が終了したら`kmain`での`brk 2`命令はシンドローム`Brk(2)`、
ソース`CurrentSpElx`、種別`Synchronous`の例外となり、`handle_exception`
関数にルーティングされ、デバッグシェルが起動するはずです。シェルから
`exit`が呼ばれるとシェルは終了し、例外ハンドラは無限ループを開始する
はずです。

先に進む前に、他の同期例外を正しく検出していることを確認すべきです。
`svc 3`などの他の例外を引き起こす命令の呼び出しを試してみる必要が
あります。また、物理メモリの範囲外のアドレスにジャンプすることで
意図的にデータアボートや命令アボートを引き起こしてみることも必要です。

すべてが期待通りに動いたら、次の段階に進んでください。

### サブフェーズ E: 例外からの復帰

このサブフェーズではあらゆる種類の例外から正しく戻るためのコードを記述します。
主に`kern/init/vectors.s`、`kern/src/traps.rs`、`kern/src/traps`ディレクトリで
作業します。

#### 概要

今`handle_exception`の無限ループを削除するとRaspberry Piは例外ハンドラに
繰り返し入る例外ループに入るか、デバッグシェルから抜けるときに完全に
クラッシュします。これは、例外ハンドラが以前に実行されていたコードに戻る
際にプロセッサの状態（主にレジスタ）がコードに関係なく変更されているためです。

例として、次のアセンブリを考えてみます。

```
1: mov x3, #127
2: mov x4, #127
3: brk 10
4: cmp x3, x4
5: beq safety
6: b   oh_no
```
`brk`例外が発生すると、例外ベクタが呼び出され、最終的に`handle_exception`が
呼び出されます。Rustでコンパイルされた`handle_exception`関数はその処理に
（特に）`x3`と`x4`レジスタを使用します。例外ハンドラが`brk`呼び出しの場所に
戻った場合、`x3`と`x4`の状態は不明であり、5行目の`beq safety`命令が`safety`に
分岐するかは保証されません。

つまり、例外ハンドラがそれが望むようにマシンを使用できるようにするには
例外ハンドラを呼び出す前にすべての処理コンテキスト（レジスタなど）を保存
しておく必要があります。そして、ハンドラが復帰した際にそれまで実行されて
いたコードが問題なく実行し続けるように処理コンテキストを復元する必要が
あります。この処理コンテキストを保存/復元するプロセスは**コンテキストスイッチ**
として知られています。

**なぜコンテクスト _スイッチ_ なのか？**
> _スイッチ_ という言葉が含まれているので少しごまかされるかもしれません。
> 結局のところ、同じコンテキストにに戻るだけではないのですか？
>
> 実際、同じコンテキストに戻りたいことはほとんどありません。通常は戻る前に
> コンテキストを変更してCPUがほんの少し異なる処理を実行するようにしたいと
> 考えます。たとえば、プロセススイッチングを実装する場合、CPU時間を多重化
> するためにあるプロセスのコンテキストを別のプロセスのコンテキストに入れ
> 替えます。システムコールを実装する場合はレジスタの値を変更して戻り値を
> 注入します。そして最後に、ブレークポイント例外から復帰する場合は`ELR`の
> リターアドレスを変更して同じ命令ではなく次の命令が実行されるようにする
> 必要があります。

この後すぐに _トラップフレーム_ として知られる構造体にすべての処理
コンテキストを保存するコードを記述します。`kern/src/traps/frame.rs`にある
`TrapFrame`構造体の定義を完成させRustからトラップフレームにアクセスして
変更できるようにします。また、トラップフレームの保存/復元をし、`tf`
パラメータとして`handle_exception`関数にトラップフレームへのポインタを
渡すためのアセンブリを記述します。

#### トラップフレーム

_トラップフレーム_ はすべての処理コンテキストを保持する構造体に付けられる
名前です。「トラップフレーム」という名前は「トラップ」という用語に由来します。
トラップとはイベントが発生した際にプロセッサがより高い特権レベルを呼び出す
メカニズムを表す一般的な用語です。プロセッサがより高い特権レベルに
_トラップ_ するといいます。

トラップフレームを作成する方法は数多くありますがどのアプローチも実質的には
同じです。つまり、実行に必要なすべての状態をメモリに保存することです。
ほとんどの実装はすべての状態をスタックにプッシュします。すべての状態を
プッシュするとそのスタックポインタ自体がトラップフレームへのポインタに
なります。私たちもこのアプローチを取ります。

今のところ、Cortex-A53の完全な実行状態は以下で構成されます。

- **x0..x30 - 31個の汎用レジスタすべての64ビットのすべて**
- **q0..q31 - すべてのSIMD/FPレジスタの128ビットのすべて**
- **TRPDR - 64ビットの「スレッドID」レジスタ**

    これは例外ソースがレベル`s`にある場合、`TPIDE_ELs`に格納されています。
- **sp - スタックポインタ**

    これは例外ソースがレベル`s`にある場合、`SP_ELs`に格納されています。
- **PSTATE - プログラムステート**

    これは`ELx`で例外が発生した場合、`SPSR_ELs`に格納されています。
- **pc - プログラムカウンタ**

    レジスタ`ELR_ELx`は _優先リンクアドレス_ を格納しています。これは
    例外を補足した際にCPUが持っていたPCの場合もあれば総でない場合も
    あります。通常は、`ELF_ELx`は例外を補足した際のPCまたは`pc + 4`の
    いずれかです。

例外ハンドラを呼び出す前に関連するレジスタをスタックにプッシュすることに
よりこのコンテキストを _すべて_ トラップフレームに保存し、ハンドラが復帰する
際にスタックからポップすることでトラップフレームを復元する必要があります。
状態をすべて保存した後、スタックは次のようになるはずです。

![トラップフレーム](trap_frame.png)

各レジスタが`_ELx`か`_ELs`を使用しているかを再確認してください。トラップ
フレームの`SP`と`TPIDR`はターゲットではなくソースのスタックポインタと
スレッドIDであることに注意してください。例外の最終的な発生源は`EL0`だけ
なので`SP_EL0`と`TPIDR_EL0`レジスタを保存/復元する必要があります。すべての
状態をプッシュした時、CPUの本当の`SP`（例外ベクタにより使用されるもの）は
トラップフレームの先頭を指しています。

最後に、トラップフレームへのポインタを`handle_exception`の第3引数として
渡します。引数の型は`&mut TrapFrame`です。`TrapFrame`は
`kern/src/traps/frame.rs`で宣言されています。トラップフレームのレイアウトに
正確に一致するように`TrapFrame`構造体を定義する必要があります。

**スレッドIDとは何か**
> `TPIDR`レジスタ(`TPIDR_ELx`)はOSが現在実行中のものに関する識別情報を
> 格納するためのレジスタです。後でプロセスを実装する際にはこのレジスタに
> プロセスのIDを格納します。今のところは将来のためにこのレジスタの保存/
> 復元をしておきます。

#### 優先例外リターンアドレス

`ELx`で例外が発生するとCPUは _優先リンクアドレス_ （または、_優先例外リターンアドレス_）を
`ELR_ELx`に格納します。この値は (ref: D1.10.1) で次のように定義されています。

1. 非同期例外の場合、割り込みを受けた結果、実行されなかった、または実行が
  完了しなかった最初の命令のアドレス
2. システムコール以外の同期例外の場合、例外を発生させた命令のアドレス
3. 例外を発生させた命令の場合、例外を発生させた命令に続く命令のアドレス

`brk`命令は2番目のカテゴリに入ります。そのため、`brk`命令の後に実行を
続行したい場合、復帰する前に次の命令のアドレスが`ELR_ELx`に含まれるように
する必要があります。AArch64ではすべての命令が32ビット幅なので個のアドレスは
`ELR_ELx + 4`です。

#### 実装

`kern/init/vectors.s`にある`context_save`ルーチンと`context_restore`ルーチンの
実装から始めます。`context_saveルーチン`は関連するすべてのレジスタをスタックに
プッシュし、第3引数としてトラップフレームへのポインタを渡して`handle_exception`
を呼び出します。次に、`context_restore`を実装します。ここではコンテキストの
復元以外にすることはありません。

`HANDLER`マクロによって生成される命令で`x28`, `x29`, `x30(lr)`,
`x31(xzr)`はすでに保存/復元されていることに注意してください。
`context_{save,restore}`ルーチンでこれらのレジスタの保存/復元は必要ありませんが
トラップフレームにはこれらのレジスタが含まれていなければなりません。
技術的には`xzr`レジスタは常に0を含んでいるので保存/復元を行う必要はありません。
単にSPを16バイトアラインにするために保存します。

コンテキストスイッチのパフォーマンスへの影響を最小限に抑えるには次のように
レジスタをスタックにプッシュ／ポップする必要があります。

```
// レジスタ `x1`, `x5`, `x12`, `x13` をpush
stp x1, x5, [SP, #-16]!
stp x12, x13, [SP, #-16]!

// レジスタ`x1`, `x5`, `x12`, `x13` をpop
ldp x12, x13, [SP], #16
ldp x1, x5, [SP], #16
```

これらのルーチンを実装したら`kern/src/traps/frame.rs`で`TrapFrame`の定義を
完成させます。フィールドの順序とサイズが作成したトラップフレームと完全に
一致していることを確認し、それへのポインタを`context_save`に渡してください。

最後に、`handle_exception`の無限ループを削除し、`brk`例外から復帰する前に
トラップフレームのELRに4を足してください。コンテキストスイッチの実装に
成功したら、デバッグシェルから`exit`した後もカーネルは通常通り実行される
はずです。準備ができたら、次のフェーズに進んでください。

**注記: トラップフレームレイアウト**
> トラップフレームは図と完全に一致する必要はありませんが図にある
> すべてのデータを含む必要があります。

**警告: `q0` ... `q31`**
> `qn`レジスタは128ビット幅であることを忘れないでください。

**ヒント**
> `handle_exception`を呼び出すにはトラップフレームの一部 _ではない_
> レジスタを保存/復元する必要があります。

**ヒント**
> Rustには`u128`と`i128`の2つの128ビット整数型があります。

**ヒント**
> 特殊レジスタの読み書きには`mrs`命令と`msr`命令を使います。

**ヒント**
> `context_save`ルーチンは42命令です。

**ヒント**
> `TrapFrame`には6つのフィールド（そのうちの2つは配列）があり、
> サイズは`xzr`レジスタを除くと792バイトです。

**質問 (layz-float): 浮動小数点レジスタを遅延ロードする方法は**
> 128ビットのSIMD/FPレジスタの保存/復元は非常に高価です。
> `TrapFrame`の792バイトのうち512バイトを占めます。これらのレジスタは
> 例外のソース、または、コンテキストスイッチのターゲットで実際に使用
> されている場合にのみ保存／復元するのが理想的です。
>
> AArch64アーキテクチャではこれらのレジスタの使用を選択的に有効/無効に
> することができます。SIMD/FPが無効の場合、レジスタを使用する命令は
> トラップします。この機能を使ってSIMD/FPレジスタの遅延ローディングを
> 実装するにはどうしたらよいですか。ここではSIMD/FPレジスタとSIMD/FP
> 命令が自由に使用できるが、SIMP/FPが実施に使用されている場合にのみ
> コンテキストスイッチでレジスタを保存/復元します。特定の例外が発生した
> ときに何をするか、`TrapFrame`構造体を変更する必要があるか否か、
> 新たに保存する必要がある状態は何かについて具体的に説明してください。

## フェーズ 2: それはプロセス

このフェーズではユーザレベルのプロセスを実装します。まず、プロセスの状態を
保持する`Process`構造体を実装からスタートします。次に、最初のプロセスを起動
することによりシステムをブートストラップします。次に、tickベースのラウンド
ロビンスケジューラを実装します。そのためにまず割り込みコントローラドライバを
実装してタイマー割り込みを有効にします。次に、タイマー割り込みが発生したら
スケジューラを起動し、次のプロセスへのコンテキストスイッチを実行します。
最後に、最初のシステムコールである`sleep`を実装します。

このサブフェーズを完成させると最小限ですが完全なマルチタスクオペレーティング
システムを構築したことになります。今のところ、プロセスはカーネルや他の
プロセスと物理メモリを共有します。次のフェーズでは仮想メモリを有効にして、
プロセスを互いに隔離し、信頼できないプロセスからカーネルのメモリを保護します。

### サブフェーズ A: プロセス

このサブフェーズでは`kern/src/process/process.rs`にある`Process`構造の実装を
完成させます。次のサブフェーズではこの実装を使用して最初のプロセスを開始します。

#### プロセスとは何か

プロセスとはカーネルにより実行、管理、保護されるコードとデータのコンテナです。
それは非カーネルコードが実行される単一ユニットです。コードが実行している場合、
それはプロセスの一部として実行しているか、カーネルの一部として実行しているかの
いずれかです。特に研究の世界では、多くのオペレーティングシステムアーキテクチャ
が存在しますがそれらはすべてプロセスという概念とほぼ同じ概念を持っています。

プロセスは通常、カーネルがシステムの安定性とセキュリティを確保できるように、
縮小された権限（私たちのOSでは`EL0`）で実行されます。あるプロセスがクラッシュ
した場合、それにより他のプロセスがクラッシュしたり、マシン全体がクラッシュ
したりすることは望みません。また、プロセスが互いに干渉できることも望みません。
あるプロセスがハングアップした場合、他のプロセスが進行不能になるようなことは
望みません。プロセスは _隔離_ を提供します。つまり、プロセスは互いにほとんど
独立に動作します。皆さんはプロセスのこのような属性を毎日みていると思います。
ウェブブラウザがクラッシュしたりハングしたときにマシンの他の部分もクラッシュ
したりハングしたりしますか・

プロセスの実装とは信頼できないコードやデータを保護、隔離、実行、管理するための
構造やアルゴリズムを作成することです。

#### プロセスには何があるか

プロセスを実装するにはプロセスのコードとデータだけでなく、複数のプロセスを適切に
管理・隔離できるようにするための補助情報も記録する必要があります。つまり、
プロセスの次の要素を記録します。

- **スタック**

    各プロセスは実行するために個別にスタックを必要とします。プロセスを実装する
    際にはプロセスのスタックとして使用するのに適したメモリセクションを割り当てる
    必要があります。そして、プロセスのスタックポインタがこのメモリ領域を指す
    ようにブートストラップする必要があります。

- **ヒープ**

    互いに独立した動的メモリ割り当てを可能にするために、各プロセスは独自の
    ヒープも持ちます。ヒープは空で始まりますがシステムコールを介して要求に
    応じて拡張することができます。ラボ4ではヒープは実装せず、スタックだけを
    必要とするユーザプログラムをサポートします。

- **コード**

    プロセスはコードを実行していない限りあまり役に立ちません。したがって、
    カーネルはプロセスのコードをメモリにロードし、適切なときに実行する必要が
    あります。

- **仮想アドレス空間**

    プロセスがカーネルのメモリや他のプロセスのメモリにアクセスできるのは
    望まないので、各プロセスは仮想メモリを使って個別の仮想アドレス空間に
    閉じ込められます。

- **スケジューリング状態**

    通常、CPUコアの数よりも多くのプロセスが存在します。CPUは一度に1つの命令
    ストリームしか実行できないので、カーネルはCPU時間（そしてそれゆえ命令
    ストリーム）を多重化してプロセスを並行して実行する必要があります。どの
    プロセスがいつどこで実行されるかを決めるのはスケジューラの仕事です。
    これを正しく行うために、スケジューラはプロセスがスケジューリング可能な
    状態であるかを知る必要があります。_スケジューリング状態_ はこれを追跡
    します。

- **実行状態**

    CPU時間を複数のプロセスで正しく多重化するためにはプロセスの実行状態を
    CPUから切り離したときに保存し、再びCPUに付け替えたときに復元するように
    する必要があります。実行状態を維持するために使用する構造体がトラップ
    フレームであることはすでにわかるでしょう。各プロセスはその実行状態を
    適切に維持するためにトラップフレームを維持します。

プロセスのスタック、ヒープ、コードはプロセスの物理的な状態のすべてを構成
します。残りの状態はプロセスの隔離、管理、保護のために必要です。

`kernel/src/process/process.rs`にある`Process`構造体がこれらの情報をすべて
保持します。当分の間、全てのプロセスはメモリを共有するため、プロセスのヒープ、
コード、仮想アドレス空間のフィールドを見ることはないでしょう。これらは後で
課題として処理することになります。

**質問 (kernel-distruct): プロセスはカーネルを信頼しなければならないのか**
> カーネルがプロセスに対して明確に不信感を抱いていることは明らかですが、
> プロセスはカーネルを信頼しなければならないでしょうか。もしそうなら、
> プロセスはカーネルに何を期待していますか。

**質問 (isolated-stacks): 2つのプロセスがスタックを共有すると何が問題になるか**
> 2つのプロセスが平行に実行し、スタックを共有していると想像してください。
> 第1に2つのプロセスがスタックを共有するとはどういうことですか。第2に
> プロセスはかなり早い段階でクラッシュする可能性が高いのは何故ですか。第3に
> たとえスタックを共有していたとしてもスタックの共有のためにクラッシュする
> ことは決してないプロセスのプロパティを定義してください。言い換えれば、
> 並行して実行しスタックを共有しているが、この共有の結果としては決して
> クラッシュしない２つのプロセスとはどのようなものですか。

#### 実装

それでは`kern/src/process/process.rs`にある`Process`構造の実装から開始
しましょう。始める前に`kern/src/process/stack.rs`に提供している`Stack`
構造体の実装を読んでください。どのようにこの構造体を使用して新しいスタックを
確保して、新しいプロセス用のスタックへのポインタを取得するかを理解してください。
次に、`kern/src/process/state.rs`にあるスケジューリングの状態を追跡する
ために使用することになる`State`構造体の実装を読んでください。プロセスを
スケジューリングする際に異なるバリアントをどのように解釈するかを推理して
みてください。

最後に、`Process::new()`メソッドだけを実装してください。実装は簡単です。
状態を追跡することに関して複雑なことは何もありません。プロセス構造体の
実装は後で完成させます。準備ができたら次のサブフェーズに進んでください。

**質問 (stack-drop0: スタックのメモリはどのように回収されるか**
> `Stack`構造体は作成される際、16バイトアラインの1MiBのメモリブロックを
> 割り当てます。このメモリを所有する`Process`が存在しなくなったとき、この
> メモリが解放されることを何が保証しますか。

**質問 (lazy-stacks): スタックメモリの遅延割り当てはどのようにできるか**
> `Stack`構造体は、プロセスが実際にスタックを使うか、どのくらい使うかに
> 関係なくスタック用に1MiBのメモリを割り当てます。仮想メモリのことを考えて、
> 仮想メモリを使用してスタック用のメモリを遅延割り当てすることで必要になる
> までスタックにメモリをまったく、あるいは最小限のメモリだけ使用させるように
> する方法はありますか。

**質問 (stack-size): プロセスはスタックサイズをどのように増やすことができるか**
> プロセスによっては1MiBよりもはるかに大きなスタックスペースを必要としますが、
> 私たちのシンプルな設計ではすべてのプロセスに1MiBちょうどのスタックスペースを
> 割り当てます。プロセスが動的メモリ割り当てにアクセスできると仮定すると、
> プロセスはどのようにスタックサイズを増やすことができますか。プロセスが
> 実行する命令について具体的に説明してください。

### サブフェーズ B: 最初のプロセス

このサブフェーズでは最初のユーザ空間（`EL0`）プロセスを開始します。主に
`kern/src/process/scheduler.rs`と`kern/src/main.rs`で作業します。

#### コンテキストスイッチングプロセス

プロセス間のコンテキストスイッチを可能にする作業のほとんどはすでに終わって
います。例外に応答してプロセス間でコンテキストスイッチするには次のようにします。

1. トラップフレームを現在のプロセスのトラップフレームとしてその`context`
  フィールドに保存する。
2. 次に実行するプロセスのトラップフレームをその`context`フィールドから復元する。
3. どのプロセスが実行中かを追跡するためにスケジューリング状態を変更する。

残念ながら、最初のプロセスにコンテキストスイッチするにはこの手順から少し外れる
必要があります。最初のプロセス以前に上記のステップのいずれかを実行するのは
正しくありません。それがどれかわかりますか。

最初のプロセス以前にこの手順を踏むとどうなるか見てみましょう。まず、コンテキスト
スイッチを促す例外が発生します。これがプロセススケジューラを駆動するタイマー
割り込みになることは後で説明します。ここでステップ１に従います。つまり、例外に
応答して現在のプロセスの`context`フィールドに現在のトラップフレームを格納
します。しかし、現在のプロセスはまだ存在しないことに注意してください。そして
次にステップ2の一部として次のプロセスの`context`を復元してリターンします。

プロセスの実行中に例外が発生したわけではないので、私たちが保存し、後で復元する
トラップフレームはプロセス自体とはほとんど関係がありません。言い換えれば、
プロセスのトラップフレームを無関係なもので上書きしてしまったことになります。
したがって、まず最初に有効なプロセスのトラップフレームがなければ、ステップ1を
実行することはできません。つまり、最初のプロセスに適切にコンテキストスイッチ
するにはそのプロセスがすでに実行中である必要があります。さらに別の言い方を
すれば、最初のコンテキストスイッチが発生した後でないとコンテキストスイッチを
正しく実行できないということです。お手上げです。

これを回避するために最初のコンテキストスイッチを _偽装_ することにより
コンテキストスイッチをブートストラップすることにします。最初のプロセスの
トラップフレームをすでに書いた`context_save`ルーチンによるものではなく、
新しいプロセスのスタック上に手でトラップフレームを作成し直接`context_restore`
を呼び出すことで上記のステップ1を完全に回避します。一旦最初のプロセスが
実行されれば他のすべてのコンテキストスイッチは正常に動作します。

#### カーネルスレッド

私たちはまだコードをディスクからメモリにロードするメカニズムを構築していません。
仮想メモリを有効にしたらそのための手続きを実装する必要があります。今のところ、
カーネルとメモリを共有している間は単にカーネルのコードとデータを再利用する
ことができます。カーネルとプロセスがローカルデータ（スタック）を共有しない限り
（これはプロセスごとに新しいスタックを確保することにより怒らないことが保証
されています）、問題なく同時実行できます。さらに、Rustはプロセス間でデータ
競合が発生する可能性がないことを保証します。

プロセス間でメモリやその他のリソースを共有することはよくあることなので、
この種のプロセスには _スレッド_ という特別な名前があります。実際、スレッドとは
他のプロセスとメモリやその他のリソースを共有するプロセスに他なりません。

まもなく最初のプロセスを開始します。このプロセスはカーネルとメモリを共有する
ため _カーネルスレッド_ になります。そのため、この最初のプロセスを開始するのに
必要な作業は最小限です。コードとデータのすべてはすでにメモリ内にあるからです。

1. 「偽の」保存トラップフレームを設定することによりコンテキストスイッチを
  ブートストラップする。

2. `context_restore`を呼び出す。

3. `EL0`に切り替える。

必要なコードはごくわずかですが正しいものにするためには慎重な実装が必要である
ことがわかるでしょう。

**注記: _カーネルスレッド_ という用語には2️つの意味で使われています**
> _カーネルスレッド_ という用語は、（ユーザ空間で実装されているスレッドに
> 対して）カーネルで実装されているスレッドと、カーネル内で実行しているスレッド
> という2つのスレッドを指すのに使われています。これは不幸な名前の衝突ですが、
> 通常は、文脈によってどちらの意味かは明確です。簡単な経験則として、OSの開発に
> 関する議論でない限り、カーネルで実装されているスレッドに関する議論であると
> 考えるべきです。

#### 実装

`kern/src/main.rs`には新しいグローバル変数`SCHEDULER`があります。これは
`GlobalScheduler`型ですが単なる`Scheduler`のラッパーです。これらの型は両者とも
`kern/src/process/scheduler.rs`で定義されています。変数`SCHEDULER`はシステム
全体のスケジューラへのハンドルを提供します。

スケジューラを初期化し、最初のプロセスの実行を開始するには、`GlobalScheduler`の
`start()`メソッドを呼び出す必要があります。ここでの課題は`start()`メソッドを
実装することです。

実装には次をすることが必要です。

1. パラメータを取らずシェルを起動する`extern`関数を作成する。

    プロセスが最初に実行されるときにこの関数が呼び出されるように手配します。
    この関数は好きな場所に書くことができます。ディスク上のバイナリにバック
    アップされたプロセスを起動できるようになったらこの関数は削除します。

2. `start()`で新しい`Process`を作成し、保存トラップフレームを設定する。

    プロセスのトラップフレームを設定して後で`context_restore`によりCPUに
    復元された際に、`extern`関数が実行され、プロセスのスタックポインタが
    プロセスのスタックの上端を指し、プロセスがAAarch64実行状態の`EL0`で
    実行され、次のセクションで`EL0`からのタイマー割り込みを処理できるように
    現在の`EL1`に対してIRQ割り込みがアンマスクされるようにする必要があります。

3. 必要なレジスタを設定し、`context_restore`を呼び出し、EL0に`eret`する。

    トラップフレームを設定したら次の手順でそのプロセスへのコンテキスト
    スイッチをブートストラップできます。

    - 適切なレジスタに適切な値に設定して`context_restore`を呼び出す。

        注：ここではわざと曖昧にしています。これが不透明だと感じたら、`context_restore`が何をするのか、何をさせたいのか、どうすれば
        そうさせることができるのかを考えてください。

    - 現在のスタックポインタ（`sp`）を初期値（`_start`のアドレス）に設定する。
      これは後で例外を捕捉する際に`EL1`スタック全体を使えるようにするために
      必要です。**注意**: `sp`を直接`ldr`したり`adr`したりすることはできません。
      まず別のレジスタにロードし、そのレジスタから`sp`に`mov`する必要が
      あります。

    - もはや`0`を持っていないと思われるレジスタをすべて再設定する。
      ユーザレベルのプロセスに情報を漏らしてはいけません。

    - `eret`により`EL0`に復帰する。

    これを実装するには[インラインアセンブリ](https://doc.rust-lang.org/unstable-book/language-features/asm.html)を
    使用する必要があります。例として、変数`tf`がトラップフレームへの
    ポインタだとすると以下は`x0`の値をそのアドレスにセットし、それを`x1`に
    コピーします。

    ```rust
    unsafe {
        asm!("mov xo, $0
              mov x1, x0"
             :: "r"(tf)
             :: "volatile");
    }
    ```

関数は復帰すべきではないのでコンパイラを満足させるために`start()`関数の最後に
無限ループを追加するとよいかもしれません。メソッドを実装したら、`kmain`に`SCHEDULER.start()`の呼び出しを追加し、シェルやブレークポイントの呼び出しを
すべて削除してください。`SCHEDULER.initialize()`はまだ呼び出す必要はありません。
これはサブフェーズDで実装します。これで`kmain`は以下のように2つの初期化の
呼び出しとスケジューラを開始する呼び出しだけになるはずです。

```rust
unsafe fn kmain() -> ! {
    ALLOCATOR.initialize();
    FILESYSTEM.initialize();
    SCHEDULER.start()
}
```

すべてうまくいけばカーネルが起動すると`EL0`からあなたの`extern`関数が
呼び出され、ユーザレベルのプロセスとしてシェルが実行されます。

次に進む前にこの時点で同じプロセスに戻るコンテキストスイッチが正しく動作する
ことも確認しておく必要があります。`extern`関数でシェルを起動する前後に
`brkへの呼び出しをいくつか追加してみてください。

```rust
extern fn run_shell() {
    unsafe { asm!("brk 1" :::: "volatile"); }
    unsafe { asm!("brk 2" :::: "volatile"); }
    shell::shell("user0> ");
    unsafe { asm!("brk 3" :::: "volatile"); }
    loop { shell::shell("user1> "); }
}
```

各ブレークポイント例外から正常に戻ることができるはずです。各ブレークポイント
例外のソースは`LowerAArch64`であるはずで、これはユーザ空間への切り替えが
成功したことを示しています。すべてが期待通りに動作したら次のサブフェーズに
進んでください。

**ヒント**
> インラインアセンブリは6命令で構成されます。

**ヒント**
> インラインアセンブリ以外は`unsafe`は必要ありません。

### サブフェーズ C: タイマー割り込み

このサブフェーズではBCM2837搭載の割り込みコントローラ用のドライバを実装します。
また、既存のシステムタイマードライバを変更してタイマー割り込みを構成できるように
します。最後に、スケジューリングに基づくコンテキストスイッチのスプリングボードと
して機能する周期的なタイマー割り込みを有効にします。主に、
`lib/pi/src/interrupt.rs`と`lib/pi/src/timer.rs、kern/src/traps`で作業します。

#### 割り込み処理

AArch64では割り込みは特定のクラスの例外にすぎません。この2つの主な違いは
割り込みが非同期に発生することです。つまり、割り込みは外部イベントに応じて
外部ソースにより発生します。

下図は割り込みがソースである外部デバイスからシンクである例外ベクターに至る
経路を示しています。

![割り込み伝達経路](interrupt_path.png)

割り込みは経路上の各ポイントで選択的に無効にすることができます。割り込みが
例外ベクタに送られるには外部デバイス、割り込みコントローラ、CPU のすべてで
割り込みを受け入れるように設定されていなければなりません。

**注記: 割り込みコントローラとは何か**
> 割り込みコントローラはシステムタイマーなどの割り込み発生デバイスとCPUの間の
> プロキシおよびゲートとして動作する外部デバイスです。割り込みコントローラは
> CPUの割り込みピンに物理的に接続されています。割り込みコントローラの入力ピンに
> 信号が送られると割り込みコントローラはその信号をCPUに転送します。
>
> 間接的なレイヤーが追加されることで割り込みを選択的に有効/無効にすることが
> 可能になっています。また、CPUメーカがCPUにバンドルする割り込みコントローラを
> 選択できるようにもしています。

#### 外部デバイス

システムタイマー用のデバイスドライバは既に書いています。このサブフェーズでは
タイマーのコンペアレジスタを設定できるようにドライバを拡張します。システム
タイマーは現在時刻とコンペアレジスタの値を継続的に比較し、値が等しくなると
割り込みを発生させます。

#### 割り込みコントローラ

システムタイマーは割り込みコントローラに割り込みを伝達しますが、割り込み
コントローラはCPUに割り込みを伝達するように構成されている必要があります。
ここではこれを行うように割り込みコントローラ用のデバイスドライバを作成する
ことになります。

割り込みコントローラは割り込みを受信するとその割り込みを保留中としてマークし、
物理的な割り込みピンを論理的にハイに保持することでCPUに配送します。システム
タイマー割り込みを含むいくつかの割り込みでは割り込みが確認されるまでピンは
ハイのまま保持されます。これは割り込みは確認されるまで継続して配送されることを
意味します。割り込みが確認されると割り込みピンは解放され、保留フラグは解除
されます。

#### CPU

割り込みが例外ベクタに配送されるにはCPUにおいて割り込みを _アンマスク_ する
必要があります。デフォルトでは割り込みはCPUにより _マスクされている_ ので
配信されません。CPUは割り込みがマスクされている間に受信した割り込みを
割り込みがアンマスクされたらすぐに配信することができます。CPUは例外ベクタを
呼び出すと自動的にすべての割り込みもマスクします。これはシステムタイマー
割り込みなどの処理されるまでハイレベルを保持する割り込みが直ちに例外ループに
ならないようにするためです。

前のサブフェーズで、プロセスが`EL0`で実行中に割り込みが発生するように構成
していますのでこの点に関しては追加でやることはありません。

**質問 (reentrant-irq): IRQの処理中にIRQのマスクはいつ解除するのか**
> 私たちのカーネルは例外処理ルーチンの間ずっとIRQをマスクしているので
> ネストした割り込み処理はサポートしていませんが、IRQを処理中にIRQを
> アンマスクすることは商業OSではかなり一般的なことです。どのような
> シナリオでこのようなことをしたくなりますか。また、保留中のIRQを最初に
> 確認せずにこれを行うと例外ループになりますか。それはなぜですか。

#### 例外ベクタ

例外ベクタはすでに構成済みです。そのため、あとはIRQ（割り込み要求）例外を
適切に処理するだけです。割り込みを処理するために対応する割り込みのハンドラ
関数のリストを保持するグローバルま`Irq`構造体を設けました。`kern/src/traps/irq.rs`に
ある`register()`関数を呼び出すことで各割り込みのハンドラ関数を設定することが、
`invoke()`関数で登録したハンドラを実行することができます。`kern/src/traps.rs`に
ある`handle_exception`関数を変更して既知のすべての割り込み要求を`invoke()`
関数に送るようにします。

どの割り込みが発生したかを判断するには割り込みコントローラでどの割り込みが
保留中かをチェックする必要があります。`handle_irq`関数は割り込みを認識して、
それを処理します。

#### 実装

`lib/pi/src/interrupt.rs`にある割り込みコントローラドライバの実装から始めます。
割り込みコントローラのドキュメントは[BCM2837 ARM Peripherals Manual](../arm_docs/BCM2837-ARM-Peripherals.pdf)の
第7章にあります。必要な処理は`Interrupt` enumで記述されている通常IRQの有効化、
無効化、状態チェックだけです。FIQやBasic IRQについては無視して構いません。
`interrup`構造体は4`つのメソッドを提供しています。iter()`メソッドはどの
割り込みが保留中であるかをチェックするために割り込みを走査する際に使用できます。
`to_index()`と`from_index()`は`register()`と`invoke()`を実装する際に
役に立ちます。

次に、システムタイマードライバ用の`tick_in()`メソッドと関数を
`lib/pi/src/timer.rs`に実装します。システムタイマーに関するドキュメントは
[BCM2837 ARM Peripherals Manual](../arm_docs/BCM2837-ARM-Peripherals.pdf)の
第12章にあります。`tick_in()`を正しく実装するには2つのレジスタに書き込む
必要があります。

次は、`src/traps/irq.rs`に移動して`register()`メソッドと`invoke()`メソッドを
実装します。`Irq`構造体は内部にハンドラ関数のスマートポインタである`IrqHandler`
のリストを保持しています。`register()`メソッドで割り込みのハンドラ関数を
セットし、`invoke()`メソッドで実行することができます。

次に、タイマー割り込みを有効にし、`kern/src/process/scheduler.rs`にある
`GlobalScheduler::start()`で最初のプロセスを開始する直前に`TICK`マイクロ秒毎に
タイマー割り込みが発生するように設定します。`TICK`変数はk`ern/src/param.rs`で
宣言されています。さらに、タイマーのハンドラ関数を登録します。タイマー
割り込みが`TICK`マイクロ秒ごとに無期限に発生するようにハンドラ関数を
`TICK`マイクロ秒毎に新しいタイマー割り込みが発生するように設定します。
実装をテストするためにここにメッセージを表示するとよいでしょう。

`kern/src/traps.rs`にある`handle_exception`関数を変更して既知の割り込みを
`kern/src/traps/irq.rs`にある`invoke()`関数に転送するようにします。

最後に、`kern/src/main.rs`で`SCHEDULER.start()`を呼び出す前に
`IRQ.initialize()`を追加します。

実装が終了するとソースが`LowerAArch64`、種類が`Irq`のタイマー割り込みが
`TICK`マイクロ秒ごとに発生するのが確認できるはずです。タイマー割り込みが
発生するまでの間は通常通りプロセスとやりとりできるはずです。すべてが期待
通りに動作したら次のサブフェーズに進んでください。

**警告: `TICK`の設定は後で変更する**
> 現在のところ、すべてが期待通りに動くことを確認するために2秒という途方も
> なく遅い`TICK`設定を使っています。通常、この数値は1ミリ秒から10ミリ秒の
> 間にします。後で`TICK`をより合理的な10ミリ秒に下げます。

### サブフェーズ D: スケジューラ

このサブフェーズではシンプルなラウンドロビン型のプリエンプティブスケジューラを
実装します。主に`kern/src/process/scheduler.rs`と`kern/src/process/process.rs`
で作業します。

#### スケジューリング

スケジューラの主な責務は次にどのタスクを実行するかを決定することです。
ここでタスクとはCPUでの実行を要求するあらゆるものと定義されます。私たちの
OSは比較的単純なのでスケジューラが考えるタスクはプロセスに限定されます。
したがって、私たちのスケジューラの責務は（もしあれば）次に実行するプロセスを
決定することです。

無数の特性をもつ多くのスケジューリングアルゴリズムが存在します。最も単純な
もののひとつに「ラウンドロビン」スケジューリングがあります。ラウンドロビン
スケジューラはタスクのキューを管理します。次に実行するタスクはキューの先頭
から選ばれます。スケジューラは固定のタイムスライス（`TICK`）（_クウォンタム_
とも呼ばれます）だけタスクを実行します。タスクが最大クウォンタムまで実行する
とスケジューラはそのタスクをキューの最後尾に移動させます。このようにラウン
ドロビンスケジューラは単にタスクのキューを循環させるだけです。

私たちのOSではスケジューラはタスクを4つの状態のうちの1つにマークします。

- **Ready**

    実行の準備ができているタスク。順番が来たらスケジューラはそのタスクを
    実行します。

- **Running**

    現在実行中のタスク。

- **Wating**

    イベント待ちのタスクであり、そのイベントが発生するまで実行する準備は
    できていません。スケジューラはタスクの順番が来た際にイベントが発生したか
    チェックします。イベントが発生していた場合はそのタスクが実行されます。
    そうでなければ、そのタスクは順番を失い次回に再びチェックされることに
    なります。

- **Dead**

    タスクは現在死んでおり（実行しておらず、実行する資格もない）、再生される
    のを待っている。

`kern/src/process/state.rs`にある`State`列挙型はこれらの状態を表します。
各プロセス構造体はスケジューラが管理する`State`に関連付けられています。
`Waiting`状態は、待機中のイベントが発生したか否かをスケジューラが判断する
ために使用できる関数も持っていることに注意してください。

下図はラウンドロビンスケジューラの4つのスケジューリングラウンドを示しています。
タスク`C`はラウンド3と4の間に発生するイベントを待っています。

![ラウンドロビンスケジューラ](roundrobin.png)

ラウンドは以下の通りです。

1. ラウンド1では、キューには`A`、`B`、`C`、`D`の4つのタスクがあります。
  キューの先頭にあるプロセス`A`が現在CPUで実行中です。`C`は待機状態ですが
  他のプロセスは準備中または実行中です。`A`はクウォンタムを使い切ると
  キューの末尾に移されます。

2. ューの先頭のタスク`B`が実行されます。クウォンタムが切れると`B`はキューの
  末尾に移されます。

3. `C`はイベントを待っているためスケジューラは待機中のイベントが発生したか
  否かをチェックします。この時点ではイベントは発生していなかったため、`C`は
  スキップされ、`D`が次に実行されるタスクとして選択されます。`D`は先頭に
  移され実行されます。クウォンタムが切れると`D`はキューの末尾に移されます。

4. `C`は依然として大気中の状態なのでスケジューラはイベントが発生したか否かを
  チェックします。この時点ではイベントが発生していたので`C`がスケジューリング
  されます。タイムクウォンタムが切れると`C`はキューの末尾に移されます。

**質問 (wait-queue): 準備完了のタスクと待機中のタスクを分けることは有益か**
> ラウンドロビンスケジューラの別の実装では準備完了タスクのみからなる _ready_
> キューと待機中タスクのみからなる _wait_ キューの2つのキューを保持します。
> あなたはラウンドロビンスケジューラのキューをどのように利用しますか。性能
> （平均タスクレイテンシ/スループット）は良くなりますか、悪くなりますか。

#### コードの構造

`kern/src/process/scheduler.rs`にある`Scheduler`構造体は実行すべきプロセスの
キューを管理します。プロセスは`Scheduler::add()`メソッドによりキューに追加
されます。このメソッドはプロセスに一意のIDを割り当てる役割も担っています。
IDはプロセスの`TPIDR`レジスタに格納されます。

スケジューリングの変更が必要になると`Scheduler::schedule_out()`と
`Scheduler::switch_to()`メソッドが呼び出されます。その名前が示すように、
`schedule_out()`メソッドは現在のプロセスの状態を`new_state`に変更し、現在の
トラップフレームを現在のプロセスに保存し、現在のプロセスをスケジューリング
キューの末尾に移動させます。Raspberry Piのボードには4つのコアがあるので
コアの数だけ`Running`状態のプロセスが存在する可能性があることを思い出して
ください。そのため、現在のタラップフレームに格納されているプロセスIDに
基づいて現在のプロセスを見つける必要があります。`switch_to()`メソッドは
次に実行するプロセスを見つけて、その次のプロセスをキューの先頭に移動させ、
次のプロセスのトラップフレームを復元し、次のプロセスの状態を`Running`に
します。

プロセスが実行可能か否かを判断するためにスケジューラは`kern/src/process/process.rs`で
定義されている`process.is_ready()`メソッドを呼び出す必要があります。この
メソッドは状態が`Ready`であるか、待機中のイベントが発生していた場合に
`true`を返します。

スケジューラは`TICK`マイクロ秒ごとに起動される必要があります。前のサブ
フェーズで設定したタイマー割り込みはスケジューリング変更の主な原因の1つに
なります。`GlobalScheduler`型は`Scheduler`の`add()`メソッドと`kill()`
メソッドのラッパーと共にスレッドセーフな`switch()`メソッドを提供しています。
`switch()`メソッドはまずロックを取得してから現在のプロセスをスケジュールアウト
します。そして、次のプロセスへの切り替えを繰り返し試みます。`switch_to()`
メソッドは全プロセスが`Waiting`状態にある時などで次のプロセスが見つからなかった
場合、`wfe`命令を実行して低電力状態にし、それ以上命令を実行することなく
イベントが発生するまで待機します。

最後に、現在実行中のプロセスを終了させるには`Scheduler::kill()`メソッドを
呼び出します。このメソッドは次のサブフェーズでシステムコールにより呼び出され
ます。このメソッドは内部的に`Dead`状態をパラメータとして`Scheduler::schedule_out()`
メソッドを呼び出して現在のプロセスをスケジュールアウトします。そして、
死んだプロセスをキューの末尾から削除し、死んだプロセスのインスタンスを削除
します。`GlobalScheduler`型は`Scheduler::kill()`のスレッドセーフなラッパーを
提供しているので死んだプロセスがプロセスキューの末尾エントリであることは
保証されています。

**質問 (new-state): なぜスケジューラは新しい状態を知らないのか**
> `scheduler.switch()`メソッドは呼び出し元に現在のプロセスの新しい状態を
> 渡すことを要求します。これはスケジューラはプロセスの新しい状態がなんで
> あるべきかを知らないことを意味します。なぜ知らないのですか。

#### 実装

以上でラウンドロビンスケジューラを実装する準備ができました。次の順で
実装することを推奨します。

1. **`kernel/src/process/process.rs`にある`Process::is_ready()`メソッドを実装する**

    ここでは`mem::replace()`関数が役に立つことが証明されるでしょう。
    `Waiting`状態には待機中のイベントが発生したか否かをチェックする関数が
    含まれていることに注意してください。これが`true`を返した場合のみ、
    `Waiting`プロセスはスケジューリングできます。

2. **`kern/src/process/scheduler.rs`にある`Scheduler`構造体を実装する**

    実装する必要のある関数は`new()`、`add()`、`schedule_out()`、
    `switch_to()`、`kill()`の5つです。

3. **`GlobalScheduler::initialize()`でスケジューラを初期化する**

    グローバルスケジューラは最初のプロセスが実行される前に作成/初期化
    されている必要があります。最初のプロセスは実行前にスケジューラの
    キューに存在していなければなりません。

4. **`GlobalScheduler::start()`を修正する**

    extern関数のアドレスからプロセスを開始するのはなく`switch_to`関数を
    使用してスケジューリングキューからプロセスを開始するようにします。

5. **タイマー割り込みが発生したときにスケジューラを起動する**

    タイマー割り込みが発生したときに`SCHEDULER.switch()`を起動して
    現在のプロセスと次のプロセスとの間でコンテキストスイッチを行います。

`GlobalScheduler::initialize()`に複数のプロセスを追加してスケジューラを
テストしてください。新しいプロセスを割り当ててトラップフレームを適切に
設定する必要があります。プロセスを区別できるように新しいプロセスごとに
新しい`extern`関数を作成するとよいでしょう。プロセスをスケジューラのキューに
正しい順番で追加することを忘れないでください。

実装が終了したら`TICK`マイクロ秒ごとに異なるプロセスが実行されるはずです。
タイマー割り込みの間は各プロセスと普通にやりとりできるはずです。すべてが
期待通りに動いたら次のサブフェーズに進んでください。

**警告: オーバーフロー**
> プロセスIDを生成する際にオーバーフローさせないでください。

**警告: unsafe**
> これらのルーチンの実装には`unsafe`を使用してはいけません。

**ヒント**
> プロセスの`State`の所有バージョンを取得するには`mem::replace()`を
> 使用してください。

**質問 (wfe): 準備完了のプロセスが存在しないのに何故イベントを待つのが正しいのか**
> 準備完了のプロセスがないときに`wfe`命令を使って待機することはイベントが
> 到着するまでCPUがストールすることを意味します。`wfe`の実行後にイベントが
> 来なければスケジューリングが再開されることはありません。なぜこれが正しい
> 動作なのでしょうか。

    ヒント: プロセスが待機状態になるシナリオを考えてください。

**注記: wfeについての注意**
実行可能なプロセスがない場合、プロセッサは`wfe` (Wait-For-Event) 状態に
なります。このコンテキストにおいては`event != interrupt`です。これは
プロセッサが`wfe`状態になるとタイマー割り込みにでは起床されないことを
意味します。そのため、スケジューリングは再開されません。割り込み待ち状態に
したい場合は`wfe`命令を`wfi`命令に変更してください。

### サブフェーズ E: スリープ

このサブフェーズでは`sleep`システムコールとシェルコマンドを実装します。
主に`kern/src/shell.rs`と`kern/src/traps`で作業します。

#### システムコール

システムコールとはある種の例外に他なりません。`svc #n`命令が実行されると
システムコール`n`に対応してシンドローム`Svc(n)`の同期例外が生成されます。
これは優先リンクアドレスが`svc`命令そのものではなくその命令の次の命令で
あることを除けば`brk #n`が`Brk(n)`例外を生成する方法と似ています。システム
コールとはユーザプロセスが権限は足りず自分では実行できないサービスをOSに要求
する際に使用するメカニズムです。

一般的なOSではファイルシステム操作からハードウェアに関する情報の取得にいたる
100以上のシステムコールが公開されています。このサブフェーズでは`sleep`
システムコールを実装します。`sleep`システムコールはスケジューラにある時間の
間プロセスをスケジューリングしないように要求します。言い換えると、プロセスを
スリープさせるようOSに要求します。

#### システムコール規約

関数コールに規約が必要なようにシステムコールにも規約が必要です。私たちの
OSは他のUnixベースのOSで使われているシステムコール規約を修正したものを
採用します。その規則は以下のとおりです。

- システムコール`n`は`svc #n`で呼び出される。
- レジスタ`x0`...`x6`経由で最大7つのパラメータをシステムコールに渡す
  ことができる。
- レジスタ`x0`...`x6`経由で最大7つのパラメータをシステムコールから返す
  ことができる。
- レジスタ`x7`はエラーを示すために使用される。取り得る値については
  `lib/kernel_api/src/lib.rs`を参照。

      - `x7`が`1`の場合、エラーはない。
      - `x7`が`0`の場合、不明なエラーが発生した。
      - `x7`がその他の値の場合、システムコール固有のエラーコードを表す。

- 他のすべてのレジスタとプログラム状態はカーネルにより保持される。

したがって、`u32`と`u64`の2つのパラメータを取り、`u64`の2つの値を返す
架空のシステムコール`7`を呼び出すにはRustのインラインアセンブリを使って
次のように書きます。

```rust
fn syscall_7(a: u32, b: u64) -> Result<(u64, u64), Error> {
    let ecode: u64;
    let result_one: u64;
    let result_two: u64;
    unsafe {
        asm!("mov w0, $3
              mov x1, $4
              svc 7
              mov $0, x0
              mov $1, x1
              mov $2, x7"
              : "=r"(result_one), "=r"(result_two), "=r"(ecode)
              : "r"(a), "r"(b)
              : "x0", "x1", "x2")
    }

    let e = OnError::from(ecode);
    if let OsError::Ok = e {
        Ok((result_one, result_two))
    } else {
        Err(e)
    }
}
```

システムコールのラッパーは結果値を返す前にエラー値をチェックしていることに
注意してください。`lib/kernel-api/src/lib.rs`に定義済みのシステムコール番号と
`OsError`のenumがあります。

**質問 (syscall-error): エラー値を渡すのになぜ別のレジスタを使うのか**
> Linuxを含むほとんどのUnix系OSでは最初の結果レジスタ（私たちの例では`x0`）を
> エラー値レジスタとしても使用しています。これらの規約ではある範囲の負値は
> エラーコードを表し、それ以外の値は成功した戻り値として解釈されます。私たちが
> 取ったアプローチの利点は何ですか、また、不利な点はなんですか。

#### Sleepシステムコール

`sleep`システムコールは私たちのOSではシステムコール番号`1`です。このシステム
コールは`u32`のパラメータを1つ取ります。このパラメタは呼び出し元のプロセスを
一時停止させるべきミリ秒数に対応します。エラー値の他に`u32`のパラメータが1つ
返されます。このパラメタはプロセスが最初にスリープを要求してから起床される
までに経過したミリ秒数に対応します。擬似コードのシグネチャは以下のように
なります。

```rust
fn sleep(t: u32) -> u32
```

**質問 (sleep-elapsed): 経過時間が要求した時間と異なるのはどういうときか**
> もしあるとすれば`sleep`からの戻り値が入力値と異なる場合はどのような
> 状況ですか。もしあるとすればどのような状況で両者が同じになりますか。
> それぞれの場合の相対的な確率はどのくらいだと思いますか。

#### 実装

それでは`sleep`システムコールを実装してください。まず、`kern/src/traps.rs`に
ある`handle_exception`関数を修正してシステムコール例外を認識し、
`kern/src/traps/syscalls.rs`にある`handle_syscall`関数に転送するように
します。

次に、`handle_syscall`関数を実装してください。この関数は`sleep`システム
コールを認識してそのハンドラ関数`sys_sleep()`を呼び出します。`sys_sleep()`の
内部では現在実行中のプロセスを要求に応じて変更します。実装を完成させるには
クロージャを使用して`Box<FnMut>`を作成する必要があるでしょう。これは次の
ようになります。

```rust
let boxed_fnmut = Box::new(move |p| {
    // `p`を使う
});
```

クロージャについては[TRPLv2](https://doc.rust-lang.org/book/ch13-01-closures.html)を読んでください。

最後に、スリープ時間のミリ秒である`ms`をパラメタとして渡してsleepシステム
コールを呼び出す`sleep <ms>`コマンドをシェルに追加してください。

ユーザレベルのシェルで`sleep`を呼び出して実装をテストしてください。プロセスが
スリープ中はスケジューリングされないことを確認してください。他のすべての
プロセスは正しくスケジューリングされ続けるはずです。次に、すべてのプロセスが
スリープ中の場合はどのプロセスもスケジュール _されない_ ことを確認してください。
実装が期待通りに動いたら次のサブフェーズに進んでください。

**ヒント**
> `sleep`システムコールハンドラはスケジューラと対話する必要があります。

**ヒント**
> クロージャは環境から値を取り込むことができることを思い出してください。

**ヒント**
> `kernel_api::syscall::sleep(span::Duration)`関数を提供ています。
> sleepシステムコールを呼び出すためにシェルで自由に使ってください。
> システムコール番号とエラーコードも`kernel_api`ライブラリにあります。

**ヒント**
> `u32`型は`FromStr`を実装しています。

## フェーズ 3: メモリ管理ユニット

このフェーズではメモリ管理ユニットのサポートを有効にします。これにより
システムが複数のプロセスをそれぞれのプライベート仮想メモリ空間で独立して
実行できるようにします。まず、`VirtualAddr`構造体と`PhysicalAddr`構造体、
アドレスの変換をサポートするためのいくつかのトレイトについてレビューする
ことから始めます。次に、64KBアラインのページをインデックスする2レベルの
ページテーブルを実装します。この`PageTable`構造体を使用してカーネルページ
テーブルとユーザページテーブルを実装します。最後に、仮想メモリ空間を持つ
プロセス間のコンテキストスイッチをサポートするために`init.rs`や
`scheduler.rs`などのこれまでのフェーズで部分的に構築したコードを再検討
します。

### サブフェーズ A: 仮想メモリ

このサブフェーズでは`kern/src/vm/address.rs`にある64ビットアドレス値を
表す`VirtualAddr`構造体と`PhysicalAddr`構造体をレビューします。次に、
`kern/src/traps/frame.rs`と`kern/src/init/vectors.s`で`TrapFrame`に2つの
レジスタを追加します。

#### 仮想アドレスはなぜ必要なのか

カーネルプロセスとユーザプロセスで物理メモリを共有するのではなく、各ユーザ
プロセスは独自の仮想メモリ空間を持つことになります。これによりプロセスは
互いに隔離され、信頼できないプロセスからカーネルメモリを保護することが
できます。

仮想メモリ空間をサポートすることにより、ユーザプロセスは物理メモリ空間に
ついて何も知る必要がなくなります。つまり、プロセスは実際のハードウェア
アドレスも同時に実行されているかもしれない他のプロセスの仮想空間も意識
することはありません。

各プロセスの仮想空間は分離されているので2つの異なるプロセスがまったく同じ
仮想アドレスを使用していても、それぞれは異なる物理アドレスに変換されます。

また、仮想空間と物理空間が分離されているため、連続した仮想メモリページを
不連続な物理メモリページに変換することができます。つまり、物理空間の
不連続なページを利用して、1つの連続した仮想空間を形成することができます。
ユーザプロセスは仮想メモリ空間で実行するアプリケーションを作成、コンパイル、
リンクすることができます。OSはすべてのメモリアクセスの物理メモリアドレスへの
マッピングを担当します。

OSがこれを実現するには仮想空間と物理空間の間のすべての変換を処理する
（一般にMMUと呼ばれている）メモリ管理ユニットが必要です。

#### MMUはどのように使うのか

メモリ管理ユニットは仮想空間アドレスと物理アドレスの変換を行うハードウェア
ユニットです。MMUを使用するには、まずこれを有効にし、変換に使用するページ
マッピングテーブルを提供する必要があります。つまり、MMUはすべての変換を
行いますが、OSはページテーブルの作成と維持をする責任があります。

MMUを有効にするとプロセッサの命令フェッチとメモリアクセスはすべてMMUを
通して変換されるようになります。そのため、カーネル空間用とユーザ空間用の
両者に適切なページテーブルを提供する必要があります。

MMUを有効にした結果、カーネルは仮想メモリを使用し、そのページテーブル
セットを維持する準備が必要になります。このフェーズの後の部分ではそれを
どのようにセットアップするかを説明します。

#### カーネルプロセスとユーザープロセスの分離

通常、OSは多くのプロセスを同時に実行します。これらのプロセスは各自の仮想
メモリ空間を持つため、OSは各プロセスの変換テーブルを記録する必要があります。
各プロセスの変換テーブルには仮想ページアドレスを物理ページアドレスに
マッピングする情報が含まれています。これらのページテーブルはユーザプロセスと
物理アドレス間の変換に使用されるため _ユーザページテーブル_ と呼ばれます。

同様に、MMUを有効にしているので、MMUがカーネルアドレスを正しくマッピングし
続けるために使用する _カーネルページテーブル_ を提供する必要があります。
MMUは提供したカーネルページテーブルにより指定されるカーネルページの
パーミッションも強制します。したがって、カーネルメモリページとプロセス
メモリページの間でパーミッションの分離もされることになります。

ARMアーキテクチャにはMMUがアドレス変換に使用するページテーブルを記録する
ためのレジスタである _翻訳テーブルベースレジスタ_ が`TTBR0_EL1`と
`TTBR1_EL1`の2つあります。私たちの設計では`TTBR1_EL1`は _ユーザページテーブル_
のベースアドレスを、`TTBR0_EL1`は _カーネルページテーブル_ のベース
アドレスを指すために使用します。各プロセスとカーネルページテーブルを
記録するために両レジスタを`TrapFrame`に追加する必要があります。

カーネルレベルとユーザレベルで仮想空間アドレスを使用するようになったので
仮想アドレス空間を分割して、カーネルアドレスとユーザアドレスを仮想空間内で
明確に分離する必要があります。そのためにユーザレベルの仮想アドレスには
`0xffff_ffff_c000_0000`から始まるアドレスを、カーネル空間の仮想アドレスには
`0x0`から始まるアドレスを使うことにします。

したがって、ユーザレベルの仮想メモリ空間の最大サイズは`0x4000_0000` となり、
これは!GBになります。これらの変数は`kern/src/param.rs`で定義されています。

**質問 (which-table): MMUはどちらのテーブルを使うかをどうやって知るのか**
> MMUは仮想アドレスが与えられると物理アドレスに正しく変換するために
> `TTBR1_EL1`をベースとするユーザページテーブルか、`TTBR0_EL1`を
> ベースとするカーネルページテーブルのいずれかを使用します。では、
> MMUは与えられたアドレスに対して2つのテーブルのどちらを使うべきかを
> どうやって知るのでしょうか。

  **ヒント**: カーネルレベルとユーザーレベルの仮想空間は任意のアドレスで分割したわけではありません。
  カーネルレベルを仮想空間の上位部分にしたらどうなるでしょうか。次のリファレンスが参考になるでしょう:
  [ARMv8-Aアドレス変換](../arm_docs/ARMv8-A-Address-Translation.pdf)

#### 実装

`kern/src/vm/address.rs`にある`VirtualAddr`と`PhysicalAddr`を見てください。
名前も目的も違いますがその構造、必要とするトレイト、機能に違いはありません。

次に、トラップフレームに`TTBR0_EL1`と`TTBR1_EL1`レジスタを追加してください。
そのためには`kern/src/traps/frame.rs`と`kern/src/init/vectors.s`を修正する
必要があります。`TTBR0_EL1`と`TTBR1_EL1`を保存/復元するための命令を追加
する必要があります。他のシステムレジスタで行ったように`handle_exception`を
呼び出す前に`context_save`で保存し、`hadnle_execption`から復帰した後に
`context_restore`で復元します。これに応じて`TrapFrame`構造体に`TTBR0_EL1`と
`TTBR1_EL1`を追加するも必要があります。`TrapFrame`構造体はトラップフレームの
レイアウトと正確に一致させる必要があることに注意してください。

さらに`vectors.s`でスタックから`TTBR0_EL1`と`TTBR1_EL1`を復元した後に次の
4行を挿入する必要があります。このコードブロックは`dsb`命令の前に行ったメモリ
アクセスが`dsb`命令が実行される前に完了することを保証するために必要です。

```
dsb   ishst
tlbi  vmalle1
dsb   ish
isb
```

変更がトラップフレームとコンテキストスイッチの機能に影響しないことを
テストしてください。すべてがうまくいったら次のサブフェーズに進んで
ください。

#### サブフェーズ B: ページテーブル

プロセッサが命令フェッチやデータアクセスのために64ビット仮想アドレスを
発行するとメモリ管理ユニット（MMU）は仮想アドレスを対応する物理アドレスに
変換します。

![仮想アドレスから物理アドレスへの変換](trans_vm_pm.png)

上図は64KBページの仮想アドレスから物理アドレスへの変換の一例です。これは
64KBの粒度と42ビット仮想アドレス空間を想定しており、私たちのODでは
この設定を使用します。図K6-13のビットを指定したより詳細な図は (ref: K6.1.2)
を参照してください。

上の図で何が起きているのか見ていきましょう。上部に示されている64ビットの
仮想アドレスは4つの領域に分割されます。

- **ビット[63-42]** は`TTBR0`と`TTBR1`のどちらのページテーブルを使用する
  かを決定するために使用されます。
- **ビット[41-29]** は選択された`TTBRx`をベースアドレスとするL2テーブルの
  インデックスに使用されます。13ビットが使用されているためこのレベルの
  ページテーブルは8192個のエントリを持つことができ、各エントリは64ビットです。
  この64ビットの各ビットがどのように使用されるかは後で説明しますが、
  ここではこれらのエントリのビット[47-16]はL3ページテーブルのベースアドレス
  として使用されるとだけ言っておきます。
- **ビット[28-16]** は選択されたL3ページテーブルのインデックスに使用
  されます。13ビットを使用するのでL3ページテーブルには8192個のエントリを
  持つことができ、各エントリは64ビットです。この64ビットのうち、[47-16]
  ビットを最終的な物理アドレスに使用します。
- **ビット[15-0]** はL3エントリからビット[47-16]でアドレス指定された
  ページ内のバイトオフセットとして使用されます。私たちは64KBのページを
  使用していますので各バイトをアドレス指定するには16ビットで十分です。

仮想アドレスのさまざまな部分がわかったところでMMUがアドレス変換を実行
する手順を詳しく説明します。

1. ユーザページのマッピングの場合、`TTBR1`が最初のページテーブルの
  ベースアドレスとして使用されます。カーネルまたはI/Oペリフェラルの
  マッピングの場合は`TTBR0`が最初のページテーブルのベースアドレスとして
  使用されます。
2. ページテーブルには8192個の64ビットページテーブルエントリがあり、
  仮想アドレスの[41:29]ビットがテーブル内のエントリを見つけるための
  インデックスとして使用されます。
3. 選択されたL2ページテーブルエントリの有効性と要求されたメモリアクセスが
  許可されているか否かをチェックします。
4. エントリが有効で許可されている場合、L2ページテーブルエントリの[47:16]
  ビットがレベル3のページテーブルのアドレスを見つけるために使用されます。
5. 仮想アドレスの[28:16]ビットがL3ページテーブルエントリのインデックス
  として使用されます。
6. 選択されたL3ページテーブルエントリの有効性と要求されたメモリアクセスが
  許可されているか否かをチェックします。
7. エントリが有効で許可されている場合、このL3ページテーブルエントリは64KBの
  物理ページを参照しています。L3ページテーブルエントリのビット[47:16]が
  取り出され物理アドレスのビット[47:16]として使用されます。
8. 64KBのページを使用しているので仮想アドレスの[15:0]が物理アドレスの
  [15:0]として使用されます。

各レベルのページテーブルの数はOSやどれだけのメモリをマッピングする必要が
あるかによります。実際、この階層モデルをフルに活用すれば必要以上に大きな
仮想空間を持つことになります。しかし、私たちの設計ではユーザレベルの仮想
メモリは1GBで十分です。したがって、ユーザページテーブルにはそれぞれが
異なるL3ページテーブルを指す2つのエントリを持つL2ページテーブルを1つだけ
用意することにします。2つのL3ページテーブルにはそれぞれ8192個のエントリがあり、
それぞれが64KBのページを指します。したがって次のように計算できます。

**1（L2テーブル）\* 2（L3テーブル）\* 8192（L3エントリ）\* 64KB（ページサイズ）= 1GB**

**質問 (translation-control): 私たちの設計はどう違うか**
> 上の図は私たちの設計と正確には一致しません。特に、`TTBRの選択`と
> `レベル2インデックス`に使うビット数が私たちの設計とは異なります。
> 私たちの設計ではこれらのビット数が何であるかわかりますか。また、
> 私たちの設計を適用するためにMMUをどのように構成したら良いですか。

  **ヒント**: 前の質問とまったく同じヒントです：カーネル仮想空間と
    ユーザ仮想空間でアドレス分割をどのように行ないましたか。コードの
    どこで、`0xffff_ff_c000_0000`以上のアドレスがユーザ仮想空間用になる
    ようにMMUを構成しましたか。

#### ページテーブルエントリ

PDF文書「[ページテーブルエントリ](pagetable-entry.pdf)」には
L2/L3ページテーブルエントリの具体的な詳細（ビット位置、名前、フィールドの
説明など）が記載されています。ページテーブルを実装する際にはこのドキュメントを
参照することになるでしょう。詳細については (ref:  D4.3) を参照してください。

`ADDR`フィールドには32ビットの出力アドレスが含まれます。このアドレスは
L2テーブルエントリかL3テーブルエントリかにより使用方法が異なります。
L2テーブルの場合、出力アドレスは仮想アドレスの[28:16]ビットに位置する
レベル3インデックスと組み合わされて、L3ページテーブルを指します。L3
テーブルの場合、出力アドレスは変換された物理アドレスの[47:16]ビットに
なります。

各エントリの下位10ビットはメモリ属性を表します。

- **VALID**: ディスクリプタが有効か否かを示します。そのエントリを使用
  するには有効であると設定する必要があります。
- **TYPE**: L2エントリの場合は、メモリブロックを指すディスクリプタか次の
  レベルの変換テーブル（L3）を指すディスクリプタのいずれかとして解釈
  できます。私たちのL2エントリはL3テーブルを指す必要があり、L3エントリは
  メモリページを指すことに注意してください。
- **ATTR**: メモリ領域の属性を記述します。ユーザページテーブルが新しい
  ページを割り当てる際、そのL3エントリはノーマルメモリである必要があります。
  同様に、カーネルページテーブルがL3エントリを設定する場合もノーマル
  メモリでなければなりません。一方、`IO_BASE`から`IO_BASE_END`までの
  メモリ範囲については、L3ページテーブルにデバイスメモリエントリを持つ
  必要があります。
- **NS**： 私たちのシステムでは考慮しません。
- **AP**: エントリのデータアクセス権限を設定します。カーネルページテーブルは
  `KERN_RW`権限を、ユーザページテーブルは`USER_RW`権限を持つ必要があります。
- **SH**: 共有可否フィールド。ノーマルメモリ空間のエントリには内部共有可能を、
  デバイスメモリのエントリには外部共有可能をセットする必要があります。
- **AF**: 最初にアクセスされた際に設定される必要があります。ページテーブル
  エントリを作成した際には常にこのビットをセットすることを忘れないでください。
  私たちの実装ではすべてのページが使用されていると仮定します。

ここで`lib/aarch64/src/vmsa.rs`ファイルを開いて定義済みの属性の`RawL2Entry`
ビットと`RawL3Entry`ビットを確認してください。`defbit!`マクロは
`lib/aarch64/src/macros.rs`ファイルで定義されてます。ライブラリコードを
読んで理解があっているかを確かめ、各エントリに実装されているメソッドの
使い方を学んでください。

#### 私たちのOSのメモリ空間レイアウト

これでMMUとページテーブルについての詳細な知識を得たことになります。次は私たちの
OSのメモリレイアウトをどのように設計するかについて検討します。

簡単に復習すると、仮想空間では、カーネルアドレスは仮想アドレスの`0x0`から始まり、
ユーザアドレスは仮想アドレスの`0xffff_fffc_0000_0000`から始まります。このように
仮想空間を分割しましたが物理空間はどうなるのでしょうか。

```bash
-------------------  0xFFFF_FFFF_FFFF_FFFF
ユーザ空間 (1GB)
-------------------  0xFFFF_FFFF_C000_0000  = 2^64 - 2-(64 - TCR_EL1:T1SZ(34))
未使用
-------------------  0x0000_0000_FFFF_FFFF  = 2^(64 - TCR_EL1:T0SZ(32))
カーネル空間 (4GB)
-------------------  0x0000_0000_0000_0000
```

私たちのOSは次のように設計します。カーネルが実行を開始したらカーネルページ
テーブルを作成し、利用可能な物理メモリをすべてカーネルの仮想メモリにマッピング
します。まず、ラボ3で実装した`memory_map`関数を使って利用可能な物理メモリの
終端を求めます。次に、仮想と物理の両アドレス空間をアドレス`0x0`から開始し、
`memory_map`から得た終端アドレスまでのすべてのページ用にページテーブルエントリを
作成します。こうすることでカーネルはこれまで使っていた物理アドレスをそのまま
使い続けることができ、MMUは必要なテーブルが提供されたことで満足します。

メモリマップドIOデバイスについても同様に処理を行います。`IO_BASE`と`IO_BASE_END`の
間の領域をページごとに同じ仮想アドレスにマッピングします。こうすることでこれまでと
同じアドレスでIOデバイスを使い続けることができます。`IO_BASE`と`IO_BASE_END`の
定義は`pi/src/common.rs`にあります。

rpiのメモリは1GBなのでカーネルページテーブルとユーザページテーブルはまったく
同じように設計できることに注意してください。すなわち、1つのL2テーブルと2つの
L3テーブルです。

ではユーザ仮想メモリについてはどうでしょうか。すべての物理メモリをカーネル
仮想メモリにマッピングしたらユーザ仮想空間には何をマッピングするのでしょうか。

実は、ページをカーネル仮想メモリにマッピングしてもそれが割り当てられるわけでは
**ありません**。このマッピングを作成したのはカーネルが仮想空間を使って物理
メモリを管理できるようにしただけです。

ではメモリ割り当てはどのようになっているでしょうか。思い出してください。
私たちのアロケータは`memory_map`から返されたメモリを管理しており、それは
物理アドレスを使用しています。

カーネルがメモリを割り当てる必要がある場合はこれまで通りアロケータを使い続ける
ことができます。アロケータが使う物理アドレス空間とカーネルの仮想空間は同じ
だからです。最初に構築したカーネルページテーブルのおかげです。

ユーザがメモリを割り当てる必要がある場合も私たちのアロケータを使うことに
なりますが、その場合は変換が正しく行われるようにそのコンテキストのユーザ
ページテーブルに適切なページテーブルエントリを挿入する必要があります。

この設計では、アロケータはカーネルが誤ってユーザに割り当てられたページを使用
することなく、カーネルとユーザそれぞれが要求したメモリを得ることを保証します。
MMUはユーバがカーネルページにアクセスできないことを保証します。カーネルページに
はカーネル権限フラグを立てているからです。そして、これまでカーネルで使ってた
物理アドレスを変更する必要はありません。カーネルの仮想アドレスは変わらないから
です。とてもクールですね。

#### 実装

これでレベル2から開始する64KB粒度の2つのレベルのページテーブルを実装する準備が
整いました。主に`kern/src/vm/pagetable.rs`、`kern/src/process.rs`、
`kern/src/vm.rs`で作業することになります。

次の手順で実装することを推奨します。

1. **`L2PageTable`, `L3Entry`, `L3PageTable`の各構造体を実装する**

    {usize, u64, i32, ...}などの型を`PhysicalAddr`と`VirtualAddr`に変換する
    便利なトレイトや、`PhysicalAddr`と`VirtualAddr`を{usize、u64、*mut u8、...}に
    変換する`as_usize()`, `as_u64()`, `as_mut_ptr()`などの関数を自由に追加して
    ください。

2. **`PageTable`構造体を実装する**

    `PageTable`では6つのメソッドを実装する必要があります。各メソッドの要件は
    スケルトンコード内のドキュメントコメントに明記されています。私たちは
    仮想メモリ空間を最大1GBメモリまでサポートしていることに注意してください。
    つまり、この空間をカバーするにはL3ページテーブルは2つで十分であり、L2ページ
    テーブルのエントリは2つしか必要ありません。ページテーブルエントリを作成する
    際には適切なビットをセットすることを忘れないでください。

3. **`PageTable`用の`IntoIterator`を実装する**

    返されるイテレータは1番目のL3ページテーブルの最初のエントリからイテレートし、
    2番目のL3ページテーブルに移動する必要があります。

        ヒント:` chain()`メソッドが役に立ちます。

4. **`KernPageTable::new()`メソッドを実装する**

    `KernPageTable`は内部に`PageTable`のスマートポインタを持つ構造体です。
    まず、カーネルページテーブル用の適切な権限を持つ`PageTable`を作成して
    ください。

    次に、`0x0000_0000`から始まるSDRAMに存在するすべてのメモリ空間をロード
    してください。lab3で実装した`allocator::memory_map()`関数を呼び出すことで
    終了アドレスを取得することができます。この空間は内部共有されるノーマル
    メモリであることに注意してください。L3エントリに適切な設定を行い、ページ
    テーブルにそれらのエントリーをセットしてください。

    次に、`IO_BASE`から`IO_BASE_END`までのI/Oメモリ範囲用のL3エントリをデバイス
    メモリとしてセットしてください。範囲変数は`pi/src/common.rs`で定義されて
    います。このエントリは属性がデバイスメモリとしてセットされることと外部共有
    可能であることを除いてノーマルメモリ空間用のエントリと同じ設定でなければ
    なりません。また、作成する各ページテーブルエントリに適切なビット値をセット
    することを忘れないでください。

    どちらの場合も64KBのページ粒度を使用していることに注意してください。

5. **`UserPageTable`構造体を実装する**

    ユーザページテーブルでは作成時にはページテーブルにページを設定する必要は
    ありません。

    `alloc()`関数が呼ばれた際に64KBのページを割り当て、適切な設定のL3エントリを
    作成し、割り当てたページの物理アドレスをL3エントリの`ADDR`フィールドに
    セットし、ページテーブルにそのエントリをセットします。仮想アドレスでページ
    テーブルを検索する際にはユーザプロセスの仮想アドレスは`USER_IMG_BASE`
    (`0xffff_ff_c000_0000`) から始まることに注意してください。ページテーブルを
    検索してエントリを設定する際には仮想アドレスからこのベースアドレスを引く
    必要があります。作成する各ページテーブルエントリに適切なビット値を設定する
    ことを忘れないでください。

6. **`UserPageTable`用の`Drop`トレイトを実装する**

    `Drop`トレイトを実装するには内部のページテーブルをイテレートして存在する
    各エントリを`dealloc()`します。

7. **プロセス構造体に`UserPageTable`を持たせる**

    これは`process.rs`にある`Process`構造体の`pub vmap.Box<UserPageTable>`病をを
    アンコメントするだけで簡単に実現することができます。`Process::new()`
    メソッドを修正して`vmap`を保持する`Process`構造体を返すようにします。

8. **最後に`kern/src/vm.rs`にある`VMManager`を実装する**

    仮想メモリマネージャはカーネルページテーブルのスレッドセーフなラッパーです。
    最初に使用する前に`initialize()`を呼び出して初期化する必要があります。これは
    内部で`setup()`メソッドを呼び出します。仮想マシンマネージャの設定には
    いくつかの関連レジスタに適切な値をセットすることが含まれます。

    `setup()`メソッドで使用されるレジスタは次のとおりです。

      - `ID_AA64MMFR0_EL1`: AArch64メモリモデル機能レジスタ 0 (ref: D7.2.43)

          `Tgran64`フィールドは現在のシステムが64KBのメモリ変換粒度をサポート
          しているか否かをチェックするために使用されます。サポートされていない
          場合、`startup()`がパニックになります。`PARange`フィールドは物理
          アドレスのサポート範囲をチェックするために使用されます。

      - `MAIR_EL1`: メモリ属性間接レジスタ(EL1) (ref: D7.2.70)

          指定可能なAttrIndxに対応するメモリ属性エンコーディングを提供します。

      - `TCR_EL1`: 変換制御レジスタ (ref: D7.2.91)

          EL1とEL0におけるその他のメモリ管理機能を制御します (guide: 12.2)

      - `TTBR0_EL1`と`TTBR1_EL1`

          変換テーブルのベースアドレスを指定します。

      - `SCTLR_EL1`: システム制御レジスタ (ref: D7.2.88)

          メモリシステムなどのシステムのトップレベルの制御を行います。

    未実装のメソッドのコードを作成して`VMManager`の実装を完成させてください。

**ヒント**
> 潜在的なタイプミスや間違いを防ぐために生のビットやビット操作を使用しないで
> `aarch64`ライブラリのラッパー関数と変数を使用してください。

**ヒント**
> `aarch64`ライブラリにはレジスタ用のインタフェースもあります。

**質問 (Daref): `Deref`トレイトと`DerefMut`トレイトはなぜ必要か**
> `pagetable.rs`には`KernPageTable`と`UserPageTable`用の`Deref`トレイトと
> `DerefMut`トレイトがあります。これらのトレイトの役割は何ですか、また、
> なぜ必要ですか。

**注記: ページアクセス権のパーミッションはサポートしていません**
> `UserPageTable::alloc`の実装にはメモリページのアクセス権のパーミッション
> （RWページやRWXなど）用のフィールド`_perm`がありますが、実際には使用
> しません。将来この機能をサポートするためのスタブとして存在しているだけです。
> ただし、カーネルページとユーザ空間ページを分離するMMUのページ権限は
> サポートしていることに注意してください。これはページテーブルエントリの
> `AP`に適切な値を設定することで行います。

#### 仮想メモリのテスト

まず、`kern/src/main.rs`にコードを1行追加します。スケジューラの初期化を呼び出す
前に`VMM`の`initialize()`メソッドを呼び出してください。これによりあなたの
`kmain()は以下のような6行になります。

```rust
unsafe fn kmain() -> ! {
    ALLOCATOR.initialize();
    FILESYSTEM.initialize();
    IRQ.initialize();
    VMM.initialize();
    SCHEDULER.initialize();
    SCHEDULER.start();
}
```

これでカーネルは仮想メモリを有効にしたので、プロセスがユーザページテーブルを
持つはずです。次のフェーズではいくつかのユーザプログラムを実装してそれらを
プロセスとしてロードする予定です。次のフェーズに移る前にユーザぽロセスが
ユーザページテーブルを使って実行できるか否かを簡単にテストしてみましょう。

`kern/src/process/scheduler.rs`の`initialize()`関数で物理アドレスではなく
仮想アドレスを使って開始することができます。

仮想空間にはまだプロセスが存在しないので`test_phase_3`というテスト関数を
用意しました。この関数は、プロセスが与えられると、そのプロセスの仮想空間の
アドレス`USER_IMG_BASE`に新しいページを割り当て、関数`test_user_process`を
そのページにコピーします。したがって、`elr`に`USER_IMG_BASE`を設定すると
`test_user_process`が実行されるはずです。

各プロセス用に`ttbr0`と`ttbr1`を適切にセットしてください。`ttbr0`には
カーネルページテーブルのベースアドレスを、`ttbr1`にはユーザページテーブルの
ベースアドレスをそれぞれ設定する必要があります。次に、各プロセスで
`test_phase_3()`関数を呼び出して、`USER_IMG_BASE`で実行できるようにし、
`elr`に`USER_IMG_BASE`をセットしてください。`test_user_process`はsleep
システムコールを呼び出すシンプルな関数です。最後にそのプロセスをスケジューラの
キューに追加してください。

すべてがうまくいけば、各プロセスはスケジューリングされた直後に`Waiting`状態に
なり10秒間スリープすることを確認できます。タイマー割り込みとスケジューリング
キューを表示して確認するとよいでしょう。

## フェーズ 4: ディスクのプログラム

このフェーズではファイルシステムイメージからプログラムバイナリをロードして
プロセスを作成するために`Process`構造体の実装をさらに変更します。

### サブフェーズ A: プログラムのロード

前のフェーズでは`extern`関数を使ってユーザレベルのプロセスを生成し、トラップ
フレームの`ELR`レジスタにその`extern`関数のアドレスを渡すことでプロセスを
起動しました。しかし、すべてのユーザプログラムをカーネルコードに実装するのは
現実的ではないし安全でもありません。その代わりにカーネルの外部でユーザが
書き、コンパイルしてディスクにバイナリとして格納されているプログラムをロード
する機能を実装します。

このサブフェーズでは`kern/src/process/process.rs`で作業します。

ディスクにあるプログラムのバイナリを`Process`構造体に変換するには次の手順が
必要です。

1. バイナリファイルを開き、プロセスオブジェクトを作成する。
2. ユーザープロセスの _スタック_ 用にプロセスのユーザページテーブル内に
  64KBのページを割り当てる。このページにはRead/Write権限をもたせる。
3. プロセスのユーザページテーブル内に`USER_IMG_BASE`から始まる仮想アドレスを
  持つ64KBのページを割り当てる。このページにはRead/Write/Excecute権限を
  もたせる。バイナリファイルの読み込み割り当てられたページに格納する。
  バイナリファイル全体の読み込みが終わるまで追加のページを割り当て続ける。
4. プロセスのトラップフレームに適切な値を設定する。

#### 実装

まず、ヘルパー関数を完成させてください。`kern/src/process/process.rs`には
`VirtualAddr`を返す関数が4つあります。関連する定数変数は`kern/src/param.rs`に
定義されています。

  - `get_max_va()`: ユーザプロセスの最高位仮想アドレスを返します。
  - `get_image_base()`: ユーザ仮想メモリ空間のベースアドレスを返します。
  - `get_stack_base()`: ユーザプロセスのスタックの仮想空間のベースアドレスを
    返します。スタックは上位のメモリアドレスから下位のメモリアドレスへ向かって
    成長するので、スタックのベースとしてふさわしいアドレスはユーザの仮想
    空間の最後のページです。アドレスは`PAGE_SIZE`でアライメントされる必要が
    あることに注意してください。
  - `get_stack_top()`: ユーザプロセスのスタックの先頭を返します。これは
    プロセスが実行されるとスタックポインタに設定されます。これは可能な限り
    最大のスタックポインタである必要があります。ARMではスタックポインタは
    16バイトアラインであることを思い出してくだい。

次に、`load()`メソッドと`do_load()`メソッドを完成させてください。

`do_load()`メソッドはパラメータとしてファイルへのパスを取得し、ラップされた
`Process`構造体を返します。`do_load`は新しいプロセス構造体を作成し、プロセス
仮想空間にスタックを割り当て、指定されたパスのファイルを開き、その内容を
アドレス`USER_IMG_BASE`から始まるプロセス仮想空間に読み込む必要があります。

`load()`メソッドは内部で`do_load()`メソッドを呼び出します。次に、プロセスを
そのユーザページテーブルで実行するために適切な仮想アドレスをプロセスの
トラップフレームに設定します。最後に、実行可能なプロセスオブジェクトを返します。

#### ユーザプログラムのコンパイル

これで私たちのOSはそのファイルシステムでユーザプログラムをロードして実行できる
ようになったのでさっそく実行してみましょう。しかし、その前に私たちのOSの
ニーズに合わせてユーザプログラムをコンパイルする必要があります。

Linuxなどの商用OSでは通常、実行可能ファイルは`elf`などの実行可能ファイル形式に
コンパイルされます。ユーザプログラムをメモリにロードして実行させるプロセスは
通常、私たちのOSで行うものより複雑です。Linuxカーネルでそれがどのように実行
されるのかについては["How programs get run: ELF binaries"](https://lwn.net/Articles/631631/)
を読んでください。

私たちのOSにはelfインタプリタはありません。なのでプログラムをコンパイルして、
`USER_IMG_BASE`アドレスにロードされるプレーンバイナリファイルにする必要が
あります。

`user`ディレクトリにコンパイル可能な2つのユーザプログラムを用意しました。
ただし、`fib`はまだ実装していない`write`システムコールを必要としています。
そのため、この例では先に見た`test_user_process`関数と同じ動作をする`sleep`を
ベースに説明します。

`sleep`をコンパイルするには`user/sleep`で`make`を実行します。すると
`user/sleep/build`に`sleep.bin`と`sleep.elf`という2つのファイルが生成されます。

`sleep.elf`はsleepプログラムの`elf`バージョンです。私たちのOSは`elf`インタ
プリタを持っていないのでこれを使うことはできません。代わりに`sleep.bin`を
使います。これは文字通り実行可能な単なるバイトストリームです。

`sleep`をコンパイルしたら`sleep.bin`をSDカードにコピーし、テスト段階に進んで
ください。

#### 実装のテスト

`user`ディレクトリに2つのユーザプログラム`fib`と`sleep`を用意しました。
名前が示しているように`sleep`は`sleep`システムコールを呼び出すプログラムです。
そのコードは先の`test_user_process()`関数と全く同じです。`fib`の動作も非常に
単純です。再帰的な`fib()`関数を使って40番目のフィボナッチ数を計算するだけです。
ソースコードは`user/fib/src/main.rs`にあります。

次に`kern/src/process/scheduler.rs`を再度見てください。もはやレジスタを直接
設定したり、外部関数から作成したプロセスを追加したりする必要はありません。
`Process::load`関数を使ってディスクから複数のプログラムをロードすることが
できるからです。`initialize()`メソッドで`sleep`プログラムを4回ロードして
スケジューリングキューに追加してください。

最後に`GlobalScheduler::start()`関数のインラインアセンブリを変更します。
`_start`関数のアドレスの代わりに次のページのアドレスを計算して`sp`レジスタに
格納してください。こうすることでカーネルレベルに戻った際にスタック用の
クリーンなページを持つことができます。`eret`を呼び出す前にカーネルから
情報やアドレスが漏れる可能性のあるレジスタをクリーンにするのを忘れないで
ください。

起動後、4つの`sleep`プログラムが開始したら次のサブフェーズに進むことができます。
`write`システムコールが実装されていないので`fib`プログラムはまだテストできない
ことに注意してください。次のサブフェイズで`write`と更に複数のシステムコールを
実装する予定です。

`qemu`を使用し、ユーザプログラムを含むファイルシステムイメージが必要な場合は
`user/build.sh`スクリプトを使用することができます。このスクリプトは`sleep`と
`fib`プログラムのコンパイル済みバイナリを含む`fs.img`を生成します。
