# Lab 4: プリエンプティブマルチタスク

- [フェーズ 0: 始めよう](#フェーズ-0-始めよう)
- [フェーズ 1: ARMとLeg](#フェーズ-1-armとleg)
  - [サブフェーズ A: ARMv8概要](#サブフェーズ-a-armv8概要)
  - [サブフェーズ B: 命令](#サブフェーズ-b-命令)

## はじめに

この課題ではプロセスとその関連するインフラストラクチャを実装することで
ユーザレベルのアプリケーションを実現します。特権レベルの切り替えコード、
コンテキストスイッチコード、単純なラウンドロビンスケジューラ、システム
コールハンドラ、仮想メモリサブシステムを作成します。また、いくつかの
ユーザプログラムを書き、それらをロードして新しいプロセスを開始します。

## フェーズ 0: 始めよう

ラボ4用のアップデートをgitリポジトリから開発マシンに取得します。

```bash
$ git fetch skeleton
$ git merge skeleton/lab4
```

リポジトリのディレクトリ構造は次のようになります。この課題で作業する
ディレクトリには`*`がついています。

```bash
.
├── bin : common binaries/utilities
├── doc : reference documents
├── ext : external files (e.g., resources for testing)
├── tut : tutorial/practices
│    ├── 0-rustlings
│    ├── 1-blinky
│    ├── 2-shell
│    ├── 3-fs
│    └── 4-spawn : questions for lab4 *
├── boot : bootloader
├── kern : the main os kernel *
├── lib  : required libraries
│     ├── aarch *
│     ├── kernel_api *
│     ├── fat32
│     ├── pi
│     ├── shim
│     ├── stack-vec
│     ├── ttywrite
│     ├── volatile
│     └── xmodem
└── user  : user level program *
      ├── fib *
      └── sleep *
```

作業を進める前にコンフリクトを解決する必要があるかもしれません。
たとえば、次のようなメッセージが表示された場合です。

```bash
Auto-merging kern/src/main.rs
CONFLICT (content): Merge conflict in kern/src/main.rs
Automatic merge failed; fix conflicts and then commit the result.
```

コンフリクトを解決するには`main.rs`を手動で修正する必要があります。
ラボ 3で変更した内容がすべて保持されていることを確認してください。
すべてのコンフリクトが解決したら解決したファイルを`git add`して
コミットしてください。マージコンフリクトの解決方法については
githowto.com のチュートリアルを参照してください。

### ARMドキュメント

この課題では次の3つのARM公式文書を参照します。

- [ARMv8リファレンスマニュアル](../arm_docs/ARMv8-Reference-Manual.pdf)

  ARMv8アーキテクチャの公式リファレンス マニュアルです。これは一般的な
  方法でアーキテクチャ全体をカバーする包括的なマニュアルです。Raspberry
  Pi 3向けのアーキテクチャの具体的な実装についてはARM Cortex-A53
  マニュアルを参照してください。このマニュアルのセクションを参照する
  場合は([ref:](../arm_docs/ARMv8-Reference-Manual.pdf) C5.2) という形で示します。これは[ARMv8リファレンスマニュアル](../arm_docs/ARMv8-Reference-Manual.pdf)の
  セクション C5.2を参照する必要があることを示します。

- [ARM Cortex-A53マニュアル](../arm_docs/ARM-Cortex-A53-Manual.pdf)

  Raspberry Pi 3で使用されているARMv8 (v8.0-A)アーキテクチャの具体的な
  実装に関するマニュアルです。このマニュアルのセクションを参照する
  場合は([A53](../arm_docs/ARM-Cortex-A53-Manual.pdf): 4.3.30)という形で示します。これは[ARMv8リファレンスマニュアル](../arm_docs/ARM-Cortex-A53-Manual.pdf)の
  セクション 4.3.30を参照する必要があることを示します。

- [ARMv8-Aプログラマガイド](../arm_docs/ARMv8-A-Programmer-Guide.pdf)

  ARMv8-Aプロセスのプログラミング方法に関する高水準手引きドです。
  このマニュアルのセクションを参照する
  場合は([guide](../arm_docs/ARMv8-A-Programmer-Guide.pdf): 10.1)という形で示します。これは[ARMv8-Aプログラマガイド](../arm_docs/ARMv8-A-Programmer-Guide.pdf)の
  セクション 10.1を参照する必要があることを示します。

これら3つのドキュメントはすべて`doc/src/arm_docs`サブディレクトリに
あります。今すぐこれら3つのドキュメントをダウンロードしてすぐ手の届く
ところに置いておくことを勧めます。

## フェーズ 1: ARMとLeg

このフェーズではARMv8アーキテクチャについて学び、下位特権レベルへの
切り替え、例外ベクタのインストールし、タイマー割り込みの有効化、
デバッグシェルの起動によるブレークポイント例外の処理を行います。ARM
アーキテクチャの例外レベルについて学習し、アーキテクチャが例外、割り込み、
特権レベルをどのように扱うかを学びます。

### サブフェーズ A: ARMv8概要

このサブフェーズではARMv8アーキテクチャについて学習します。コードを書く
ことはありませんが、アーキテクチャに関するいくつかの質問に答えることに
なります。

ARM (Acorn RISC Machine) CPUアーキテクチャは30年以上の歴史があります。
主要なリビジョンが8つあり、最新のリビジョンが2011年に導入されたARMv8-A
です。Broadcom BCM2837 SOCにはARMv8.0-AベースのCPUであるARM Cortex-A53が
搭載されています。Cortex-A53（やその他の特定のCPU）はこのアーキテクチャの
実装と呼ばれます。これはこれまで3回の課題でプログラミングしてきたた
CPUです。

**注記: モバイル市場を支配するARM CPU**
> ARM CPUはモバイル市場を支配しており、世界中で販売されているスマート
> フォンの95％以上、アップルのiPhoneやグーグルのPixelを含むフラッグシップ
> スマートフォンのほぼ100％に搭載されています。

これまでは基礎となるアーキテクチャーの詳細については不問とし、Rust
コンパイラーに任せてきました。しかし、ユーザ空間でプロセスを実行できる
ようにするには最下位レベルでCPUを直接プログラミングする必要があります。
CPUを直接プログラミングするにはCPUネイティブのアセンブリ言語と全体的な
概念に精通する必要があります。まず、アーキテクチャの概要から説明し、
次に、いくつかの主要なアセンブリ命令について説明します。

#### レジスタ

ARMv8アーキテクチャには以下のレジスタがあります (ref: B1.2.1)。

- `r0`...`r30` - 64ビットの汎用レジスタ

  これらのレジスタはエイリアスによりアクセスされます。レジスタ
  `x0`...`x30`はこれらのレジスタの64ビット全体のエイリアスです。レジスタ
  `w0`...`w30`はこれらのレジスタの最下位32ビットのエイリアスです。

- `lr` - 64ビットのリンクレジスタ: `x30`のエイリアス

  _リンクアドレス_ の格納に使用されます。`bl <addr>`命令は次の命令の
  アドレスを`lr`に格納し、`addr`に分岐します。`ret`命令は`lr`の
  アドレスをPCにセットします。

- `sp` - スタックポインタとして使用

  スタックポインタの下位32ビットは`wsp`でアクセスできます。スタック
  ポインタは常に16バイトアラインされていなければなりません。

- `pc` - プログラムカウンタ

  このレジスタは読み込みはできますが、書き込むことはできません。`pc`は
  分岐命令と例外のエントリ/リターンで更新されます。

- `v0`...`v31` - 128ビットのSIMD/FPポイントレジスタ

  これらのレジスタはベクトル化SIMD命令と浮動小数点演算に使用されます。
  これらのレジスタはエイリアスによりアクセスされます。レジスタ
  `q0`...`q31`はこれらのレジスタの128ビットすべてのエイリアスです。
  レジスタ`d0`...`d31`はこれらのレジスタの下位64ビットのエイリアスです。
  また、これらのレジスタのそれぞれ、下位32ビット、16ビット、8ビットを示す
  `s`、`h`、`b`を前置詞とするエイリアスがあります。

- `xzr` - read-onlyのゼロレジスタ

  この擬似レジスタは（ハードウェアレジスタである場合とそうでない場合が
  ありますが）常に値`0`を保持します。

また、_多くの特殊_ レジスタもあります。これらのレジスタについては
次のセクションのように、必要に応じて説明します。

#### PSTATE

ARMv8 CPUはすべての時点で _プログラムの状態_ をPSTATEという疑似レジスタに
取り込みます (ref: D1.7)。PSTATEは実際のレジスタではなく、直接読み書きする
方法はありません。代わりに、PSTATE擬似レジスタの様々なフィールドを読み書き
するために使用できる特殊レジスタがあります。ARMv8.0では以下が該当します。

- `NZCV` - 条件フラグ
- `DAIF` - 例外マスクビット。例外が発行されないようにするために使用
- `CurrentEL` - 現在の例外レベル（後で説明）
- `SPSel` - スタックポインタセレクタ

これらのレジスタは _システムレジスタ_ または _特殊レジスタ_ として
知られるレジスタクラスに属します (ref: C5.2)。通常、レジスタは`ldr`
命令を使ってメモリからロードし、`str`命令を使ってメモリにストア
することができます。システムレジスタはこれらの命令では読み書きできません。
代わりに、特殊目的命令の`mrs`と`msr`を使用する必要があります
(ref: C6.2.162～C6.2.164)。たとえば、`NZCV`を`x1`に読み込むには
次の命令を実行します。

```
mrs x1, NZCV
```

#### 実行状態

ARMv8 CPUはすべての時点で所定の _実行状態_ で実行されています。このような
実行状態は2つあります。32ビットのARMv7互換モードに対応するAArch32と
64ビットのARMv8モードのAArch64です (guide: 3.1)。私たちは常にAArch64で
実行します。

#### セキュアモード

ARMv8 CPUはすべての時点で所定の _セキュリティ状態_ （ほかでは
_セキュリティモード_ または _セキュリティワールド_ と呼ばれています）で
実行されています。セキュリティ状態には _セキュア_ と _ノーマル_
としても知られている _非セキュア_ （non-secure）の2つの状態が
あります。私たちは常に非セキュア（ノーマル）モードで実行します。

#### 例外レベル

ARMv8 CPUはすべての時点で所定の _例外レベル_ (guide: 3) で実行されて
います。各例外レベルは _特権レベル_ に対応しており、例外レベルが高いほど
そのレベルで実行されているプログラムの特権が大きくなります。例外レベル
には次の4つがあります。

- `EL0`（ユーザ） - 通常、信頼されないユーザアプリケーションの実行に
  使用されます
- `EL1`（カーネル） - 通常、特権を持つOSカーネルを実行するために使用されます
- `EL2`（ハイパーバイザ） - 通常、仮想マシンハイパーバイザの実行に使用されます
- `EL3`（モニタ） - 通常、低レベルファームウェアの実行に使用されます

Raspberry PiのCPUはEL3で起動します。その時点ではRaspberry Pi財団が
提供するファームウェアが実行され、ファームウェアはCPUをEL2に切り替え、
`kernel8.img`ファイルを実行します。したがって、私たちのカーネルはEL2で
実行を開始します。その後、私たちのカーネルが適切な例外レベルで実行される
ようにEL2からEL1に切り替えることになります。

#### #Lxレジスタ

`ELR`、`SPSR`、`SP`など、いくつかのシステムレジスタは例外レベルごとに
重複して存在してます。例外レベル`n`用のレジスタを示すためにレジスタ名の
末尾には`_ELn`が付いています。たとえば、`ELR_EL1`は_EL1用の例外リンクレジスタ_ で
あり、`ELR_EL2`はEL2用の例外リンクレジスタです。

_ターゲット_ 例外レベル`x`のレジスタに言及する場合は`ELR_ELx`のように
接尾辞に`x`を使用します。ターゲット例外レベルとは例外ベクタを実行する
ためにCPUが必要に応じて切り替える例外レベルのことです。_ソース_ 例外
レベル`x`のレジスタに言及する場合は`SP_ELs`のように接尾辞に`s`を使用
します。ソース例外レベルとは例外が発生したときにCPUが実行していた例外
レベルのことです。

#### 例外レベルの切り替え

例外レベルを増加させるメカニズムは1つしか存在しません。また、例外レベルを
減少させるメカニズムも1つしか存在しません。

高いレベルから低いレベルに切り替える（特権を減らす）には実行中の
プログラムが`eret`命令 (ref: D1.11) を使用して例外レベルから _return_
しなければなりません。現在の例外レベルが`ELx`のときに`eret`命令を実行
すると、CPU は次のようになります。

- 特殊システムレジスタ`ELR_ELx`の値をPCにセットする
- 特殊システムレジスタ`SPSR_ELx`の値をPSTATEにセットする

`SPSR_ELx`レジスタ (ref: C5.2.18) にはリターンすべき例外レベルも格納
されています。例外レベルの変更には次のような影響もあることに注意して
ください。

- `Els`にリターンする際、`sp`には`SPSR_ELx[0] == 1`の場合は`SP_ELs`が、
  `SPSR_ELx[0] == 0`の場合は`SP_EL0`がセットされます。

下位レベルから上位レベルへの切り替えは例外の結果としてしか発生しません
(guide: 10)。特に設定しない限り、CPUは例外を次の例外レベルでトラップ
します。たとえば、`EL0`で動作中に割り込みを受けた場合、CPUは`EL1`に
切り替えて例外を処理します。`ELx`への切り替えが発生するとCPUは次のように
なります。

- `PSTATE.DAIF=0b1111`とセットすることですべての例外と割り込みを
  マスクします
- `PSTATE`などのフィールドを`SPSR_ELx`に保存します
- _優先例外リンクアドレス_ を`ELR_ELx`に保存します (ref: D1.10.1)
- `SPSel`が`1`に設定されていた場合は`sp`に`SP_ELx`をセットします
- _例外シンドローム_ （後述）を`ESR_ELx`に保存します (ref: D1.10.4)
- 例外ベクタ(後述)に対応するアドレスを`PC`にセットします（後述）

例外シンドロームレジスタが有効なのは例外が _同期_ （後述）であった
場合だけであることに注意してください。すべての汎用レジスタとSIMD/FP
レジスタは例外が発生したときの値を維持します。

#### 例外ベクタ

例外が発生するとCPUはその例外に対応する _例外ベクタ_ にジャンプします
(ref: D1.10.2)。例外には4つのタイプがあり、それぞれ4つの例外発生源が
考えられるため合計16個の例外ベクタが存在します。例外の4タイプは次の
とおりです。

- **同期** - `svc`や`brk`などの命令により発生する例外
- **IRQ** - 外部ソースからの非同期割り込み要求
- **FIQ** - 外部ソースからの非同期高速割り込み要求
- **SError** - 「システムエラー」割り込み

4つの発生源は次のとおりです。

- ソースが`SP = SP_EL0`で同じ例外レベル
- ソースが`SP = SP_ELxPで同じ例外レベル
- AArch64で実行中の下位の例外レベル
- AArch32で実行中の下位の例外レベル

プログラムガイド (guide: 10.4) では次のように記述されています。

例外が発生するとプロセッサは例外に対応するハンドラコードを実行
しなければなりません。[例外]ハンドラが格納されるメモリ上の場所は
_例外ベクタ_ と呼ばれています。ARMアーキテクチャでは例外ベクタは
_例外ベクタテーブル_ と呼ばれるテーブルに格納されます。各例外レベルは
独自のベクタテーブルを持っています。つまり、EL3、EL2、EL1のそれぞれに
1つずつテーブルがあります。このテーブルには[x86がそうであるような]
アドレスの集合ではなく、実行されるべき命令が格納されています。ベクタ
テーブルの各エントリは16命令長です。個々の例外用のベクタはテーブルの
先頭から固定オフセットに配置されます。各テーブルのベースとなる仮想
アドレスはベクタベースアドレス[特殊]レジスタの`VBAR_EL3`, `VBAR_EL2`,
`VBAR_EL1`によりセットされます。

ベクターは物理的に次のように配置されます。

- ソースが`SP = SP_EL0`でターゲットとソースが同一の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x000 | 同期例外 |
| 0x080 | IRQ |
| 0x100 | FIQ |
| 0x180 | SError |

- ソースが`SP = SP_ELx`でターゲットとソースが同一の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x200 | 同期例外 |
| 0x280 | IRQ |
| 0x300 | FIQ |
| 0x380 | SError |

- AArch64で実行中でソースが下位の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x400 | 同期例外 |
| 0x480 | IRQ |
| 0x500 | FIQ |
| 0x580 | SError |

- AArch32で実行中でソースが下位の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x600 | 同期例外 |
| 0x680 | IRQ |
| 0x700 | FIQ |
| 0x780 | SError |

ベクタテーブルは連続しています。

#### Rustとのインタフェース

システムに関する低レベルの詳細にアクセスするためのRustyインタフェースを
提供するために`aarch64`ライブラリ (`lib/aarch64`) を用意しました。
次のサブフェーズに移る前に`regs.rs`で定義されているレジスタとあなたの
理解を比較してください。ライブラリ内の他のファイルについては次のサブ
フェーズの最後に再検討します。

#### まとめ

とりあえず、ARMv8アーキテクチャについて知っておくべきことは以上です。
次に進む前に以下の質問に答えてください。

**質問 (arm-x30): x30はどのレジスタのエイリアスか**
> `x30`に`0xFFFF`という値が書き込まれた場合、その値を取り出すために
> 使用できる他の2つのレジスタ名は何ですか.

**質問 (arm-pc): 特定のアドレスをPCにセットする方法は**
> `ret`命令を使ってどのようにアドレス`A`をPCにセットしますか。
> `eret`命令を使ってどのようにアドレス`A`をPCにセットしますか。
> どのレジスタにどの値をセットするか、具体的に答えてください。

**質問 (arm-el): どのようにして現在の例外レベルを知るか**
> 現在の例外レベルを知るために具体的にどの命令を実行しますか。

**質問 (arm-sp-el): どのようにして例外からの復帰時にスタックポインタを変更するか**
> 例外が発生した際に実行中のプログラムのスタックポインタは`A`です。
> 例外を処理した後、プログラムが実行されていた場所に戻りたいが
> スタックポインタは`B`に変更したい。どのようにしますか。

**質問 (arm-svc): 下位ELからのシステムコールに使用されるベクタはどれか**
> `svc`命令を発行した時プロセスは`EL0`で実行中でした。CPUは具体的に
> どのアドレスにジャンプしますか。

**質問 (arm-int): 下位のELからの割り込みに使用されるベクタはどれか**
> タイマー割り込みが発生した時プロセスは`EL0`で実行中でした。
> CPUは具体的にどのアドレスにジャンプしますか。

**質問 (arm-mask): IRQ例外のマスクを解除するには**
> IRQ割り込みのマスクだけを解除するにはどのレジスタにどんな値を
> 書き込みますか。

**質問 (arm-aarh32): どのようにしてAArch32実行状態に`eret`するか**
> ソースがAArch64で実行中に例外が発生しました。ターゲットもAArch64で
> 実行中です。`eret`によって例外から復帰する際にCPUをAArch32実行状態に
> 切り替えるにはどのレジスタのどの値を変更しますか。

       ヒント
       (guide: 10.1)を参照してください。

### サブフェーズ B: 命令

このサブフェーズではARMv8命令セットについて学習します。コードを書く
ことはありませんが、命令セットに関するいくつかの質問に答えることに
なります。

#### メモリへのアクセス

ARMv8はロード/ストアRISC (Reduced Instruction Set Computer) 命令
セットです。このような命令セットの決定的な特徴はメモリのアクセスが
特定の命令でしかできないことです。つまり、メモリの読み込みはロード
命令でレジスタに読み込むことしかできず、メモリへの書き込みはストア
命令でレジスタからメモリに書き込むことしかできません。

ロード命令とストア命令には多くの種類があり、特定の命令にはバリエーションも
あります。最も単純なものから説明します。

- `ldr <ra>, [<rb>]` : <rb>のアドレスの値を<ra>にロードする
- `str <ra>, [<rb>]` : <ra>の値を<rb>のアドレスにストアする

レジスタ `<rb>` は _基底アドレス_ と呼ばれます。`r3 = 0x1234` の場合、

```
ldr r0, [r3]    // r0 = *r3 (すなわち、r = *(0x1234))
str r0, [r3]    // *r3 = r0 （すなわち、*(0x1234) = r0
```

`[-256, 255]`の範囲のオフセットを指定することもできます。

```
ldr r0, [r3, #64]     // r0 = *(r3 + 64)
str r0, [r3, #-12]    // *(r3 - 12) = r0
```

ポストインデックスを指定することもできます。これはロードまたはストアの
_後に_ 基底アドレスの値を変更します。

```
ldr r0, [r3], #30     // r0 = *r3; r3 += 30
str r0, [r3], #-12    // *r3 = r0; r3 -= 12
```

プリインデックスを指定することもできます。これはロードまたはストアの
_前に_ 基底アドレスの値を変更します。

```
ldr r0, [r3, #30]!    // r3 += 30; r0 = *r3
str r0, [r3, #012]!   // r3 -= 12; *r3 = r0
```

オフセット、ポストインデックス、プリインデックスは _アドレッシングモード_
と呼ばれます。

最後に、`ldp`命令と`stp`命令 (load pair, store pair) を使うと一度に2つの
レジスタからロードとストアができます。これらの命令には`ldr`と`str`と同じ
アドレッシングモードを使用することができます。

```
// `x0` と `x1` をスタックに積む。 操作後のスタックは次のようになる
//
//   |------| <- SP
//   |  x0  |
//   |------|
//   |  x1  |
//   |------| <x (original SP)
//
stp x0, x1, [SP, #-16]!

// pop `x0` と `x1` をスタックから下ろす。操作後のスタックは次のようになる
//
//   |------| <x (original SP)
//   |  x0  |
//   |------|
//   |  x1  |
//   |------| <- SP
//
ldp x0, x1, [SP], #16

// 次の4つの操作は上の2つの操作と同じことをする
sub SP, SP, #16
stp x0, x1, [SP]
ldp x0, x1, [SP]
add SP, SP, #16

// 上と同じだが、x0, x1, x2, x3の保存と復元をする
sub SP, SP, #32
stp x0, x1, [SP]
stp x2, x3, [SP, #16]

ldp x0, x1, [SP]
ldp x2, x3, [SP, #16]
add SP, SP, #32
```

#### 即値のロード

_即値_ とは計算なしで値がわかる整数の別名です。16ビットの即値を、任意に
16ビットの倍数だけ左にシフトして、レジスタにロードするには`mov` (move)
を使用します。16ビットの即値を、他のビットは置き換えることなく数ビット
左にシフトして、ロードするには`movk`（move/keep）命令を使用します。
使用例は次の通り。

```
mov   x0, #0xABCD, LSL #32    // x0 = 0xABCD00000000
mov   x0, #0x1234, LSL #16    // x0 = 0x12340000

mov   x1, #0xBEEF             // x1 = 0xBEEF
movk  x1, #0xDEAD, LSL #16    // x1 = 0xDEADBEEF
movk  x1, #0xF00D, LSL #32    // x1 = 0xF00DDEDBEEF
movk  x1, #0xFEED, LSL #48    // x1 = 0xFEEDF00DDEADBEEF
```

即値の前には`#`が付くこと、ディスティネーションレジスタは左に置くこと、
`LSL`は左シフトを指定することに注意してください。

レジスタにロードできるのは任意のシフトを伴う16ビット即値だけです。
多くの場合、アセンブラは正しいシフト値を見つけ出すことができます。
たとえば、アセンブラは`mov x12, #(1 << 21)`を`mov x12, 0x20, LSL #16`に
自動的に変換することができます。

#### ラベルからのアドレスのロード

アセンブリコードのセクションは`<label>;`を使って _ラベル付け_ する
ことができます。

```
add_30:
    add x1, x1, #10
    add x1, x1, #20
```

ラベル後の最初の命令のアドレスをロードするには`adr`命令か`ldr`命令を
使用することができます。

```
adr x0, add_30      // x0 = add_30の最初の命令のアドレス
ldr x0, =add_30     // x0 = add_30の最初の命令のアドレス
```

ラベルが命令と同じリンカセクションにない場合は`ldr`を使用する必要が
あります。ラベルが同じセクション内にある場合は`adr`を使用するべきです。

#### レジスタ間の移動

`mov`命令でレジスタ間の値の移動をすることもできます。

```
mov x13, #23    //          x13 = 23
mov sp, x13     // sp = 23, x13 = 23
```

#### 特殊レジスタからのロード

`ELR_EL1`などの特殊/システムレジスタは`mrs`命令と`msr`命令を使って
別のレジスタへのロード/ストアしかできません。

別のレジスタから特殊レジスタへ書き込むには`msr`命令を使用します。

```
msr ELR_EL1, x1     // ELR_EL1 = x1
```

特殊レジスタからへ別のレジスタに読み込むには`mrs`命令を使用します。

```
mrs x0, CurrentEL   // x0 = CurrentEL
```

#### 算術演算

`add`命令と`sub`命令を使って算術演算をすることができます。構文は次の通り。

```
add <dest> <a> <b>      // dest = a + b
sub <dest> <a> <b>      // dest = a - b
```

たとえば、

```
mov x2, #24
mov x3, #36
add x1, x2, x3    // x1 = 24 + 36 = 60
sub x4, x3, x2    // x4 = 36 - 24 = 12
```

パラメタ`<b>`には即値も使用できます。

```
sub sp sp, #120   // sp -= 120
add x3, x1, #120  // x3 = x1 + 120
add x3, x3, #88   // x3 += 88
```

#### 論理演算

`and`命令と`orr`命令はビット単位の`AND`と`OR`を行います。使用法は
`add`と`sub`と同じです。

```
mov x1, 0b11001
mov x2, 0b10101

and x3, x1, x2    // x3 = x1 & x2 = 0b10001
orr x3, x1, x2    // x3 = x1 | x2 = 0b11101
orr x1, x1, x2    // x1 |= x2
and x2, x2, x1    // x2 &= x1

and x1, x1, #0b110    // x1 &= 0b110
orr x1, x1, #0b101    // x1 |= 0b101
```

#### 分岐

_分岐_ はあるアドレスへのジャンプを指す用語です。_分岐_ はPCを指定された
アドレスまたはラベルアドレスに変更します。無条件にラベルにジャンプする
には`b`命令を使用します。

```
b label   // labelにジャンプ
```

次のアドレスをリンクレジスタに格納してラベルにジャンプするには`bl`命令を
使用します。`ret`命令は`lr`のアドレスにジャンプします。

```
my_function:
    add x0, x0, x1
    ret

mov x0, #4
mov x1, #30
bl  my_function     // lr = `mov x3, x0のアドレス
mov x3, x0          // x3 = x0 = 4 + 30 = 34
```

`br`命令と`blr`命令は各々`b`と`bl`と同じですがレジスタが持つ
アドレスにジャンプします。

```
ldr x0, =label
blr x0            // bl label と同じ
br  x0            // b  label と同じ
```

#### 条件分岐

`cmp`命令は2つのレジスタの値、または、レジスタの値と即値を比較して
`bne` (branch not equal), `beq` (branch if equal), `blt` (branch
if less than) などの条件分岐命令のためのフラグをセットします (ref:
C1.2.4)。

```
// x1と等しくなるまでx0に１を足し、等しくなったら`function_when_eq`を
// 呼び出し、ついでexitを実行する
not_equal:
    add x0, x0, #1
    cmp x0, x1
    bne not_equal
    bl  function_when_eq

exit:
    ...

// x0 == x1 のときに呼ばれる
function_when_eq:
    ret
```

即値を使用した例

```
cmp x1, #0
beq x1_is_eq_to_zero
```

分岐が選択されなかった場合は単に次の命令を実行することに注意してください。

#### Rustとのインタフェース

ここで再び`aarch64`サブディレクトリに移動して残りのファイルの確認を
始めてください。ライブラリの各ファイルの簡単な説明は以下のとおりです。

- `asm.rs` - 内部的に使用するインラインアセンブリを関数としてラップ
- `macros.rs` - このライブラリで使用するマクロを定義
- `regs.rs` - マクロを使ってレジスタを定義し、そのインタフェースを提供
- `sp.rs` - スタックポインタへのアクセス
- `vmsa.rs` - 仮想メモリのサポート（後述）
- `lib.rs` - 上記のモジュールをインクルード。`current_el()`などの便利な
  関数を持つ

たとえば、`sp.rs`の`get()`関数と`set()`関数を使うと任意の時点で現在の
スタックポインタを取得したり変更したりすることができます。同様に、
`lib.rs`の`current_el()`関数は _カレント例外レベル_ と呼ばれている
CPUが現在実行している例外レベルを返します。

#### まとめ

ARMv8命令セットにはまだまだ多くの命令があります。これらをベースにすれば
残りの命令のほとんどを簡単にピックアップできるはずです。命令は (ref: C3)
に記載されています。上で紹介した命令の簡潔なリファレンスについては、Griffin Dietz氏による[ISAチートシート](https://tc.gts3.org/cs3210/2020/spring/r/AArch64-ISA-Cheat-Sheet.pdf)を
参照してください。先に進む前に次の質問に答えてください：

**質問 (asm-memcpy): ARMv8アセンブリでmemcpyはどう書きますか**
> ソースアドレスが`x0`に、ディスティネーションアドレスが`x1`に、
> コピーするバイト数（これは非ゼロの8の倍数であることが保証されている）
> が`x2`に置かれているとすると、ARMv8アセンブリで`memcpy`をどのように
> 実装しますか。`ret`することも忘れないでください。

    ヒント
    わずか6、7行で実装できます。

```
memcpy:
    ldr  x3, [x0], #8
    str  x3, [x1], #8
    subs x2, #8
    bne  memcpy
exit:
    ret
```

**質問 (asm-movk): どのように`ELR_EL1`に`0xABCDE`を書くか**
> EL1で実行していると仮定するとARMv8アセンブリを使用してどのようにして
> `ELR_EL1`に即値`0xABCDE`を書きますか

    ヒント
    3命令が必要です。

```
mov   x0, 0xBCDE
movk  x0, 0xA, LSL #16
msr   ELR_EL1, x0
```

**質問 (asm-cbz): cbz命令は何をしますか**
> (ref: C6.2.36) の`cbz`命令のドキュメントを読んでください。
> この命令は何をしますか、どのように使いますか。

**質問 (init): init.rsは何をしていますか**
> ラボ3まで`kern/src/init/init.s`をカーネルで実行される最初のコードと
> して使っていました。ここからはその役目は`kern/src/init.rs`に置き
> 換わりました。特に、`_start`関数はRaspberry Piの起動時に`0x80000`
> 番地にあり、ファームウェアはシステムの初期化を終えるとすぐにこの
> アドレスにジャンプします。まもなくこのファイルを修正してEL1に切り替え、
> 例外ベクタをセットアップするすることになります。
>
> `kern/src/init.rs`のコードをすべて読んでください。ファイルの
> すべての関数について、そのコードが何をしているのかを説明して
> ください。たとえば、`_start`関数の説明は次のように言うことができます。
>
> 「`MPIDR_EL1`レジスタの[7:0]ビット (ref: D7.2.74) を読み込んで
> (`Aff0`)、現在コードを実行しているコア番号を取得する。番号が0の場合、
> KERN_STACK_BASE(0x80_000) をスタックポインタに設定して、kinit() を
> 呼び出す。」

    ヒント
    まだよく知らない命令やレジスタについてはマニュアルを参照してください。

    ヒント
    `init.rs`をレビューするには`aarch64`ライブラリと
    `kern/src/param.rs`が必要になります。

### サブフェーズ C: EL1への切り替え

このサブフェーズではEL2からEL1に切り替えるためのRustコードを書きます。
主に`kern/src/init.rs`と`kern/src/main.rs`で作業します。このサブ
フェーズに進むのは前のサブフェーズの質問に答えてからにすることを
勧めます。

#### 現在の例外レベル

すでに説明したようにカーネルが呼び出された時、CPUはEL2で動作している
はずです。`kmain()`で現在の例外レベルを表示することでこのことを確認して
ください。`current_el()`を呼び出すには`unsafe`を使用する必要があることに
注意してください。EL1に正常に切り替えたことを確認できたらこの呼び出しは
削除します。`current_el()`は`lib/aarch64`ライブラリにあります。依存問題を
解決するにはこのライブラリを追加する必要があります。

#### 切り替え

EL1に切り替えるためのアセンブリコードを完成させる時間です。
`kern/src/init.rs`で次の行を見つけてください。

```rust
// FIXME: eret to itself, expecting current_el() == 1 this time
```

この行の上には次のコードがあります。

```rust
SPSR_EL2.set(
    (SPSR_EL2::M & 0b0101)
    | SPSR_EL2::F
    | SPSR_EL2::I
    | SPSR_EL2::D
    | SPSR_EL2::A,
);
```

前のサブフェーズで学んだのでこれらのビットが何をするのかを知っている
はずです。特に、`SPSR_EL2`のどのビットをセットするとその後に`eret`
したらその結果どうなるかを知っているはずです。

`FIXME`を適切なコードに置き換えることで切り替えルーチンを完成させて
ください。EL1に切り替えた際、CPUが適切な例外レベルで再帰的に
`switch_to_el1`にジャンプして、内部チェックの`current_el() == 2`を
バイパスして`kmain()`に進むことを確認してください。このルーチンを
完了するのに必要なコードは2行です。例外レベルを下げる唯一の方法は
`eret`であることを思い出してください。ルーチンを完了したら今度は
`current_el()`が`1`を返すことを確認してください。

**ヒント**
> 例外からリターンする際にPCをセットするにはどのレジスタを使用しますか.

#### サブフェース D: 例外ベクタ

このサブフェーズでは例外ベクタと例外ハンドラを設定してインストールします。
これはカーネルが任意の例外や割り込みを処理できるようにするための第一歩と
なります。作成した例外ベクタと例外ハンドラは`brk #n`命令に応答して起動する
小さなデバッガを実装することでテストします。主に`kernel/src/init/vectors.s`,
`kernel/src/traps.rs`, `kernel/src/traps`ディレクトリで作業します。

#### 概要

ベクトルテーブルは16個のベクトルで構成され、各ベクトルは最大16個の一連の
命令であることを思い出してください。`vectors.s`の中にこれらのベクタ用の
スペースを確保し、`vectors`ラベルをテーブルの先頭に配置しました。この
`vectors.s`ファイルは`init.rs`で`global_asm!`マクロによりインクルード
されます。あなたの課題は16個のベクタでテーブルを埋め、最終的に例外が
発生した際に`kernel/src/traps.rs`にある`handle_exception`Rust関数が適切な
引数で呼び出されるようにすることです。すべての例外は`handle_exception`
関数にルーティングされます。この関数は例外がなぜ発生したかを判断し、
必要に応じてより上位のハンドラに例外をディスパッチします。

#### 呼び出し規約

Rustで宣言された`handle_exception`関数を適切に呼び出すにはその関数が
どのように呼び出されることを期待しているかを知っておく必要があります。
特に、その引数である`info`, `esr`, `tf`の値を関数はどこで見つけるのか、
関数が呼び出された後のマシンの状態についてどんな約束があるのか、関数を
呼び出した場所にどのように戻るのかを知っておく必要があります。

この外部の関数を呼び出す方法を知るという問題は（ラボ3でC言語とRust言語
の間で行ったような）ある言語が別の言語を呼び出す際にはいつでも発生します。
すべての言語が関数をどのように呼び出すかを知っておかなくても良いように
_呼び出し規約_ が確立されています。_呼び出し規約_（または、
_プロシジャ呼び出し規約_）とは以下を定めた一連の規則のことです。

- **どのように関数に引数を渡すか**

  AArch64では最初の8つの引数は左から右の順でレジスタ`r0`...`r7`で渡します。

- **どのように関数から値を返すか**

  AArch64では最初の8つの返り値はレジスタ`r0`...`r7`で渡されます。

- **関数はどの状態（レジスタ、スタックなど）を保存する必要があるか**

  レジスタは通常 _caller-saved_ と _callee-saved` に分類されます。

  _caller-saved_ レジスタは関数呼び出しの前後で保存されることは保証
  されていません。したがって、callerはレジスタ値を保存する必要がある
  場合は関数を呼び出す前にレジスタ値を保存する必要があります。

  逆に、_callee-saved_ レジスタは関数呼び出しの前後で保存されることが
  保証されています。したって、関数呼び出し中に対象のレジスタを使用したい
  場合、calleeはそのレジスタを使用する前にレジスタ値を保存し、リターン
  する前にそのレジスタ値を復元する必要があります。

  レジスタ値の保存と復元は通常、スタックへのpushとpopで行われます。

  AArch64ではレジスタ`r19`...`r29`と`SP`がcaller-savedで、残りの汎用
  レジスタはcallee-savedです。これには`lr` (`x30`) も含まれることに注意
  してください。SIMD/FPレジスタには複雑な保存規則があります。私たちの
  目的のためにはこれらはすべてcaller-savedであると言えば十分です。

- **どのように呼び出し元に帰るのか**

  AArch64では`lr`レジスタが _リンクアドレス_ （calleeがリターンする際に
  ジャンプすべきアドレス）を保持します。`ret`命令は`lr`に分岐するので
  通樹はそれで関数は終了します。

AArch64の呼び出し規約は公式の[プロシジャコール標準](https://tc.gts3.org/cs3210/2020/spring/r/AArch64-Procedure-Call-Standard.pdf)
ドキュメントと共に (guide: 9) でも説明されています。アセンブリから
`handle_exception` Rust関数を呼び出す場合はこの呼び出し規約を確実に
守る必要があります。

**注記: Rustはどの規約を使えばよいかをどのようにして知るのか**
> 呼び出し規約を厳密に守ると関数呼び出しや関数本体のあらゆる最適化が
> できなくなります。そのため、Rustの関数はデフォルトでは特定の呼び出し
> 規約に従うことが保証されていません。対象となるプラットフォームの呼び
> 出し規約に完全に従うように関数をコンパイルするには`extern`関数修飾子を
> 使用します。`handle_exception`はすでに`extern`として宣言しているので
> Rustが関数を適切にコンパイルすることを保証することができます。

#### ベクタテーブル

ベクタテーブルを埋めるための手助けをするマクロ `HANDLER source, kind` を
用意しました。このマクロは次の有効なベクタエントリにアラインする8命令に
展開します。`HANDLER a, b`を"命令"として使用すると`.macro`と`.endm`の
間に展開されます。すなわち、

```rust
vectors:
    HANDLER 32, 39
```

は、次のように展開されます。

```rust
vectors:
    .align 7
    stp   lr, xzr, [SP, #-16]!
    stp   x28, x29, [SP, #16]!

    mov   x29, #32
    movk  x29, #39, LSL #16
    bl    context_save

    ldp   x28,x29, [SP], #16
    ldp   lr, xzr, [SP], #16
    eret
```

展開されたコードは`lr`, `xzr`, `x28`, `x29`をスタックにプッシュし、
下位16ビットが`source`、上位16ビットが`kind`となる32ビットの値を
`x29`に作成し、アセンブリ関数`context_save`（`vectors.s`で`vectors`の
上で宣言されています）を呼び出します。この関数が復帰したらスタックから
保存した4つのレジスタを復元し、最後に例外から復帰します。

`context_save`関数は今のところ何もしません。単に下の`context_restore`
からの`ret`に進むだけです。後で関数`context_save`を修正してRust関数
`handle_exception`を正しく呼び出すようにします。

#### Syndrome構造体

_同期例外_（命令の実行または試行によって発生する例外）が発生すると
CPUは例外の原因を記述する値をシンドロームレジスタ（`ESR_ELx`）にセット
します (ref: D1.10.4)。`kernel/src/traps/syndrome.rs`にシンドローム値を
解析して意味のある`Syndrome enum`に変換する構造体を設定しました。この後
すぐに`ESR_ELx`値を`esr`パラメータとしてRust関数に渡すコードを書くことに
なります。そして、`Syndrome::from(esr)`を使って次に何をすべきかを決定する
シンドロームの値を解析します。

#### Info構造体

Rust関数`handle_exception`は第1パラメータとして`Info`構造体を受け取ります。
この構造体には2つの16ビットフィールドがあります。最初のフィールドはソースに、
2番目のフィールドは例外の種類に対応します。もうおわかりだと思いますが
これは`HANDLE`マクロが`x29`で設定する`32ビット`値そのものです。この値を
第1パラメータとして渡すには`context_save`コードブロック内で`x29`を`x0`に
移動する必要があります。さらに、`Info`構造体が正しく作成されるように
正しいエントリに対して正しく`HANDLE`を呼び出すようにしてください。

#### 実装

これで予備的な例外処理コードを実装する準備ができました。最初に扱う例外は
`brk`例外（ソフトウェアブレークポイント）です。この例外が発生した場合は
理論的にはそれを実行した時点でのマシンの状態を調べることができるシェルを
起動することになります。

`main.rs`に`brk`の呼び出しを挿入することから始めます。インラインアセンブリを
使う代わりに`aarch64`ライブラリの`asm.rs`で定義されている`brk`マクロを
呼び出すことができます。

その後は次のように進めます。

1. **`HANDLE`マクロを使って`vectors`テーブルを埋める**

    エントリが`Info`構造体を正しく作成するようにしてください。
    (guide: 10.4) を参照してエントリの順序をチェックしてください。
    ハンドラの`source`と`kind`は`src/traps.rs`にある`Source`と`Kind`
    enumにマッチするようにしてください。

2. **`context_save`内で`handle_exception`関数を呼び出す**

    必要に応じてcaller-savedレジスタを保存/復元して適切なパラメータを
    渡すようにしてください。今のところ`tf`パラメータには`0`を渡しておく
    ことができます。これは後で使うことになります。引数に何を渡すかは
    `src/traps.rs`を参照してください。

    **注意**: AArch64では`SP`レジスタをロード/ストアの一部として使用
    する場合、常に16バイトアラインにする必要があります。常に`SP`を
    16バイトアラインに保つようにしてください。

3. **`init.rs`にある次のコメントでマークされている位置で正しい`VBAR`レジスタをセットアップする**

    ```rust
    // FIXME: load `vectors` addr into appropriate register (guide: 10.4)
    ```

4. **この時点で例外が発生するたびに`handle_exception`関数が呼び出される
  はず**

    `handle_exception`でパラメタ`info`と`esr`の値を表示し、それらが期待
    通りであることを確認してください。その後、ハンドラ内で無限ループ
    させます。ループの中では`aarch64::nop()`を呼び出して最適化で削除
    されないようにします。例外ハンドラから適切に戻るにはさらにコードを
    書く必要がありますが、今は単にループさせることにします。これは次の
    サブフェーズで修正することになります。

5. **`Syndrome::from()`メソッドと`Fault::from()`メソッドを実装する**

    前者は後者を呼び出す必要があります。これらを正しく実装するには (ref:
    D1.10.4, ref: Table D1-8) を参照する必要があるでしょう。テーブルの
    "ISS encoding description"をクリックすると特定の例外クラスの
    シンドロームのデコード方法と`Fault`のデコード方法の詳細がわかります。
    たとえば、`brk 12`は`Syndrome::Brk(12)`とデコードされることが確認できる
    はずです。同様に、`svc 77`は`Syndrome::Svc(77)`と解析します。いくつかの
    例外の32ビット値を省略していたり、同じ例外だが異なる例外クラスで発生
    した例外は合体させていることに注意してください。

    **警告**: aarch64ライブラリを使用してください
    インラインアセンブリを使用したり、各レジスタで生のビット操作を
    行なったりせずに`aarch64`ライブラリで定義されているレジスタや関数を
    使用すると便利です。`REG_NAME::get_value(raw_value, REG_NAME::MASK)`
    関数が便利なことがわかるでしょう。

6. **`brk`例外が発生したらシェルを起動する**

    `brk`例外の検出には`handle_exception`の`Syndrome::from()`メソッドを
    使用してください。このような例外が発生したらシェルを起動します。
    シェルを区別するために異なるシェルプレフィックスを使用するとよいで
    しょう。`Syndrome::from()`の呼び出しは同期例外に対してだけにするべきで
    あることに注意してください。それ以外の場合は`ESR_ELx`レジスタが有効な
    値を保持している保証はないからです。

    この時点でシェルを変更して新しいコマンド`exit`を実装する必要があります。
    `exit`が呼ばれたらシェルはループを終了して復帰する必要があります。
    これにより後で`brk`例外から抜けることができるようになります。この変更の
    ため、カーネルが終了してクラッシュするのを防ぐためにkmain内の`shell()`
    への呼び出しを`loop { }`でラップする必要もあります。

これらの実装が終了したら`kmain`での`brk 2`命令はシンドローム`Brk(2)`、
ソース`CurrentSpElx`、種別`Synchronous`の例外となり、`handle_exception`
関数にルーティングされ、デバッグシェルが起動するはずです。シェルから
`exit`が呼ばれるとシェルは終了し、例外ハンドラは無限ループを開始する
はずです。

先に進む前に、他の同期例外を正しく検出していることを確認すべきです。
`svc 3`などの他の例外を引き起こす命令の呼び出しを試してみる必要が
あります。また、物理メモリの範囲外のアドレスにジャンプすることで
意図的にデータアボートや命令アボートを引き起こしてみることも必要です。

すべてが期待通りに動いたら、次の段階に進んでください。
