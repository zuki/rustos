# Lab 4: プリエンプティブマルチタスク

- [フェーズ 0: 始めよう](#フェーズ-0-始めよう)
- [フェーズ 1: ARMとLeg](#フェーズ-1-armとleg)
  - [サブフェーズ A: ARMv8概要](#サブフェーズ-a-armv8概要)
  - [サブフェーズ B: 命令](#サブフェーズ-b-命令)
  - [サブフェーズ C: EL1への切り替え](#サブフェーズ-c-el1への切り替え)
  - [サブフェース D: 例外ベクタ](#サブフェース-d-例外ベクタ)
  - [サブフェーズ E: 例外からの復帰](#サブフェーズ-e-例外からの復帰)
- [フェーズ 2: それはプロセス](#フェーズ-2-それはプロセス)

## はじめに

この課題ではプロセスとその関連するインフラストラクチャを実装することで
ユーザレベルのアプリケーションを実現します。特権レベルの切り替えコード、
コンテキストスイッチコード、単純なラウンドロビンスケジューラ、システム
コールハンドラ、仮想メモリサブシステムを作成します。また、いくつかの
ユーザプログラムを書き、それらをロードして新しいプロセスを開始します。

## フェーズ 0: 始めよう

ラボ4用のアップデートをgitリポジトリから開発マシンに取得します。

```bash
$ git fetch skeleton
$ git merge skeleton/lab4
```

リポジトリのディレクトリ構造は次のようになります。この課題で作業する
ディレクトリには`*`がついています。

```bash
.
├── bin : common binaries/utilities
├── doc : reference documents
├── ext : external files (e.g., resources for testing)
├── tut : tutorial/practices
│    ├── 0-rustlings
│    ├── 1-blinky
│    ├── 2-shell
│    ├── 3-fs
│    └── 4-spawn : questions for lab4 *
├── boot : bootloader
├── kern : the main os kernel *
├── lib  : required libraries
│     ├── aarch *
│     ├── kernel_api *
│     ├── fat32
│     ├── pi
│     ├── shim
│     ├── stack-vec
│     ├── ttywrite
│     ├── volatile
│     └── xmodem
└── user  : user level program *
      ├── fib *
      └── sleep *
```

作業を進める前にコンフリクトを解決する必要があるかもしれません。
たとえば、次のようなメッセージが表示された場合です。

```bash
Auto-merging kern/src/main.rs
CONFLICT (content): Merge conflict in kern/src/main.rs
Automatic merge failed; fix conflicts and then commit the result.
```

コンフリクトを解決するには`main.rs`を手動で修正する必要があります。
ラボ 3で変更した内容がすべて保持されていることを確認してください。
すべてのコンフリクトが解決したら解決したファイルを`git add`して
コミットしてください。マージコンフリクトの解決方法については
githowto.com のチュートリアルを参照してください。

### ARMドキュメント

この課題では次の3つのARM公式文書を参照します。

- [ARMv8リファレンスマニュアル](../arm_docs/ARMv8-Reference-Manual.pdf)

  ARMv8アーキテクチャの公式リファレンス マニュアルです。これは一般的な
  方法でアーキテクチャ全体をカバーする包括的なマニュアルです。Raspberry
  Pi 3向けのアーキテクチャの具体的な実装についてはARM Cortex-A53
  マニュアルを参照してください。このマニュアルのセクションを参照する
  場合は([ref:](../arm_docs/ARMv8-Reference-Manual.pdf) C5.2) という形で示します。これは[ARMv8リファレンスマニュアル](../arm_docs/ARMv8-Reference-Manual.pdf)の
  セクション C5.2を参照する必要があることを示します。

- [ARM Cortex-A53マニュアル](../arm_docs/ARM-Cortex-A53-Manual.pdf)

  Raspberry Pi 3で使用されているARMv8 (v8.0-A)アーキテクチャの具体的な
  実装に関するマニュアルです。このマニュアルのセクションを参照する
  場合は([A53](../arm_docs/ARM-Cortex-A53-Manual.pdf): 4.3.30)という形で示します。これは[ARMv8リファレンスマニュアル](../arm_docs/ARM-Cortex-A53-Manual.pdf)の
  セクション 4.3.30を参照する必要があることを示します。

- [ARMv8-Aプログラマガイド](../arm_docs/ARMv8-A-Programmer-Guide.pdf)

  ARMv8-Aプロセスのプログラミング方法に関する高水準手引きドです。
  このマニュアルのセクションを参照する
  場合は([guide](../arm_docs/ARMv8-A-Programmer-Guide.pdf): 10.1)という形で示します。これは[ARMv8-Aプログラマガイド](../arm_docs/ARMv8-A-Programmer-Guide.pdf)の
  セクション 10.1を参照する必要があることを示します。

これら3つのドキュメントはすべて`doc/src/arm_docs`サブディレクトリに
あります。今すぐこれら3つのドキュメントをダウンロードしてすぐ手の届く
ところに置いておくことを勧めます。

## フェーズ 1: ARMとLeg

このフェーズではARMv8アーキテクチャについて学び、下位特権レベルへの
切り替え、例外ベクタのインストールし、タイマー割り込みの有効化、
デバッグシェルの起動によるブレークポイント例外の処理を行います。ARM
アーキテクチャの例外レベルについて学習し、アーキテクチャが例外、割り込み、
特権レベルをどのように扱うかを学びます。

### サブフェーズ A: ARMv8概要

このサブフェーズではARMv8アーキテクチャについて学習します。コードを書く
ことはありませんが、アーキテクチャに関するいくつかの質問に答えることに
なります。

ARM (Acorn RISC Machine) CPUアーキテクチャは30年以上の歴史があります。
主要なリビジョンが8つあり、最新のリビジョンが2011年に導入されたARMv8-A
です。Broadcom BCM2837 SOCにはARMv8.0-AベースのCPUであるARM Cortex-A53が
搭載されています。Cortex-A53（やその他の特定のCPU）はこのアーキテクチャの
実装と呼ばれます。これはこれまで3回の課題でプログラミングしてきたた
CPUです。

**注記: モバイル市場を支配するARM CPU**
> ARM CPUはモバイル市場を支配しており、世界中で販売されているスマート
> フォンの95％以上、アップルのiPhoneやグーグルのPixelを含むフラッグシップ
> スマートフォンのほぼ100％に搭載されています。

これまでは基礎となるアーキテクチャーの詳細については不問とし、Rust
コンパイラーに任せてきました。しかし、ユーザ空間でプロセスを実行できる
ようにするには最下位レベルでCPUを直接プログラミングする必要があります。
CPUを直接プログラミングするにはCPUネイティブのアセンブリ言語と全体的な
概念に精通する必要があります。まず、アーキテクチャの概要から説明し、
次に、いくつかの主要なアセンブリ命令について説明します。

#### レジスタ

ARMv8アーキテクチャには以下のレジスタがあります (ref: B1.2.1)。

- `r0`...`r30` - 64ビットの汎用レジスタ

  これらのレジスタはエイリアスによりアクセスされます。レジスタ
  `x0`...`x30`はこれらのレジスタの64ビット全体のエイリアスです。レジスタ
  `w0`...`w30`はこれらのレジスタの最下位32ビットのエイリアスです。

- `lr` - 64ビットのリンクレジスタ: `x30`のエイリアス

  _リンクアドレス_ の格納に使用されます。`bl <addr>`命令は次の命令の
  アドレスを`lr`に格納し、`addr`に分岐します。`ret`命令は`lr`の
  アドレスをPCにセットします。

- `sp` - スタックポインタとして使用

  スタックポインタの下位32ビットは`wsp`でアクセスできます。スタック
  ポインタは常に16バイトアラインされていなければなりません。

- `pc` - プログラムカウンタ

  このレジスタは読み込みはできますが、書き込むことはできません。`pc`は
  分岐命令と例外のエントリ/リターンで更新されます。

- `v0`...`v31` - 128ビットのSIMD/FPポイントレジスタ

  これらのレジスタはベクトル化SIMD命令と浮動小数点演算に使用されます。
  これらのレジスタはエイリアスによりアクセスされます。レジスタ
  `q0`...`q31`はこれらのレジスタの128ビットすべてのエイリアスです。
  レジスタ`d0`...`d31`はこれらのレジスタの下位64ビットのエイリアスです。
  また、これらのレジスタのそれぞれ、下位32ビット、16ビット、8ビットを示す
  `s`、`h`、`b`を前置詞とするエイリアスがあります。

- `xzr` - read-onlyのゼロレジスタ

  この擬似レジスタは（ハードウェアレジスタである場合とそうでない場合が
  ありますが）常に値`0`を保持します。

また、_多くの特殊_ レジスタもあります。これらのレジスタについては
次のセクションのように、必要に応じて説明します。

#### PSTATE

ARMv8 CPUはすべての時点で _プログラムの状態_ をPSTATEという疑似レジスタに
取り込みます (ref: D1.7)。PSTATEは実際のレジスタではなく、直接読み書きする
方法はありません。代わりに、PSTATE擬似レジスタの様々なフィールドを読み書き
するために使用できる特殊レジスタがあります。ARMv8.0では以下が該当します。

- `NZCV` - 条件フラグ
- `DAIF` - 例外マスクビット。例外が発行されないようにするために使用
- `CurrentEL` - 現在の例外レベル（後で説明）
- `SPSel` - スタックポインタセレクタ

これらのレジスタは _システムレジスタ_ または _特殊レジスタ_ として
知られるレジスタクラスに属します (ref: C5.2)。通常、レジスタは`ldr`
命令を使ってメモリからロードし、`str`命令を使ってメモリにストア
することができます。システムレジスタはこれらの命令では読み書きできません。
代わりに、特殊目的命令の`mrs`と`msr`を使用する必要があります
(ref: C6.2.162～C6.2.164)。たとえば、`NZCV`を`x1`に読み込むには
次の命令を実行します。

```
mrs x1, NZCV
```

#### 実行状態

ARMv8 CPUはすべての時点で所定の _実行状態_ で実行されています。このような
実行状態は2つあります。32ビットのARMv7互換モードに対応するAArch32と
64ビットのARMv8モードのAArch64です (guide: 3.1)。私たちは常にAArch64で
実行します。

#### セキュアモード

ARMv8 CPUはすべての時点で所定の _セキュリティ状態_ （ほかでは
_セキュリティモード_ または _セキュリティワールド_ と呼ばれています）で
実行されています。セキュリティ状態には _セキュア_ と _ノーマル_
としても知られている _非セキュア_ （non-secure）の2つの状態が
あります。私たちは常に非セキュア（ノーマル）モードで実行します。

#### 例外レベル

ARMv8 CPUはすべての時点で所定の _例外レベル_ (guide: 3) で実行されて
います。各例外レベルは _特権レベル_ に対応しており、例外レベルが高いほど
そのレベルで実行されているプログラムの特権が大きくなります。例外レベル
には次の4つがあります。

- `EL0`（ユーザ） - 通常、信頼されないユーザアプリケーションの実行に
  使用されます
- `EL1`（カーネル） - 通常、特権を持つOSカーネルを実行するために使用されます
- `EL2`（ハイパーバイザ） - 通常、仮想マシンハイパーバイザの実行に使用されます
- `EL3`（モニタ） - 通常、低レベルファームウェアの実行に使用されます

Raspberry PiのCPUはEL3で起動します。その時点ではRaspberry Pi財団が
提供するファームウェアが実行され、ファームウェアはCPUをEL2に切り替え、
`kernel8.img`ファイルを実行します。したがって、私たちのカーネルはEL2で
実行を開始します。その後、私たちのカーネルが適切な例外レベルで実行される
ようにEL2からEL1に切り替えることになります。

#### #Lxレジスタ

`ELR`、`SPSR`、`SP`など、いくつかのシステムレジスタは例外レベルごとに
重複して存在してます。例外レベル`n`用のレジスタを示すためにレジスタ名の
末尾には`_ELn`が付いています。たとえば、`ELR_EL1`は_EL1用の例外リンクレジスタ_ で
あり、`ELR_EL2`はEL2用の例外リンクレジスタです。

_ターゲット_ 例外レベル`x`のレジスタに言及する場合は`ELR_ELx`のように
接尾辞に`x`を使用します。ターゲット例外レベルとは例外ベクタを実行する
ためにCPUが必要に応じて切り替える例外レベルのことです。_ソース_ 例外
レベル`x`のレジスタに言及する場合は`SP_ELs`のように接尾辞に`s`を使用
します。ソース例外レベルとは例外が発生したときにCPUが実行していた例外
レベルのことです。

#### 例外レベルの切り替え

例外レベルを増加させるメカニズムは1つしか存在しません。また、例外レベルを
減少させるメカニズムも1つしか存在しません。

高いレベルから低いレベルに切り替える（特権を減らす）には実行中の
プログラムが`eret`命令 (ref: D1.11) を使用して例外レベルから _return_
しなければなりません。現在の例外レベルが`ELx`のときに`eret`命令を実行
すると、CPU は次のようになります。

- 特殊システムレジスタ`ELR_ELx`の値をPCにセットする
- 特殊システムレジスタ`SPSR_ELx`の値をPSTATEにセットする

`SPSR_ELx`レジスタ (ref: C5.2.18) にはリターンすべき例外レベルも格納
されています。例外レベルの変更には次のような影響もあることに注意して
ください。

- `Els`にリターンする際、`sp`には`SPSR_ELx[0] == 1`の場合は`SP_ELs`が、
  `SPSR_ELx[0] == 0`の場合は`SP_EL0`がセットされます。

下位レベルから上位レベルへの切り替えは例外の結果としてしか発生しません
(guide: 10)。特に設定しない限り、CPUは例外を次の例外レベルでトラップ
します。たとえば、`EL0`で動作中に割り込みを受けた場合、CPUは`EL1`に
切り替えて例外を処理します。`ELx`への切り替えが発生するとCPUは次のように
なります。

- `PSTATE.DAIF=0b1111`とセットすることですべての例外と割り込みを
  マスクします
- `PSTATE`などのフィールドを`SPSR_ELx`に保存します
- _優先例外リンクアドレス_ を`ELR_ELx`に保存します (ref: D1.10.1)
- `SPSel`が`1`に設定されていた場合は`sp`に`SP_ELx`をセットします
- _例外シンドローム_ （後述）を`ESR_ELx`に保存します (ref: D1.10.4)
- 例外ベクタ(後述)に対応するアドレスを`PC`にセットします（後述）

例外シンドロームレジスタが有効なのは例外が _同期_ （後述）であった
場合だけであることに注意してください。すべての汎用レジスタとSIMD/FP
レジスタは例外が発生したときの値を維持します。

#### 例外ベクタ

例外が発生するとCPUはその例外に対応する _例外ベクタ_ にジャンプします
(ref: D1.10.2)。例外には4つのタイプがあり、それぞれ4つの例外発生源が
考えられるため合計16個の例外ベクタが存在します。例外の4タイプは次の
とおりです。

- **同期** - `svc`や`brk`などの命令により発生する例外
- **IRQ** - 外部ソースからの非同期割り込み要求
- **FIQ** - 外部ソースからの非同期高速割り込み要求
- **SError** - 「システムエラー」割り込み

4つの発生源は次のとおりです。

- ソースが`SP = SP_EL0`で同じ例外レベル
- ソースが`SP = SP_ELxPで同じ例外レベル
- AArch64で実行中の下位の例外レベル
- AArch32で実行中の下位の例外レベル

プログラムガイド (guide: 10.4) では次のように記述されています。

例外が発生するとプロセッサは例外に対応するハンドラコードを実行
しなければなりません。[例外]ハンドラが格納されるメモリ上の場所は
_例外ベクタ_ と呼ばれています。ARMアーキテクチャでは例外ベクタは
_例外ベクタテーブル_ と呼ばれるテーブルに格納されます。各例外レベルは
独自のベクタテーブルを持っています。つまり、EL3、EL2、EL1のそれぞれに
1つずつテーブルがあります。このテーブルには[x86がそうであるような]
アドレスの集合ではなく、実行されるべき命令が格納されています。ベクタ
テーブルの各エントリは16命令長です。個々の例外用のベクタはテーブルの
先頭から固定オフセットに配置されます。各テーブルのベースとなる仮想
アドレスはベクタベースアドレス[特殊]レジスタの`VBAR_EL3`, `VBAR_EL2`,
`VBAR_EL1`によりセットされます。

ベクターは物理的に次のように配置されます。

- ソースが`SP = SP_EL0`でターゲットとソースが同一の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x000 | 同期例外 |
| 0x080 | IRQ |
| 0x100 | FIQ |
| 0x180 | SError |

- ソースが`SP = SP_ELx`でターゲットとソースが同一の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x200 | 同期例外 |
| 0x280 | IRQ |
| 0x300 | FIQ |
| 0x380 | SError |

- AArch64で実行中でソースが下位の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x400 | 同期例外 |
| 0x480 | IRQ |
| 0x500 | FIQ |
| 0x580 | SError |

- AArch32で実行中でソースが下位の例外レベル

| `VBAR_ELx`オフセット | 例外 |
|:---------------------|:-----|
| 0x600 | 同期例外 |
| 0x680 | IRQ |
| 0x700 | FIQ |
| 0x780 | SError |

ベクタテーブルは連続しています。

#### Rustとのインタフェース

システムに関する低レベルの詳細にアクセスするためのRustyインタフェースを
提供するために`aarch64`ライブラリ (`lib/aarch64`) を用意しました。
次のサブフェーズに移る前に`regs.rs`で定義されているレジスタとあなたの
理解を比較してください。ライブラリ内の他のファイルについては次のサブ
フェーズの最後に再検討します。

#### まとめ

とりあえず、ARMv8アーキテクチャについて知っておくべきことは以上です。
次に進む前に以下の質問に答えてください。

**質問 (arm-x30): x30はどのレジスタのエイリアスか**
> `x30`に`0xFFFF`という値が書き込まれた場合、その値を取り出すために
> 使用できる他の2つのレジスタ名は何ですか.

**質問 (arm-pc): 特定のアドレスをPCにセットする方法は**
> `ret`命令を使ってどのようにアドレス`A`をPCにセットしますか。
> `eret`命令を使ってどのようにアドレス`A`をPCにセットしますか。
> どのレジスタにどの値をセットするか、具体的に答えてください。

**質問 (arm-el): どのようにして現在の例外レベルを知るか**
> 現在の例外レベルを知るために具体的にどの命令を実行しますか。

**質問 (arm-sp-el): どのようにして例外からの復帰時にスタックポインタを変更するか**
> 例外が発生した際に実行中のプログラムのスタックポインタは`A`です。
> 例外を処理した後、プログラムが実行されていた場所に戻りたいが
> スタックポインタは`B`に変更したい。どのようにしますか。

**質問 (arm-svc): 下位ELからのシステムコールに使用されるベクタはどれか**
> `svc`命令を発行した時プロセスは`EL0`で実行中でした。CPUは具体的に
> どのアドレスにジャンプしますか。

**質問 (arm-int): 下位のELからの割り込みに使用されるベクタはどれか**
> タイマー割り込みが発生した時プロセスは`EL0`で実行中でした。
> CPUは具体的にどのアドレスにジャンプしますか。

**質問 (arm-mask): IRQ例外のマスクを解除するには**
> IRQ割り込みのマスクだけを解除するにはどのレジスタにどんな値を
> 書き込みますか。

**質問 (arm-aarh32): どのようにしてAArch32実行状態に`eret`するか**
> ソースがAArch64で実行中に例外が発生しました。ターゲットもAArch64で
> 実行中です。`eret`によって例外から復帰する際にCPUをAArch32実行状態に
> 切り替えるにはどのレジスタのどの値を変更しますか。

       ヒント
       (guide: 10.1)を参照してください。

### サブフェーズ B: 命令

このサブフェーズではARMv8命令セットについて学習します。コードを書く
ことはありませんが、命令セットに関するいくつかの質問に答えることに
なります。

#### メモリへのアクセス

ARMv8はロード/ストアRISC (Reduced Instruction Set Computer) 命令
セットです。このような命令セットの決定的な特徴はメモリのアクセスが
特定の命令でしかできないことです。つまり、メモリの読み込みはロード
命令でレジスタに読み込むことしかできず、メモリへの書き込みはストア
命令でレジスタからメモリに書き込むことしかできません。

ロード命令とストア命令には多くの種類があり、特定の命令にはバリエーションも
あります。最も単純なものから説明します。

- `ldr <ra>, [<rb>]` : <rb>のアドレスの値を<ra>にロードする
- `str <ra>, [<rb>]` : <ra>の値を<rb>のアドレスにストアする

レジスタ `<rb>` は _基底アドレス_ と呼ばれます。`r3 = 0x1234` の場合、

```
ldr r0, [r3]    // r0 = *r3 (すなわち、r = *(0x1234))
str r0, [r3]    // *r3 = r0 （すなわち、*(0x1234) = r0
```

`[-256, 255]`の範囲のオフセットを指定することもできます。

```
ldr r0, [r3, #64]     // r0 = *(r3 + 64)
str r0, [r3, #-12]    // *(r3 - 12) = r0
```

ポストインデックスを指定することもできます。これはロードまたはストアの
_後に_ 基底アドレスの値を変更します。

```
ldr r0, [r3], #30     // r0 = *r3; r3 += 30
str r0, [r3], #-12    // *r3 = r0; r3 -= 12
```

プリインデックスを指定することもできます。これはロードまたはストアの
_前に_ 基底アドレスの値を変更します。

```
ldr r0, [r3, #30]!    // r3 += 30; r0 = *r3
str r0, [r3, #012]!   // r3 -= 12; *r3 = r0
```

オフセット、ポストインデックス、プリインデックスは _アドレッシングモード_
と呼ばれます。

最後に、`ldp`命令と`stp`命令 (load pair, store pair) を使うと一度に2つの
レジスタからロードとストアができます。これらの命令には`ldr`と`str`と同じ
アドレッシングモードを使用することができます。

```
// `x0` と `x1` をスタックに積む。 操作後のスタックは次のようになる
//
//   |------| <- SP
//   |  x0  |
//   |------|
//   |  x1  |
//   |------| <x (original SP)
//
stp x0, x1, [SP, #-16]!

// pop `x0` と `x1` をスタックから下ろす。操作後のスタックは次のようになる
//
//   |------| <x (original SP)
//   |  x0  |
//   |------|
//   |  x1  |
//   |------| <- SP
//
ldp x0, x1, [SP], #16

// 次の4つの操作は上の2つの操作と同じことをする
sub SP, SP, #16
stp x0, x1, [SP]
ldp x0, x1, [SP]
add SP, SP, #16

// 上と同じだが、x0, x1, x2, x3の保存と復元をする
sub SP, SP, #32
stp x0, x1, [SP]
stp x2, x3, [SP, #16]

ldp x0, x1, [SP]
ldp x2, x3, [SP, #16]
add SP, SP, #32
```

#### 即値のロード

_即値_ とは計算なしで値がわかる整数の別名です。16ビットの即値を、任意に
16ビットの倍数だけ左にシフトして、レジスタにロードするには`mov` (move)
を使用します。16ビットの即値を、他のビットは置き換えることなく数ビット
左にシフトして、ロードするには`movk`（move/keep）命令を使用します。
使用例は次の通り。

```
mov   x0, #0xABCD, LSL #32    // x0 = 0xABCD00000000
mov   x0, #0x1234, LSL #16    // x0 = 0x12340000

mov   x1, #0xBEEF             // x1 = 0xBEEF
movk  x1, #0xDEAD, LSL #16    // x1 = 0xDEADBEEF
movk  x1, #0xF00D, LSL #32    // x1 = 0xF00DDEDBEEF
movk  x1, #0xFEED, LSL #48    // x1 = 0xFEEDF00DDEADBEEF
```

即値の前には`#`が付くこと、ディスティネーションレジスタは左に置くこと、
`LSL`は左シフトを指定することに注意してください。

レジスタにロードできるのは任意のシフトを伴う16ビット即値だけです。
多くの場合、アセンブラは正しいシフト値を見つけ出すことができます。
たとえば、アセンブラは`mov x12, #(1 << 21)`を`mov x12, 0x20, LSL #16`に
自動的に変換することができます。

#### ラベルからのアドレスのロード

アセンブリコードのセクションは`<label>;`を使って _ラベル付け_ する
ことができます。

```
add_30:
    add x1, x1, #10
    add x1, x1, #20
```

ラベル後の最初の命令のアドレスをロードするには`adr`命令か`ldr`命令を
使用することができます。

```
adr x0, add_30      // x0 = add_30の最初の命令のアドレス
ldr x0, =add_30     // x0 = add_30の最初の命令のアドレス
```

ラベルが命令と同じリンカセクションにない場合は`ldr`を使用する必要が
あります。ラベルが同じセクション内にある場合は`adr`を使用するべきです。

#### レジスタ間の移動

`mov`命令でレジスタ間の値の移動をすることもできます。

```
mov x13, #23    //          x13 = 23
mov sp, x13     // sp = 23, x13 = 23
```

#### 特殊レジスタからのロード

`ELR_EL1`などの特殊/システムレジスタは`mrs`命令と`msr`命令を使って
別のレジスタへのロード/ストアしかできません。

別のレジスタから特殊レジスタへ書き込むには`msr`命令を使用します。

```
msr ELR_EL1, x1     // ELR_EL1 = x1
```

特殊レジスタからへ別のレジスタに読み込むには`mrs`命令を使用します。

```
mrs x0, CurrentEL   // x0 = CurrentEL
```

#### 算術演算

`add`命令と`sub`命令を使って算術演算をすることができます。構文は次の通り。

```
add <dest> <a> <b>      // dest = a + b
sub <dest> <a> <b>      // dest = a - b
```

たとえば、

```
mov x2, #24
mov x3, #36
add x1, x2, x3    // x1 = 24 + 36 = 60
sub x4, x3, x2    // x4 = 36 - 24 = 12
```

パラメタ`<b>`には即値も使用できます。

```
sub sp sp, #120   // sp -= 120
add x3, x1, #120  // x3 = x1 + 120
add x3, x3, #88   // x3 += 88
```

#### 論理演算

`and`命令と`orr`命令はビット単位の`AND`と`OR`を行います。使用法は
`add`と`sub`と同じです。

```
mov x1, 0b11001
mov x2, 0b10101

and x3, x1, x2    // x3 = x1 & x2 = 0b10001
orr x3, x1, x2    // x3 = x1 | x2 = 0b11101
orr x1, x1, x2    // x1 |= x2
and x2, x2, x1    // x2 &= x1

and x1, x1, #0b110    // x1 &= 0b110
orr x1, x1, #0b101    // x1 |= 0b101
```

#### 分岐

_分岐_ はあるアドレスへのジャンプを指す用語です。_分岐_ はPCを指定された
アドレスまたはラベルアドレスに変更します。無条件にラベルにジャンプする
には`b`命令を使用します。

```
b label   // labelにジャンプ
```

次のアドレスをリンクレジスタに格納してラベルにジャンプするには`bl`命令を
使用します。`ret`命令は`lr`のアドレスにジャンプします。

```
my_function:
    add x0, x0, x1
    ret

mov x0, #4
mov x1, #30
bl  my_function     // lr = `mov x3, x0のアドレス
mov x3, x0          // x3 = x0 = 4 + 30 = 34
```

`br`命令と`blr`命令は各々`b`と`bl`と同じですがレジスタが持つ
アドレスにジャンプします。

```
ldr x0, =label
blr x0            // bl label と同じ
br  x0            // b  label と同じ
```

#### 条件分岐

`cmp`命令は2つのレジスタの値、または、レジスタの値と即値を比較して
`bne` (branch not equal), `beq` (branch if equal), `blt` (branch
if less than) などの条件分岐命令のためのフラグをセットします (ref:
C1.2.4)。

```
// x1と等しくなるまでx0に１を足し、等しくなったら`function_when_eq`を
// 呼び出し、ついでexitを実行する
not_equal:
    add x0, x0, #1
    cmp x0, x1
    bne not_equal
    bl  function_when_eq

exit:
    ...

// x0 == x1 のときに呼ばれる
function_when_eq:
    ret
```

即値を使用した例

```
cmp x1, #0
beq x1_is_eq_to_zero
```

分岐が選択されなかった場合は単に次の命令を実行することに注意してください。

#### Rustとのインタフェース

ここで再び`aarch64`サブディレクトリに移動して残りのファイルの確認を
始めてください。ライブラリの各ファイルの簡単な説明は以下のとおりです。

- `asm.rs` - 内部的に使用するインラインアセンブリを関数としてラップ
- `macros.rs` - このライブラリで使用するマクロを定義
- `regs.rs` - マクロを使ってレジスタを定義し、そのインタフェースを提供
- `sp.rs` - スタックポインタへのアクセス
- `vmsa.rs` - 仮想メモリのサポート（後述）
- `lib.rs` - 上記のモジュールをインクルード。`current_el()`などの便利な
  関数を持つ

たとえば、`sp.rs`の`get()`関数と`set()`関数を使うと任意の時点で現在の
スタックポインタを取得したり変更したりすることができます。同様に、
`lib.rs`の`current_el()`関数は _カレント例外レベル_ と呼ばれている
CPUが現在実行している例外レベルを返します。

#### まとめ

ARMv8命令セットにはまだまだ多くの命令があります。これらをベースにすれば
残りの命令のほとんどを簡単にピックアップできるはずです。命令は (ref: C3)
に記載されています。上で紹介した命令の簡潔なリファレンスについては、Griffin Dietz氏による[ISAチートシート](https://tc.gts3.org/cs3210/2020/spring/r/AArch64-ISA-Cheat-Sheet.pdf)を
参照してください。先に進む前に次の質問に答えてください：

**質問 (asm-memcpy): ARMv8アセンブリでmemcpyはどう書きますか**
> ソースアドレスが`x0`に、ディスティネーションアドレスが`x1`に、
> コピーするバイト数（これは非ゼロの8の倍数であることが保証されている）
> が`x2`に置かれているとすると、ARMv8アセンブリで`memcpy`をどのように
> 実装しますか。`ret`することも忘れないでください。

    ヒント
    わずか6、7行で実装できます。

```
memcpy:
    ldr  x3, [x0], #8
    str  x3, [x1], #8
    subs x2, #8
    bne  memcpy
exit:
    ret
```

**質問 (asm-movk): どのように`ELR_EL1`に`0xABCDE`を書くか**
> EL1で実行していると仮定するとARMv8アセンブリを使用してどのようにして
> `ELR_EL1`に即値`0xABCDE`を書きますか

    ヒント
    3命令が必要です。

```
mov   x0, 0xBCDE
movk  x0, 0xA, LSL #16
msr   ELR_EL1, x0
```

**質問 (asm-cbz): cbz命令は何をしますか**
> (ref: C6.2.36) の`cbz`命令のドキュメントを読んでください。
> この命令は何をしますか、どのように使いますか。

**質問 (init): init.rsは何をしていますか**
> ラボ3まで`kern/src/init/init.s`をカーネルで実行される最初のコードと
> して使っていました。ここからはその役目は`kern/src/init.rs`に置き
> 換わりました。特に、`_start`関数はRaspberry Piの起動時に`0x80000`
> 番地にあり、ファームウェアはシステムの初期化を終えるとすぐにこの
> アドレスにジャンプします。まもなくこのファイルを修正してEL1に切り替え、
> 例外ベクタをセットアップするすることになります。
>
> `kern/src/init.rs`のコードをすべて読んでください。ファイルの
> すべての関数について、そのコードが何をしているのかを説明して
> ください。たとえば、`_start`関数の説明は次のように言うことができます。
>
> 「`MPIDR_EL1`レジスタの[7:0]ビット (ref: D7.2.74) を読み込んで
> (`Aff0`)、現在コードを実行しているコア番号を取得する。番号が0の場合、
> KERN_STACK_BASE(0x80_000) をスタックポインタに設定して、kinit() を
> 呼び出す。」

    ヒント
    まだよく知らない命令やレジスタについてはマニュアルを参照してください。

    ヒント
    `init.rs`をレビューするには`aarch64`ライブラリと
    `kern/src/param.rs`が必要になります。

### サブフェーズ C: EL1への切り替え

このサブフェーズではEL2からEL1に切り替えるためのRustコードを書きます。
主に`kern/src/init.rs`と`kern/src/main.rs`で作業します。このサブ
フェーズに進むのは前のサブフェーズの質問に答えてからにすることを
勧めます。

#### 現在の例外レベル

すでに説明したようにカーネルが呼び出された時、CPUはEL2で動作している
はずです。`kmain()`で現在の例外レベルを表示することでこのことを確認して
ください。`current_el()`を呼び出すには`unsafe`を使用する必要があることに
注意してください。EL1に正常に切り替えたことを確認できたらこの呼び出しは
削除します。`current_el()`は`lib/aarch64`ライブラリにあります。依存問題を
解決するにはこのライブラリを追加する必要があります。

#### 切り替え

EL1に切り替えるためのアセンブリコードを完成させる時間です。
`kern/src/init.rs`で次の行を見つけてください。

```rust
// FIXME: eret to itself, expecting current_el() == 1 this time
```

この行の上には次のコードがあります。

```rust
SPSR_EL2.set(
    (SPSR_EL2::M & 0b0101)
    | SPSR_EL2::F
    | SPSR_EL2::I
    | SPSR_EL2::D
    | SPSR_EL2::A,
);
```

前のサブフェーズで学んだのでこれらのビットが何をするのかを知っている
はずです。特に、`SPSR_EL2`のどのビットをセットするとその後に`eret`
したらその結果どうなるかを知っているはずです。

`FIXME`を適切なコードに置き換えることで切り替えルーチンを完成させて
ください。EL1に切り替えた際、CPUが適切な例外レベルで再帰的に
`switch_to_el1`にジャンプして、内部チェックの`current_el() == 2`を
バイパスして`kmain()`に進むことを確認してください。このルーチンを
完了するのに必要なコードは2行です。例外レベルを下げる唯一の方法は
`eret`であることを思い出してください。ルーチンを完了したら今度は
`current_el()`が`1`を返すことを確認してください。

**ヒント**
> 例外からリターンする際にPCをセットするにはどのレジスタを使用しますか.

#### サブフェース D: 例外ベクタ

このサブフェーズでは例外ベクタと例外ハンドラを設定してインストールします。
これはカーネルが任意の例外や割り込みを処理できるようにするための第一歩と
なります。作成した例外ベクタと例外ハンドラは`brk #n`命令に応答して起動する
小さなデバッガを実装することでテストします。主に`kernel/src/init/vectors.s`,
`kernel/src/traps.rs`, `kernel/src/traps`ディレクトリで作業します。

#### 概要

ベクトルテーブルは16個のベクトルで構成され、各ベクトルは最大16個の一連の
命令であることを思い出してください。`vectors.s`の中にこれらのベクタ用の
スペースを確保し、`vectors`ラベルをテーブルの先頭に配置しました。この
`vectors.s`ファイルは`init.rs`で`global_asm!`マクロによりインクルード
されます。あなたの課題は16個のベクタでテーブルを埋め、最終的に例外が
発生した際に`kernel/src/traps.rs`にある`handle_exception`Rust関数が適切な
引数で呼び出されるようにすることです。すべての例外は`handle_exception`
関数にルーティングされます。この関数は例外がなぜ発生したかを判断し、
必要に応じてより上位のハンドラに例外をディスパッチします。

#### 呼び出し規約

Rustで宣言された`handle_exception`関数を適切に呼び出すにはその関数が
どのように呼び出されることを期待しているかを知っておく必要があります。
特に、その引数である`info`, `esr`, `tf`の値を関数はどこで見つけるのか、
関数が呼び出された後のマシンの状態についてどんな約束があるのか、関数を
呼び出した場所にどのように戻るのかを知っておく必要があります。

この外部の関数を呼び出す方法を知るという問題は（ラボ3でC言語とRust言語
の間で行ったような）ある言語が別の言語を呼び出す際にはいつでも発生します。
すべての言語が関数をどのように呼び出すかを知っておかなくても良いように
_呼び出し規約_ が確立されています。_呼び出し規約_（または、
_プロシジャ呼び出し規約_）とは以下を定めた一連の規則のことです。

- **どのように関数に引数を渡すか**

  AArch64では最初の8つの引数は左から右の順でレジスタ`r0`...`r7`で渡します。

- **どのように関数から値を返すか**

  AArch64では最初の8つの返り値はレジスタ`r0`...`r7`で渡されます。

- **関数はどの状態（レジスタ、スタックなど）を保存する必要があるか**

  レジスタは通常 _caller-saved_ と _callee-saved` に分類されます。

  _caller-saved_ レジスタは関数呼び出しの前後で保存されることは保証
  されていません。したがって、callerはレジスタ値を保存する必要がある
  場合は関数を呼び出す前にレジスタ値を保存する必要があります。

  逆に、_callee-saved_ レジスタは関数呼び出しの前後で保存されることが
  保証されています。したって、関数呼び出し中に対象のレジスタを使用したい
  場合、calleeはそのレジスタを使用する前にレジスタ値を保存し、リターン
  する前にそのレジスタ値を復元する必要があります。

  レジスタ値の保存と復元は通常、スタックへのpushとpopで行われます。

  AArch64ではレジスタ`r19`...`r29`と`SP`がcaller-savedで、残りの汎用
  レジスタはcallee-savedです。これには`lr` (`x30`) も含まれることに注意
  してください。SIMD/FPレジスタには複雑な保存規則があります。私たちの
  目的のためにはこれらはすべてcaller-savedであると言えば十分です。

- **どのように呼び出し元に帰るのか**

  AArch64では`lr`レジスタが _リンクアドレス_ （calleeがリターンする際に
  ジャンプすべきアドレス）を保持します。`ret`命令は`lr`に分岐するので
  通樹はそれで関数は終了します。

AArch64の呼び出し規約は公式の[プロシジャコール標準](https://tc.gts3.org/cs3210/2020/spring/r/AArch64-Procedure-Call-Standard.pdf)
ドキュメントと共に (guide: 9) でも説明されています。アセンブリから
`handle_exception` Rust関数を呼び出す場合はこの呼び出し規約を確実に
守る必要があります。

**注記: Rustはどの規約を使えばよいかをどのようにして知るのか**
> 呼び出し規約を厳密に守ると関数呼び出しや関数本体のあらゆる最適化が
> できなくなります。そのため、Rustの関数はデフォルトでは特定の呼び出し
> 規約に従うことが保証されていません。対象となるプラットフォームの呼び
> 出し規約に完全に従うように関数をコンパイルするには`extern`関数修飾子を
> 使用します。`handle_exception`はすでに`extern`として宣言しているので
> Rustが関数を適切にコンパイルすることを保証することができます。

#### ベクタテーブル

ベクタテーブルを埋めるための手助けをするマクロ `HANDLER source, kind` を
用意しました。このマクロは次の有効なベクタエントリにアラインする8命令に
展開します。`HANDLER a, b`を"命令"として使用すると`.macro`と`.endm`の
間に展開されます。すなわち、

```rust
vectors:
    HANDLER 32, 39
```

は、次のように展開されます。

```rust
vectors:
    .align 7
    stp   lr, xzr, [SP, #-16]!
    stp   x28, x29, [SP, #16]!

    mov   x29, #32
    movk  x29, #39, LSL #16
    bl    context_save

    ldp   x28,x29, [SP], #16
    ldp   lr, xzr, [SP], #16
    eret
```

展開されたコードは`lr`, `xzr`, `x28`, `x29`をスタックにプッシュし、
下位16ビットが`source`、上位16ビットが`kind`となる32ビットの値を
`x29`に作成し、アセンブリ関数`context_save`（`vectors.s`で`vectors`の
上で宣言されています）を呼び出します。この関数が復帰したらスタックから
保存した4つのレジスタを復元し、最後に例外から復帰します。

`context_save`関数は今のところ何もしません。単に下の`context_restore`
からの`ret`に進むだけです。後で関数`context_save`を修正してRust関数
`handle_exception`を正しく呼び出すようにします。

#### Syndrome構造体

_同期例外_（命令の実行または試行によって発生する例外）が発生すると
CPUは例外の原因を記述する値をシンドロームレジスタ（`ESR_ELx`）にセット
します (ref: D1.10.4)。`kernel/src/traps/syndrome.rs`にシンドローム値を
解析して意味のある`Syndrome enum`に変換する構造体を設定しました。この後
すぐに`ESR_ELx`値を`esr`パラメータとしてRust関数に渡すコードを書くことに
なります。そして、`Syndrome::from(esr)`を使って次に何をすべきかを決定する
シンドロームの値を解析します。

#### Info構造体

Rust関数`handle_exception`は第1パラメータとして`Info`構造体を受け取ります。
この構造体には2つの16ビットフィールドがあります。最初のフィールドはソースに、
2番目のフィールドは例外の種類に対応します。もうおわかりだと思いますが
これは`HANDLE`マクロが`x29`で設定する`32ビット`値そのものです。この値を
第1パラメータとして渡すには`context_save`コードブロック内で`x29`を`x0`に
移動する必要があります。さらに、`Info`構造体が正しく作成されるように
正しいエントリに対して正しく`HANDLE`を呼び出すようにしてください。

#### 実装

これで予備的な例外処理コードを実装する準備ができました。最初に扱う例外は
`brk`例外（ソフトウェアブレークポイント）です。この例外が発生した場合は
理論的にはそれを実行した時点でのマシンの状態を調べることができるシェルを
起動することになります。

`main.rs`に`brk`の呼び出しを挿入することから始めます。インラインアセンブリを
使う代わりに`aarch64`ライブラリの`asm.rs`で定義されている`brk`マクロを
呼び出すことができます。

その後は次のように進めます。

1. **`HANDLE`マクロを使って`vectors`テーブルを埋める**

    エントリが`Info`構造体を正しく作成するようにしてください。
    (guide: 10.4) を参照してエントリの順序をチェックしてください。
    ハンドラの`source`と`kind`は`src/traps.rs`にある`Source`と`Kind`
    enumにマッチするようにしてください。

2. **`context_save`内で`handle_exception`関数を呼び出す**

    必要に応じてcaller-savedレジスタを保存/復元して適切なパラメータを
    渡すようにしてください。今のところ`tf`パラメータには`0`を渡しておく
    ことができます。これは後で使うことになります。引数に何を渡すかは
    `src/traps.rs`を参照してください。

    **注意**: AArch64では`SP`レジスタをロード/ストアの一部として使用
    する場合、常に16バイトアラインにする必要があります。常に`SP`を
    16バイトアラインに保つようにしてください。

3. **`init.rs`にある次のコメントでマークされている位置で正しい`VBAR`レジスタをセットアップする**

    ```rust
    // FIXME: load `vectors` addr into appropriate register (guide: 10.4)
    ```

4. **この時点で例外が発生するたびに`handle_exception`関数が呼び出される
  はず**

    `handle_exception`でパラメタ`info`と`esr`の値を表示し、それらが期待
    通りであることを確認してください。その後、ハンドラ内で無限ループ
    させます。ループの中では`aarch64::nop()`を呼び出して最適化で削除
    されないようにします。例外ハンドラから適切に戻るにはさらにコードを
    書く必要がありますが、今は単にループさせることにします。これは次の
    サブフェーズで修正することになります。

5. **`Syndrome::from()`メソッドと`Fault::from()`メソッドを実装する**

    前者は後者を呼び出す必要があります。これらを正しく実装するには (ref:
    D1.10.4, ref: Table D1-8) を参照する必要があるでしょう。テーブルの
    "ISS encoding description"をクリックすると特定の例外クラスの
    シンドロームのデコード方法と`Fault`のデコード方法の詳細がわかります。
    たとえば、`brk 12`は`Syndrome::Brk(12)`とデコードされることが確認できる
    はずです。同様に、`svc 77`は`Syndrome::Svc(77)`と解析します。いくつかの
    例外の32ビット値を省略していたり、同じ例外だが異なる例外クラスで発生
    した例外は合体させていることに注意してください。

    **警告**: aarch64ライブラリを使用してください
    インラインアセンブリを使用したり、各レジスタで生のビット操作を
    行なったりせずに`aarch64`ライブラリで定義されているレジスタや関数を
    使用すると便利です。`REG_NAME::get_value(raw_value, REG_NAME::MASK)`
    関数が便利なことがわかるでしょう。

6. **`brk`例外が発生したらシェルを起動する**

    `brk`例外の検出には`handle_exception`の`Syndrome::from()`メソッドを
    使用してください。このような例外が発生したらシェルを起動します。
    シェルを区別するために異なるシェルプレフィックスを使用するとよいで
    しょう。`Syndrome::from()`の呼び出しは同期例外に対してだけにするべきで
    あることに注意してください。それ以外の場合は`ESR_ELx`レジスタが有効な
    値を保持している保証はないからです。

    この時点でシェルを変更して新しいコマンド`exit`を実装する必要があります。
    `exit`が呼ばれたらシェルはループを終了して復帰する必要があります。
    これにより後で`brk`例外から抜けることができるようになります。この変更の
    ため、カーネルが終了してクラッシュするのを防ぐためにkmain内の`shell()`
    への呼び出しを`loop { }`でラップする必要もあります。

これらの実装が終了したら`kmain`での`brk 2`命令はシンドローム`Brk(2)`、
ソース`CurrentSpElx`、種別`Synchronous`の例外となり、`handle_exception`
関数にルーティングされ、デバッグシェルが起動するはずです。シェルから
`exit`が呼ばれるとシェルは終了し、例外ハンドラは無限ループを開始する
はずです。

先に進む前に、他の同期例外を正しく検出していることを確認すべきです。
`svc 3`などの他の例外を引き起こす命令の呼び出しを試してみる必要が
あります。また、物理メモリの範囲外のアドレスにジャンプすることで
意図的にデータアボートや命令アボートを引き起こしてみることも必要です。

すべてが期待通りに動いたら、次の段階に進んでください。

### サブフェーズ E: 例外からの復帰

このサブフェーズではあらゆる種類の例外から正しく戻るためのコードを記述します。
主に`kern/init/vectors.s`、`kern/src/traps.rs`、`kern/src/traps`ディレクトリで
作業します。

#### 概要

今`handle_exception`の無限ループを削除するとRaspberry Piは例外ハンドラに
繰り返し入る例外ループに入るか、デバッグシェルから抜けるときに完全に
クラッシュします。これは、例外ハンドラが以前に実行されていたコードに戻る
際にプロセッサの状態（主にレジスタ）がコードに関係なく変更されているためです。

例として、次のアセンブリを考えてみます。

```
1: mov x3, #127
2: mov x4, #127
3: brk 10
4: cmp x3, x4
5: beq safety
6: b   oh_no
```
`brk`例外が発生すると、例外ベクタが呼び出され、最終的に`handle_exception`が
呼び出されます。Rustでコンパイルされた`handle_exception`関数はその処理に
（特に）`x3`と`x4`レジスタを使用します。例外ハンドラが`brk`呼び出しの場所に
戻った場合、`x3`と`x4`の状態は不明であり、5行目の`beq safety`命令が`safety`に
分岐するかは保証されません。

つまり、例外ハンドラがそれが望むようにマシンを使用できるようにするには
例外ハンドラを呼び出す前にすべての処理コンテキスト（レジスタなど）を保存
しておく必要があります。そして、ハンドラが復帰した際にそれまで実行されて
いたコードが問題なく実行し続けるように処理コンテキストを復元する必要が
あります。この処理コンテキストを保存/復元するプロセスは**コンテキストスイッチ**
として知られています。

**なぜコンテクスト _スイッチ_ なのか？**
> _スイッチ_ という言葉が含まれているので少しごまかされるかもしれません。
> 結局のところ、同じコンテキストにに戻るだけではないのですか？
>
> 実際、同じコンテキストに戻りたいことはほとんどありません。通常は戻る前に
> コンテキストを変更してCPUがほんの少し異なる処理を実行するようにしたいと
> 考えます。たとえば、プロセススイッチングを実装する場合、CPU時間を多重化
> するためにあるプロセスのコンテキストを別のプロセスのコンテキストに入れ
> 替えます。システムコールを実装する場合はレジスタの値を変更して戻り値を
> 注入します。そして最後に、ブレークポイント例外から復帰する場合は`ELR`の
> リターアドレスを変更して同じ命令ではなく次の命令が実行されるようにする
> 必要があります。

この後すぐに _トラップフレーム_ として知られる構造体にすべての処理
コンテキストを保存するコードを記述します。`kern/src/traps/frame.rs`にある
`TrapFrame`構造体の定義を完成させRustからトラップフレームにアクセスして
変更できるようにします。また、トラップフレームの保存/復元をし、`tf`
パラメータとして`handle_exception`関数にトラップフレームへのポインタを
渡すためのアセンブリを記述します。

#### トラップフレーム

_トラップフレーム_ はすべての処理コンテキストを保持する構造体に付けられる
名前です。「トラップフレーム」という名前は「トラップ」という用語に由来します。
トラップとはイベントが発生した際にプロセッサがより高い特権レベルを呼び出す
メカニズムを表す一般的な用語です。プロセッサがより高い特権レベルに
_トラップ_ するといいます。

トラップフレームを作成する方法は数多くありますがどのアプローチも実質的には
同じです。つまり、実行に必要なすべての状態をメモリに保存することです。
ほとんどの実装はすべての状態をスタックにプッシュします。すべての状態を
プッシュするとそのスタックポインタ自体がトラップフレームへのポインタに
なります。私たちもこのアプローチを取ります。

今のところ、Cortex-A53の完全な実行状態は以下で構成されます。

- **x0..x30 - 31個の汎用レジスタすべての64ビットのすべて**
- **q0..q31 - すべてのSIMD/FPレジスタの128ビットのすべて**
- **TRPDR - 64ビットの「スレッドID」レジスタ**

    これは例外ソースがレベル`s`にある場合、`TPIDE_ELs`に格納されています。
- **sp - スタックポインタ**

    これは例外ソースがレベル`s`にある場合、`SP_ELs`に格納されています。
- **PSTATE - プログラムステート**

    これは`ELx`で例外が発生した場合、`SPSR_ELs`に格納されています。
- **pc - プログラムカウンタ**

    レジスタ`ELR_ELx`は _優先リンクアドレス_ を格納しています。これは
    例外を補足した際にCPUが持っていたPCの場合もあれば総でない場合も
    あります。通常は、`ELF_ELx`は例外を補足した際のPCまたは`pc + 4`の
    いずれかです。

例外ハンドラを呼び出す前に関連するレジスタをスタックにプッシュすることに
よりこのコンテキストを _すべて_ トラップフレームに保存し、ハンドラが復帰する
際にスタックからポップすることでトラップフレームを復元する必要があります。
状態をすべて保存した後、スタックは次のようになるはずです。

![トラップフレーム](trap_frame.png)

各レジスタが`_ELx`か`_ELs`を使用しているかを再確認してください。トラップ
フレームの`SP`と`TPIDR`はターゲットではなくソースのスタックポインタと
スレッドIDであることに注意してください。例外の最終的な発生源は`EL0`だけ
なので`SP_EL0`と`TPIDR_EL0`レジスタを保存/復元する必要があります。すべての
状態をプッシュした時、CPUの本当の`SP`（例外ベクタにより使用されるもの）は
トラップフレームの先頭を指しています。

最後に、トラップフレームへのポインタを`handle_exception`の第3引数として
渡します。引数の型は`&mut TrapFrame`です。`TrapFrame`は
`kern/src/traps/frame.rs`で宣言されています。トラップフレームのレイアウトに
正確に一致するように`TrapFrame`構造体を定義する必要があります。

**スレッドIDとは何か**
> `TPIDR`レジスタ(`TPIDR_ELx`)はOSが現在実行中のものに関する識別情報を
> 格納するためのレジスタです。後でプロセスを実装する際にはこのレジスタに
> プロセスのIDを格納します。今のところは将来のためにこのレジスタの保存/
> 復元をしておきます。

#### 優先例外リターンアドレス

`ELx`で例外が発生するとCPUは _優先リンクアドレス_ （または、_優先例外リターンアドレス_）を
`ELR_ELx`に格納します。この値は (ref: D1.10.1) で次のように定義されています。

1. 非同期例外の場合、割り込みを受けた結果、実行されなかった、または実行が
  完了しなかった最初の命令のアドレス
2. システムコール以外の同期例外の場合、例外を発生させた命令のアドレス
3. 例外を発生させた命令の場合、例外を発生させた命令に続く命令のアドレス

`brk`命令は2番目のカテゴリに入ります。そのため、`brk`命令の後に実行を
続行したい場合、復帰する前に次の命令のアドレスが`ELR_ELx`に含まれるように
する必要があります。AArch64ではすべての命令が32ビット幅なので個のアドレスは
`ELR_ELx + 4`です。

#### 実装

`kern/init/vectors.s`にある`context_save`ルーチンと`context_restore`ルーチンの
実装から始めます。`context_saveルーチン`は関連するすべてのレジスタをスタックに
プッシュし、第3引数としてトラップフレームへのポインタを渡して`handle_exception`
を呼び出します。次に、`context_restore`を実装します。ここではコンテキストの
復元以外にすることはありません。

`HANDLER`マクロによって生成される命令で`x28`, `x29`, `x30(lr)`,
`x31(xzr)`はすでに保存/復元されていることに注意してください。
`context_{save,restore}`ルーチンでこれらのレジスタの保存/復元は必要ありませんが
トラップフレームにはこれらのレジスタが含まれていなければなりません。
技術的には`xzr`レジスタは常に0を含んでいるので保存/復元を行う必要はありません。
単にSPを16バイトアラインにするために保存します。

コンテキストスイッチのパフォーマンスへの影響を最小限に抑えるには次のように
レジスタをスタックにプッシュ／ポップする必要があります。

```
// レジスタ `x1`, `x5`, `x12`, `x13` をpush
stp x1, x5, [SP, #-16]!
stp x12, x13, [SP, #-16]!

// レジスタ`x1`, `x5`, `x12`, `x13` をpop
ldp x12, x13, [SP], #16
ldp x1, x5, [SP], #16
```

これらのルーチンを実装したら`kern/src/traps/frame.rs`で`TrapFrame`の定義を
完成させます。フィールドの順序とサイズが作成したトラップフレームと完全に
一致していることを確認し、それへのポインタを`context_save`に渡してください。

最後に、`handle_exception`の無限ループを削除し、`brk`例外から復帰する前に
トラップフレームのELRに4を足してください。コンテキストスイッチの実装に
成功したら、デバッグシェルから`exit`した後もカーネルは通常通り実行される
はずです。準備ができたら、次のフェーズに進んでください。

**注記: トラップフレームレイアウト**
> トラップフレームは図と完全に一致する必要はありませんが図にある
> すべてのデータを含む必要があります。

**警告: `q0` ... `q31`**
> `qn`レジスタは128ビット幅であることを忘れないでください。

**ヒント**
> `handle_exception`を呼び出すにはトラップフレームの一部 _ではない_
> レジスタを保存/復元する必要があります。

**ヒント**
> Rustには`u128`と`i128`の2つの128ビット整数型があります。

**ヒント**
> 特殊レジスタの読み書きには`mrs`命令と`msr`命令を使います。

**ヒント**
> `context_save`ルーチンは42命令です。

**ヒント**
> `TrapFrame`には6つのフィールド（そのうちの2つは配列）があり、
> サイズは`xzr`レジスタを除くと792バイトです。

**質問 (layz-float): 浮動小数点レジスタを遅延ロードする方法は**
> 128ビットのSIMD/FPレジスタの保存/復元は非常に高価です。
> `TrapFrame`の792バイトのうち512バイトを占めます。これらのレジスタは
> 例外のソース、または、コンテキストスイッチのターゲットで実際に使用
> されている場合にのみ保存／復元するのが理想的です。
>
> AArch64アーキテクチャではこれらのレジスタの使用を選択的に有効/無効に
> することができます。SIMD/FPが無効の場合、レジスタを使用する命令は
> トラップします。この機能を使ってSIMD/FPレジスタの遅延ローディングを
> 実装するにはどうしたらよいですか。ここではSIMD/FPレジスタとSIMD/FP
> 命令が自由に使用できるが、SIMP/FPが実施に使用されている場合にのみ
> コンテキストスイッチでレジスタを保存/復元します。特定の例外が発生した
> ときに何をするか、`TrapFrame`構造体を変更する必要があるか否か、
> 新たに保存する必要がある状態は何かについて具体的に説明してください。

## フェーズ 2: それはプロセス

このフェーズではユーザレベルのプロセスを実装します。まず、プロセスの状態を
保持する`Process`構造体を実装からスタートします。次に、最初のプロセスを起動
することによりシステムをブートストラップします。次に、tickベースのラウンド
ロビンスケジューラを実装します。そのためにまず割り込みコントローラドライバを
実装してタイマー割り込みを有効にします。次に、タイマー割り込みが発生したら
スケジューラを起動し、次のプロセスへのコンテキストスイッチを実行します。
最後に、最初のシステムコールである`sleep`を実装します。

このサブフェーズを完成させると最小限ですが完全なマルチタスクオペレーティング
システムを構築したことになります。今のところ、プロセスはカーネルや他の
プロセスと物理メモリを共有します。次のフェーズでは仮想メモリを有効にして、
プロセスを互いに隔離し、信頼できないプロセスからカーネルのメモリを保護します。

### サブフェーズ A: プロセス

このサブフェーズでは`kern/src/process/process.rs`にある`Process`構造の実装を
完成させます。次のサブフェーズではこの実装を使用して最初のプロセスを開始します。

#### プロセスとは何か

プロセスとはカーネルにより実行、管理、保護されるコードとデータのコンテナです。
それは非カーネルコードが実行される単一ユニットです。コードが実行している場合、
それはプロセスの一部として実行しているか、カーネルの一部として実行しているかの
いずれかです。特に研究の世界では、多くのオペレーティングシステムアーキテクチャ
が存在しますがそれらはすべてプロセスという概念とほぼ同じ概念を持っています。

プロセスは通常、カーネルがシステムの安定性とセキュリティを確保できるように、
縮小された権限（私たちのOSでは`EL0`）で実行されます。あるプロセスがクラッシュ
した場合、それにより他のプロセスがクラッシュしたり、マシン全体がクラッシュ
したりすることは望みません。また、プロセスが互いに干渉できることも望みません。
あるプロセスがハングアップした場合、他のプロセスが進行不能になるようなことは
望みません。プロセスは _隔離_ を提供します。つまり、プロセスは互いにほとんど
独立に動作します。皆さんはプロセスのこのような属性を毎日みていると思います。
ウェブブラウザがクラッシュしたりハングしたときにマシンの他の部分もクラッシュ
したりハングしたりしますか・

プロセスの実装とは信頼できないコードやデータを保護、隔離、実行、管理するための
構造やアルゴリズムを作成することです。

#### プロセスには何があるか

プロセスを実装するにはプロセスのコードとデータだけでなく、複数のプロセスを適切に
管理・隔離できるようにするための補助情報も記録する必要があります。つまり、
プロセスの次の要素を記録します。

- **スタック**

    各プロセスは実行するために個別にスタックを必要とします。プロセスを実装する
    際にはプロセスのスタックとして使用するのに適したメモリセクションを割り当てる
    必要があります。そして、プロセスのスタックポインタがこのメモリ領域を指す
    ようにブートストラップする必要があります。

- **ヒープ**

    互いに独立した動的メモリ割り当てを可能にするために、各プロセスは独自の
    ヒープも持ちます。ヒープは空で始まりますがシステムコールを介して要求に
    応じて拡張することができます。ラボ4ではヒープは実装せず、スタックだけを
    必要とするユーザプログラムをサポートします。

- **コード**

    プロセスはコードを実行していない限りあまり役に立ちません。したがって、
    カーネルはプロセスのコードをメモリにロードし、適切なときに実行する必要が
    あります。

- **仮想アドレス空間**

    プロセスがカーネルのメモリや他のプロセスのメモリにアクセスできるのは
    望まないので、各プロセスは仮想メモリを使って個別の仮想アドレス空間に
    閉じ込められます。

- **スケジューリング状態**

    通常、CPUコアの数よりも多くのプロセスが存在します。CPUは一度に1つの命令
    ストリームしか実行できないので、カーネルはCPU時間（そしてそれゆえ命令
    ストリーム）を多重化してプロセスを並行して実行する必要があります。どの
    プロセスがいつどこで実行されるかを決めるのはスケジューラの仕事です。
    これを正しく行うために、スケジューラはプロセスがスケジューリング可能な
    状態であるかを知る必要があります。_スケジューリング状態_ はこれを追跡
    します。

- **実行状態**

    CPU時間を複数のプロセスで正しく多重化するためにはプロセスの実行状態を
    CPUから切り離したときに保存し、再びCPUに付け替えたときに復元するように
    する必要があります。実行状態を維持するために使用する構造体がトラップ
    フレームであることはすでにわかるでしょう。各プロセスはその実行状態を
    適切に維持するためにトラップフレームを維持します。

プロセスのスタック、ヒープ、コードはプロセスの物理的な状態のすべてを構成
します。残りの状態はプロセスの隔離、管理、保護のために必要です。

`kernel/src/process/process.rs`にある`Process`構造体がこれらの情報をすべて
保持します。当分の間、全てのプロセスはメモリを共有するため、プロセスのヒープ、
コード、仮想アドレス空間のフィールドを見ることはないでしょう。これらは後で
課題として処理することになります。

**質問 (kernel-distruct): プロセスはカーネルを信頼しなければならないのか**
> カーネルがプロセスに対して明確に不信感を抱いていることは明らかですが、
> プロセスはカーネルを信頼しなければならないでしょうか。もしそうなら、
> プロセスはカーネルに何を期待していますか。

**質問 (isolated-stacks): 2つのプロセスがスタックを共有すると何が問題になるか**
> 2つのプロセスが平行に実行し、スタックを共有していると想像してください。
> 第1に2つのプロセスがスタックを共有するとはどういうことですか。第2に
> プロセスはかなり早い段階でクラッシュする可能性が高いのは何故ですか。第3に
> たとえスタックを共有していたとしてもスタックの共有のためにクラッシュする
> ことは決してないプロセスのプロパティを定義してください。言い換えれば、
> 並行して実行しスタックを共有しているが、この共有の結果としては決して
> クラッシュしない２つのプロセスとはどのようなものですか。

#### 実装

それでは`kern/src/process/process.rs`にある`Process`構造の実装から開始
しましょう。始める前に`kern/src/process/stack.rs`に提供している`Stack`
構造体の実装を読んでください。どのようにこの構造体を使用して新しいスタックを
確保して、新しいプロセス用のスタックへのポインタを取得するかを理解してください。
次に、`kern/src/process/state.rs`にあるスケジューリングの状態を追跡する
ために使用することになる`State`構造体の実装を読んでください。プロセスを
スケジューリングする際に異なるバリアントをどのように解釈するかを推理して
みてください。

最後に、`Process::new()`メソッドだけを実装してください。実装は簡単です。
状態を追跡することに関して複雑なことは何もありません。プロセス構造体の
実装は後で完成させます。準備ができたら次のサブフェーズに進んでください。

**質問 (stack-drop0: スタックのメモリはどのように回収されるか**
> `Stack`構造体は作成される際、16バイトアラインの1MiBのメモリブロックを
> 割り当てます。このメモリを所有する`Process`が存在しなくなったとき、この
> メモリが解放されることを何が保証しますか。

**質問 (lazy-stacks): スタックメモリの遅延割り当てはどのようにできるか**
> `Stack`構造体は、プロセスが実際にスタックを使うか、どのくらい使うかに
> 関係なくスタック用に1MiBのメモリを割り当てます。仮想メモリのことを考えて、
> 仮想メモリを使用してスタック用のメモリを遅延割り当てすることで必要になる
> までスタックにメモリをまったく、あるいは最小限のメモリだけ使用させるように
> する方法はありますか。

**質問 (stack-size): プロセスはスタックサイズをどのように増やすことができるか**
> プロセスによっては1MiBよりもはるかに大きなスタックスペースを必要としますが、
> 私たちのシンプルな設計ではすべてのプロセスに1MiBちょうどのスタックスペースを
> 割り当てます。プロセスが動的メモリ割り当てにアクセスできると仮定すると、
> プロセスはどのようにスタックサイズを増やすことができますか。プロセスが
> 実行する命令について具体的に説明してください。

### サブフェーズ B: 最初のプロセス

このサブフェーズでは最初のユーザ空間（`EL0`）プロセスを開始します。主に
`kern/src/process/scheduler.rs`と`kern/src/main.rs`で作業します。

#### コンテキストスイッチングプロセス

プロセス間のコンテキストスイッチを可能にする作業のほとんどはすでに終わって
います。例外に応答してプロセス間でコンテキストスイッチするには次のようにします。

1. トラップフレームを現在のプロセスのトラップフレームとしてその`context`
  フィールドに保存する。
2. 次に実行するプロセスのトラップフレームをその`context`フィールドから復元する。
3. どのプロセスが実行中かを追跡するためにスケジューリング状態を変更する。

残念ながら、最初のプロセスにコンテキストスイッチするにはこの手順から少し外れる
必要があります。最初のプロセス以前に上記のステップのいずれかを実行するのは
正しくありません。それがどれかわかりますか。

最初のプロセス以前にこの手順を踏むとどうなるか見てみましょう。まず、コンテキスト
スイッチを促す例外が発生します。これがプロセススケジューラを駆動するタイマー
割り込みになることは後で説明します。ここでステップ１に従います。つまり、例外に
応答して現在のプロセスの`context`フィールドに現在のトラップフレームを格納
します。しかし、現在のプロセスはまだ存在しないことに注意してください。そして
次にステップ2の一部として次のプロセスの`context`を復元してリターンします。

プロセスの実行中に例外が発生したわけではないので、私たちが保存し、後で復元する
トラップフレームはプロセス自体とはほとんど関係がありません。言い換えれば、
プロセスのトラップフレームを無関係なもので上書きしてしまったことになります。
したがって、まず最初に有効なプロセスのトラップフレームがなければ、ステップ1を
実行することはできません。つまり、最初のプロセスに適切にコンテキストスイッチ
するにはそのプロセスがすでに実行中である必要があります。さらに別の言い方を
すれば、最初のコンテキストスイッチが発生した後でないとコンテキストスイッチを
正しく実行できないということです。お手上げです。

これを回避するために最初のコンテキストスイッチを _偽装_ することにより
コンテキストスイッチをブートストラップすることにします。最初のプロセスの
トラップフレームをすでに書いた`context_save`ルーチンによるものではなく、
新しいプロセスのスタック上に手でトラップフレームを作成し直接`context_restore`
を呼び出すことで上記のステップ1を完全に回避します。一旦最初のプロセスが
実行されれば他のすべてのコンテキストスイッチは正常に動作します。

#### カーネルスレッド

私たちはまだコードをディスクからメモリにロードするメカニズムを構築していません。
仮想メモリを有効にしたらそのための手続きを実装する必要があります。今のところ、
カーネルとメモリを共有している間は単にカーネルのコードとデータを再利用する
ことができます。カーネルとプロセスがローカルデータ（スタック）を共有しない限り
（これはプロセスごとに新しいスタックを確保することにより怒らないことが保証
されています）、問題なく同時実行できます。さらに、Rustはプロセス間でデータ
競合が発生する可能性がないことを保証します。

プロセス間でメモリやその他のリソースを共有することはよくあることなので、
この種のプロセスには _スレッド_ という特別な名前があります。実際、スレッドとは
他のプロセスとメモリやその他のリソースを共有するプロセスに他なりません。

まもなく最初のプロセスを開始します。このプロセスはカーネルとメモリを共有する
ため _カーネルスレッド_ になります。そのため、この最初のプロセスを開始するのに
必要な作業は最小限です。コードとデータのすべてはすでにメモリ内にあるからです。

1. 「偽の」保存トラップフレームを設定することによりコンテキストスイッチを
  ブートストラップする。

2. `context_restore`を呼び出す。

3. `EL0`に切り替える。

必要なコードはごくわずかですが正しいものにするためには慎重な実装が必要である
ことがわかるでしょう。

**注記: _カーネルスレッド_ という用語には2️つの意味で使われています**
> _カーネルスレッド_ という用語は、（ユーザ空間で実装されているスレッドに
> 対して）カーネルで実装されているスレッドと、カーネル内で実行しているスレッド
> という2つのスレッドを指すのに使われています。これは不幸な名前の衝突ですが、
> 通常は、文脈によってどちらの意味かは明確です。簡単な経験則として、OSの開発に
> 関する議論でない限り、カーネルで実装されているスレッドに関する議論であると
> 考えるべきです。

#### 実装

`kern/src/main.rs`には新しいグローバル変数`SCHEDULER`があります。これは
`GlobalScheduler`型ですが単なる`Scheduler`のラッパーです。これらの型は両者とも
`kern/src/process/scheduler.rs`で定義されています。変数`SCHEDULER`はシステム
全体のスケジューラへのハンドルを提供します。

スケジューラを初期化し、最初のプロセスの実行を開始するには、`GlobalScheduler`の
`start()`メソッドを呼び出す必要があります。ここでの課題は`start()`メソッドを
実装することです。

実装には次をすることが必要です。

1. パラメータを取らずシェルを起動する`extern`関数を作成する。

    プロセスが最初に実行されるときにこの関数が呼び出されるように手配します。
    この関数は好きな場所に書くことができます。ディスク上のバイナリにバック
    アップされたプロセスを起動できるようになったらこの関数は削除します。

2. `start()`で新しい`Process`を作成し、保存トラップフレームを設定する。

    プロセスのトラップフレームを設定して後で`context_restore`によりCPUに
    復元された際に、`extern`関数が実行され、プロセスのスタックポインタが
    プロセスのスタックの上端を指し、プロセスがAAarch64実行状態の`EL0`で
    実行され、次のセクションで`EL0`からのタイマー割り込みを処理できるように
    現在の`EL1`に対してIRQ割り込みがアンマスクされるようにする必要があります。

3. 必要なレジスタを設定し、`context_restore`を呼び出し、EL0に`eret`する。

    トラップフレームを設定したら次の手順でそのプロセスへのコンテキスト
    スイッチをブートストラップできます。

    - 適切なレジスタに適切な値に設定して`context_restore`を呼び出す。

        注：ここではわざと曖昧にしています。これが不透明だと感じたら、`context_restore`が何をするのか、何をさせたいのか、どうすれば
        そうさせることができるのかを考えてください。

    - 現在のスタックポインタ（`sp`）を初期値（`_start`のアドレス）に設定する。
      これは後で例外を捕捉する際に`EL1`スタック全体を使えるようにするために
      必要です。**注意**: `sp`を直接`ldr`したり`adr`したりすることはできません。
      まず別のレジスタにロードし、そのレジスタから`sp`に`mov`する必要が
      あります。

    - もはや`0`を持っていないと思われるレジスタをすべて再設定する。
      ユーザレベルのプロセスに情報を漏らしてはいけません。

    - `eret`により`EL0`に復帰する。

    これを実装するには[インラインアセンブリ](https://doc.rust-lang.org/unstable-book/language-features/asm.html)を
    使用する必要があります。例として、変数`tf`がトラップフレームへの
    ポインタだとすると以下は`x0`の値をそのアドレスにセットし、それを`x1`に
    コピーします。

    ```rust
    unsafe {
        asm!("mov xo, $0
              mov x1, x0"
             :: "r"(tf)
             :: "volatile");
    }
    ```

関数は復帰すべきではないのでコンパイラを満足させるために`start()`関数の最後に
無限ループを追加するとよいかもしれません。メソッドを実装したら、`kmain`に`SCHEDULER.start()`の呼び出しを追加し、シェルやブレークポイントの呼び出しを
すべて削除してください。`SCHEDULER.initialize()`はまだ呼び出す必要はありません。
これはサブフェーズDで実装します。これで`kmain`は以下のように2つの初期化の
呼び出しとスケジューラを開始する呼び出しだけになるはずです。

```rust
unsafe fn kmain() -> ! {
    ALLOCATOR.initialize();
    FILESYSTEM.initialize();
    SCHEDULER.start()
}
```

すべてうまくいけばカーネルが起動すると`EL0`からあなたの`extern`関数が
呼び出され、ユーザレベルのプロセスとしてシェルが実行されます。

次に進む前にこの時点で同じプロセスに戻るコンテキストスイッチが正しく動作する
ことも確認しておく必要があります。`extern`関数でシェルを起動する前後に
`brkへの呼び出しをいくつか追加してみてください。

```rust
extern fn run_shell() {
    unsafe { asm!("brk 1" :::: "volatile"); }
    unsafe { asm!("brk 2" :::: "volatile"); }
    shell::shell("user0> ");
    unsafe { asm!("brk 3" :::: "volatile"); }
    loop { shell::shell("user1> "); }
}
```

各ブレークポイント例外から正常に戻ることができるはずです。各ブレークポイント
例外のソースは`LowerAArch64`であるはずで、これはユーザ空間への切り替えが
成功したことを示しています。すべてが期待通りに動作したら次のサブフェーズに
進んでください。

**ヒント**
> インラインアセンブリは6命令で構成されます。

**ヒント**
> インラインアセンブリ以外は`unsafe`は必要ありません。

### サブフェーズ C: タイマー割り込み

このサブフェーズではBCM2837搭載の割り込みコントローラ用のドライバを実装します。
また、既存のシステムタイマードライバを変更してタイマー割り込みを構成できるように
します。最後に、スケジューリングに基づくコンテキストスイッチのスプリングボードと
して機能する周期的なタイマー割り込みを有効にします。主に、
`lib/pi/src/interrupt.rs`と`lib/pi/src/timer.rs、kern/src/traps`で作業します。

#### 割り込み処理

AArch64では割り込みは特定のクラスの例外にすぎません。この2つの主な違いは
割り込みが非同期に発生することです。つまり、割り込みは外部イベントに応じて
外部ソースにより発生します。

下図は割り込みがソースである外部デバイスからシンクである例外ベクターに至る
経路を示しています。

![割り込み伝達経路](interrupt_path.png)

割り込みは経路上の各ポイントで選択的に無効にすることができます。割り込みが
例外ベクタに送られるには外部デバイス、割り込みコントローラ、CPU のすべてで
割り込みを受け入れるように設定されていなければなりません。

**注記: 割り込みコントローラとは何か**
> 割り込みコントローラはシステムタイマーなどの割り込み発生デバイスとCPUの間の
> プロキシおよびゲートとして動作する外部デバイスです。割り込みコントローラは
> CPUの割り込みピンに物理的に接続されています。割り込みコントローラの入力ピンに
> 信号が送られると割り込みコントローラはその信号をCPUに転送します。
>
> 間接的なレイヤーが追加されることで割り込みを選択的に有効/無効にすることが
> 可能になっています。また、CPUメーカがCPUにバンドルする割り込みコントローラを
> 選択できるようにもしています。

#### 外部デバイス

システムタイマー用のデバイスドライバは既に書いています。このサブフェーズでは
タイマーのコンペアレジスタを設定できるようにドライバを拡張します。システム
タイマーは現在時刻とコンペアレジスタの値を継続的に比較し、値が等しくなると
割り込みを発生させます。

#### 割り込みコントローラ

システムタイマーは割り込みコントローラに割り込みを伝達しますが、割り込み
コントローラはCPUに割り込みを伝達するように構成されている必要があります。
ここではこれを行うように割り込みコントローラ用のデバイスドライバを作成する
ことになります。

割り込みコントローラは割り込みを受信するとその割り込みを保留中としてマークし、
物理的な割り込みピンを論理的にハイに保持することでCPUに配送します。システム
タイマー割り込みを含むいくつかの割り込みでは割り込みが確認されるまでピンは
ハイのまま保持されます。これは割り込みは確認されるまで継続して配送されることを
意味します。割り込みが確認されると割り込みピンは解放され、保留フラグは解除
されます。

#### CPU

割り込みが例外ベクタに配送されるにはCPUにおいて割り込みを _アンマスク_ する
必要があります。デフォルトでは割り込みはCPUにより _マスクされている_ ので
配信されません。CPUは割り込みがマスクされている間に受信した割り込みを
割り込みがアンマスクされたらすぐに配信することができます。CPUは例外ベクタを
呼び出すと自動的にすべての割り込みもマスクします。これはシステムタイマー
割り込みなどの処理されるまでハイレベルを保持する割り込みが直ちに例外ループに
ならないようにするためです。

前のサブフェーズで、プロセスが`EL0`で実行中に割り込みが発生するように構成
していますのでこの点に関しては追加でやることはありません。

**質問 (reentrant-irq): IRQの処理中にIRQのマスクはいつ解除するのか**
> 私たちのカーネルは例外処理ルーチンの間ずっとIRQをマスクしているので
> ネストした割り込み処理はサポートしていませんが、IRQを処理中にIRQを
> アンマスクすることは商業OSではかなり一般的なことです。どのような
> シナリオでこのようなことをしたくなりますか。また、保留中のIRQを最初に
> 確認せずにこれを行うと例外ループになりますか。それはなぜですか。

#### 例外ベクタ

例外ベクタはすでに構成済みです。そのため、あとはIRQ（割り込み要求）例外を
適切に処理するだけです。割り込みを処理するために対応する割り込みのハンドラ
関数のリストを保持するグローバルま`Irq`構造体を設けました。`kern/src/traps/irq.rs`に
ある`register()`関数を呼び出すことで各割り込みのハンドラ関数を設定することが、
`invoke()`関数で登録したハンドラを実行することができます。`kern/src/traps.rs`に
ある`handle_exception`関数を変更して既知のすべての割り込み要求を`invoke()`
関数に送るようにします。

どの割り込みが発生したかを判断するには割り込みコントローラでどの割り込みが
保留中かをチェックする必要があります。`handle_irq`関数は割り込みを認識して、
それを処理します。

#### 実装

`lib/pi/src/interrupt.rs`にある割り込みコントローラドライバの実装から始めます。
割り込みコントローラのドキュメントは[BCM2837 ARM Peripherals Manual](../arm_docs/BCM2837-ARM-Peripherals.pdf)の
第7章にあります。必要な処理は`Interrupt` enumで記述されている通常IRQの有効化、
無効化、状態チェックだけです。FIQやBasic IRQについては無視して構いません。
`interrup`構造体は4`つのメソッドを提供しています。iter()`メソッドはどの
割り込みが保留中であるかをチェックするために割り込みを走査する際に使用できます。
`to_index()`と`from_index()`は`register()`と`invoke()`を実装する際に
役に立ちます。

次に、システムタイマードライバ用の`tick_in()`メソッドと関数を
`lib/pi/src/timer.rs`に実装します。システムタイマーに関するドキュメントは
[BCM2837 ARM Peripherals Manual](../arm_docs/BCM2837-ARM-Peripherals.pdf)の
第12章にあります。`tick_in()`を正しく実装するには2つのレジスタに書き込む
必要があります。

次は、`src/traps/irq.rs`に移動して`register()`メソッドと`invoke()`メソッドを
実装します。`Irq`構造体は内部にハンドラ関数のスマートポインタである`IrqHandler`
のリストを保持しています。`register()`メソッドで割り込みのハンドラ関数を
セットし、`invoke()`メソッドで実行することができます。

次に、タイマー割り込みを有効にし、`kern/src/process/scheduler.rs`にある
`GlobalScheduler::start()`で最初のプロセスを開始する直前に`TICK`マイクロ秒毎に
タイマー割り込みが発生するように設定します。`TICK`変数はk`ern/src/param.rs`で
宣言されています。さらに、タイマーのハンドラ関数を登録します。タイマー
割り込みが`TICK`マイクロ秒ごとに無期限に発生するようにハンドラ関数を
`TICK`マイクロ秒毎に新しいタイマー割り込みが発生するように設定します。
実装をテストするためにここにメッセージを表示するとよいでしょう。

`kern/src/traps.rs`にある`handle_exception`関数を変更して既知の割り込みを
`kern/src/traps/irq.rs`にある`invoke()`関数に転送するようにします。

最後に、`kern/src/main.rs`で`SCHEDULER.start()`を呼び出す前に
`IRQ.initialize()`を追加します。

実装が終了するとソースが`LowerAArch64`、種類が`Irq`のタイマー割り込みが
`TICK`マイクロ秒ごとに発生するのが確認できるはずです。タイマー割り込みが
発生するまでの間は通常通りプロセスとやりとりできるはずです。すべてが期待
通りに動作したら次のサブフェーズに進んでください。

**警告: `TICK`の設定は後で変更する**
> 現在のところ、すべてが期待通りに動くことを確認するために2秒という途方も
> なく遅い`TICK`設定を使っています。通常、この数値は1ミリ秒から10ミリ秒の
> 間にします。後で`TICK`をより合理的な10ミリ秒に下げます。
