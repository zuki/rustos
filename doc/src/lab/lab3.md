# Lab3: FAT32ファイルシステム

## はじめに

この課題ではメモリアロケータを書くことでRustの[コレクション](https://doc.rust-lang.org/alloc/collections/index.html)
モジュール（`Vec`、`String`、`HashMap`とその仲間）を使えるようにし、
FAT32ファイルシステムとRaspberry PiのEMMC（SDカードコントローラ）
ドライバのRustインタフェースを実装し、`cd`, `ls`, `pwd`, `cat`コマンドで
シェルを拡張します。

## フェーズ0: 始めよう

[一部省略]

以下はリポジトリのディレクトリ構成です。この課題で作業するファイルには
`*`がついています。

```
.
├── bin : common binaries/utilities
├── doc : reference documents
├── ext : external files (e.g., resources for testing)
├── tut : tutorial/practices
│    ├── 0-rustlings
│    ├── 1-blinky
│    ├── 2-shell
│    └── 3-fs : questions for lab3 *
├── boot : bootloader
├── kern : the main os kernel *
└── lib  : required libraries
     ├── fat32 *
     ├── pi *
     ├── shim
     ├── stack-vec
     ├── ttywrite
     ├── volatile
     └── xmodem
```

[一部省略]

### `make transmit`コマンド

前回のラボでブートローダを書き終えたので`make transmit`コマンドを使う
ことができます。このコマンドはカーネルバイナリをビルドし、`ttywrite`を
呼び出してブートローダがロードできるようにRaspberry Piに送信します。
その結果、ブートローダが`kernel8.img`としてインストールされていると仮定
するとRaspberry Piをリセットして`make transmit`を実行するだけで新しい
バイナリをテストできるようになります。

前回のラボで`ttywrite`ユーティリティをインストールしたはずです。何らかの
理由でインストールしていない場合は今すぐ`lib/ttywrite`ディレクトリで
`cargo install --path .`を実行してインストールしてください。t
`tywrite --help`を実行することによりユーティリティが正しくインストール
されたことを確認してください。

`make transmit`ターゲットはデフォルトで`/dev/ttyUSB0`に書き込むように
設定されています。使用するTTYデバイスが異なる場合は`kern/Makefile`の
7行目の`TTY_PATH`宣言を適切に変更してください。

**注記: ユーザ名をdialoutグループに追加する**
> TTYへアクセスした際にパーミッションの問題が発生した場合はユーザ名を
> dialoutグループに追加してみてください。
    sudo usermod -a -G dialout $USER
    sudo reboot


**警告: lab3マージ後のコンパイルエラー**
> lab3の最終フェーズ用のテンプレートコードを提供していますがそこには
> 未完のコードがたくさん含まれています。このラボの作業中にコードを
> コンパイルするとマージしたばかりのコードのいくつかについてコンパイラが
> 警告を発することがわかります。後で修正するまで対象のコードをコメント
> することができます。たとえば、フェーズ1の作業中はファイルシステム
> コンポーネントを無効にしたいと思うでしょう。コメントアウトは最小限の
> コードだけにするようにしてください。

**警告: `ALLOCATOR.initialize()`の呼び出しはパニックになります**
> 前回作成したシェルは依然として機能するはずです。ただし、現時点で
> `make install`ターゲットをテストするとシェルが動作しないように見える
> かもしれません。その原因として考えられるのは`shell()`の呼び出しの前に
> ある`ALLOCATOR.initialize()`の呼び出しです。まだメモリアロケータがない
> ので、この呼び出しは`panic!()`を引き起こし、警告なしにシステムを停止
> させます。これはすぐに修正します。すべてが期待どおりに動作するように
> 対象の行を一時的にコメントアウトしてください。

## フェーズ1: メモリレーン

このフェーズではメモリアロケータを2つ実装します。シンプルな _バンプ_
アロケータとより完全な機能を持つ _ビン_  アロケータです。これらにより
`Vec`、`Box`、`String`などのヒープ割り当ての構造体がすぐに使用できる
ようになります。システムで割り当て可能なメモリを決定するために
ARMタグ（`ATAGS`）を読み込みます。また、`panic!`呼び出しを正しく
処理するためにパニックハンドラを実装します。

### サブフェーズA: Panic!

このサブフェーズではパニックハンドラを実装します。`kern/src/init/panic.rs`
で作業します。

#### Rustにおけるエラー処理

Rustには2つの大きなエラーカテゴリーがあります。_回復可能な_ エラーと
_回復不可能な_ エラーです。Rustでは回復可能なエラーを`Result<T, E>`型で
表します。一方、Rustプログラムが回復不可能なエラーに遭遇するとRustは
プログラムの実行を完全に停止します。この動作をRustの用語では
`panic!`と呼びます。

標準的なオペレーティングシステムを対象としている場合、Rustコンパイラは
バックトレースを表示してパニック時のプロセス終了コードを設定する
プログラムを生成します。しかし、私達がRaspberry Pi用に行っているような
オペレーティングシステムのサポートのない対象向けにRustプログラムの
コンパイルを指示した場合、Rustコンパイラは _パニックハンドラ_ の
実装を要求します。

パニックハンドラは`panic!`が発生したときに呼び出される関数です。その型は
`fn panic(info: PanicInfo) -> !` です。これは引数として
[PanicInfo](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html)を
受け取り、決して復帰しないことを意味します。`PanicInfo`構造体には
`panic!`が発生したファイル名、行番号、列数の情報が格納されています。

`kern/src/init/panic.rs`には無限にループするパニックハンドラを提供して
います。この`panic`関数の実装を拡張して有用な情報をコンソールにログ出力
するようにします。

#### パニックハンドラの実装

`panic`関数を実装してください。実装では渡された情報をコンソールに表示し、
既にある`loop`を実行できるようにする必要があります。関数の実装は自由です。
例として、私たちの実装は`Linuxカーネルのops`メッセージからヒントを得て
います。

```bash
            (
       (      )     )
         )   (    (
        (          `
    .-""^"""^""^"""^""-.
  (//\\//\\//\\//\\//\\//)
   ~\^^^^^^^^^^^^^^^^^^/~
     `================`

    The pi is overdone.

---------- PANIC ----------

FILE: src/kmain.rs
LINE: 40
COL: 5

index out of bounds: the len is 3 but the index is 4
```

カーネルをパニックさせて新しい`panic`関数の実装をテストしてください。
新規`make install`ターゲットを使うとカーネルをコンパイルしてRaspberry Piに
送信できることを思い出してください。`ALLOCATOR.initialize()`の呼び出しで
すでに`panic!`になるので変更は不要であることに注意してくだい。 この関数が
`shell()`の前に呼び出されることを確認してください。

次に、不正な`unwrap()`、明示的な`panic!()`、`unreachable!()`などの他の
方法でカーネルをパニックにしてみてください。そしてすべてが期待通りに
操作することを確認してください。実装に満足したら次のサブフェーズに
進んでください。
