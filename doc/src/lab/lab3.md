# Lab3: FAT32ファイルシステム

# 目次

- [フェーズ0: 始めよう](#フェーズ0-始めよう)
- [フェーズ1: メモリレーン](#フェーズ1-メモリレーン)
    - [サブフェーズA: Panic!](#サブフェーズa-panic!)
    - [サブフェーズB: ATAGS](#サブフェーズb-atags)
    - [サブフェーズC: ウォーミングアップ](#サブフェーズc-ウォーミングアップ)
    - [サブフェーズD: バンプアロケータ](#サブフェーズd-バンプアロケータ)
    - [サブフェーズE: ビンアロケータ](#サブフェーズe-ビンアロケータ)
- [フェーズ2: 32ビットリピッド](#フェーズ2-332ビットリピッド)
    - [ディスクとファイルシステム](#ディスクとファイルシステム)
    - [ディスクレイアウト](#ディスクレイアウト)
    - [コードの構成](#コードの構成)
    - [実装](#4-3-実装)
- [フェーズ3: サドルアップ](#フェーズ3-サドルアップ)
    - [サブフェースA: SDドライバFFI](#サブフェースa-sdドライバffi)
    - [サブフェーズB: ファイルシステム](#サブフェーズb-ファイルシステム)

## はじめに

この課題ではメモリアロケータを書くことでRustの[コレクション](https://doc.rust-lang.org/alloc/collections/index.html)
モジュール（`Vec`、`String`、`HashMap`とその仲間）を使えるようにし、
FAT32ファイルシステムとRaspberry PiのEMMC（SDカードコントローラ）
ドライバのRustインタフェースを実装し、`cd`, `ls`, `pwd`, `cat`コマンドで
シェルを拡張します。

## フェーズ0: 始めよう

[一部省略]

以下はリポジトリのディレクトリ構成です。この課題で作業するファイルには
`*`がついています。

```
.
├── bin : common binaries/utilities
├── doc : reference documents
├── ext : external files (e.g., resources for testing)
├── tut : tutorial/practices
│    ├── 0-rustlings
│    ├── 1-blinky
│    ├── 2-shell
│    └── 3-fs : questions for lab3 *
├── boot : bootloader
├── kern : the main os kernel *
└── lib  : required libraries
     ├── fat32 *
     ├── pi *
     ├── shim
     ├── stack-vec
     ├── ttywrite
     ├── volatile
     └── xmodem
```

[一部省略]

### `make transmit`コマンド

前回のラボでブートローダを書き終えたので`make transmit`コマンドを使う
ことができます。このコマンドはカーネルバイナリをビルドし、`ttywrite`を
呼び出してブートローダがロードできるようにRaspberry Piに送信します。
その結果、ブートローダが`kernel8.img`としてインストールされていると仮定
するとRaspberry Piをリセットして`make transmit`を実行するだけで新しい
バイナリをテストできるようになります。

前回のラボで`ttywrite`ユーティリティをインストールしたはずです。何らかの
理由でインストールしていない場合は今すぐ`lib/ttywrite`ディレクトリで
`cargo install --path .`を実行してインストールしてください。t
`tywrite --help`を実行することによりユーティリティが正しくインストール
されたことを確認してください。

`make transmit`ターゲットはデフォルトで`/dev/ttyUSB0`に書き込むように
設定されています。使用するTTYデバイスが異なる場合は`kern/Makefile`の
7行目の`TTY_PATH`宣言を適切に変更してください。

**注記: ユーザ名をdialoutグループに追加する**
> TTYへアクセスした際にパーミッションの問題が発生した場合はユーザ名を
> dialoutグループに追加してみてください。
    sudo usermod -a -G dialout $USER
    sudo reboot


**警告: lab3マージ後のコンパイルエラー**
> lab3の最終フェーズ用のテンプレートコードを提供していますがそこには
> 未完のコードがたくさん含まれています。このラボの作業中にコードを
> コンパイルするとマージしたばかりのコードのいくつかについてコンパイラが
> 警告を発することがわかります。後で修正するまで対象のコードをコメント
> することができます。たとえば、フェーズ1の作業中はファイルシステム
> コンポーネントを無効にしたいと思うでしょう。コメントアウトは最小限の
> コードだけにするようにしてください。

**警告: `ALLOCATOR.initialize()`の呼び出しはパニックになります**
> 前回作成したシェルは依然として機能するはずです。ただし、現時点で
> `make install`ターゲットをテストするとシェルが動作しないように見える
> かもしれません。その原因として考えられるのは`shell()`の呼び出しの前に
> ある`ALLOCATOR.initialize()`の呼び出しです。まだメモリアロケータがない
> ので、この呼び出しは`panic!()`を引き起こし、警告なしにシステムを停止
> させます。これはすぐに修正します。すべてが期待どおりに動作するように
> 対象の行を一時的にコメントアウトしてください。

## フェーズ1: メモリレーン

このフェーズではメモリアロケータを2つ実装します。シンプルな _バンプ_
アロケータとより完全な機能を持つ _ビン_  アロケータです。これらにより
`Vec`、`Box`、`String`などのヒープ割り当ての構造体がすぐに使用できる
ようになります。システムで割り当て可能なメモリを決定するために
ARMタグ（`ATAGS`）を読み込みます。また、`panic!`呼び出しを正しく
処理するためにパニックハンドラを実装します。

### サブフェーズA: Panic!

このサブフェーズではパニックハンドラを実装します。`kern/src/init/panic.rs`
で作業します。

#### Rustにおけるエラー処理

Rustには2つの大きなエラーカテゴリーがあります。_回復可能な_ エラーと
_回復不可能な_ エラーです。Rustでは回復可能なエラーを`Result<T, E>`型で
表します。一方、Rustプログラムが回復不可能なエラーに遭遇するとRustは
プログラムの実行を完全に停止します。この動作をRustの用語では
`panic!`と呼びます。

標準的なオペレーティングシステムを対象としている場合、Rustコンパイラは
バックトレースを表示してパニック時のプロセス終了コードを設定する
プログラムを生成します。しかし、私達がRaspberry Pi用に行っているような
オペレーティングシステムのサポートのない対象向けにRustプログラムの
コンパイルを指示した場合、Rustコンパイラは _パニックハンドラ_ の
実装を要求します。

パニックハンドラは`panic!`が発生したときに呼び出される関数です。その型は
`fn panic(info: PanicInfo) -> !` です。これは引数として
[PanicInfo](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html)を
受け取り、決して復帰しないことを意味します。`PanicInfo`構造体には
`panic!`が発生したファイル名、行番号、列数の情報が格納されています。

`kern/src/init/panic.rs`には無限にループするパニックハンドラを提供して
います。この`panic`関数の実装を拡張して有用な情報をコンソールにログ出力
するようにします。

#### パニックハンドラの実装

`panic`関数を実装してください。実装では渡された情報をコンソールに表示し、
既にある`loop`を実行できるようにする必要があります。関数の実装は自由です。
例として、私たちの実装は`Linuxカーネルのops`メッセージからヒントを得て
います。

```bash
            (
       (      )     )
         )   (    (
        (          `
    .-""^"""^""^"""^""-.
  (//\\//\\//\\//\\//\\//)
   ~\^^^^^^^^^^^^^^^^^^/~
     `================`

    The pi is overdone.

---------- PANIC ----------

FILE: src/kmain.rs
LINE: 40
COL: 5

index out of bounds: the len is 3 but the index is 4
```

カーネルをパニックさせて新しい`panic`関数の実装をテストしてください。
新規`make install`ターゲットを使うとカーネルをコンパイルしてRaspberry Piに
送信できることを思い出してください。`ALLOCATOR.initialize()`の呼び出しで
すでに`panic!`になるので変更は不要であることに注意してくだい。 この関数が
`shell()`の前に呼び出されることを確認してください。

次に、不正な`unwrap()`、明示的な`panic!()`、`unreachable!()`などの他の
方法でカーネルをパニックにしてみてください。そしてすべてが期待通りに
操作することを確認してください。実装に満足したら次のサブフェーズに
進んでください。

### サブフェーズB: ATAGS

このサブフェーズではRaspberry Piのファームウェアによってロードされる
ARMタグ（ATAGS）に対するイテレータを実装します。イテレータを使って
システムで利用可能なメモリ量を指定するATAGを見つけます。`lib/pi/src/atags`
ディレクトリと`kern/src/allocator.rs`で作業します。

#### ARMタグ

[ATAGS](http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html#d0e428)（ARMタグ）は
ARMブートローダやファームウェアがシステムに関する情報をカーネルに渡す
ために使用するメカニズムです。たとえば、LinuxはARMアーキテクチャ用に
構成されているとATAGSを使用することができます。

Raspberry Piはアドレス0x100にATAG構造体の配列を配置します。以下はATAGS
構造をRust構文で書いたものです。

```rust
#[repr(C)]
struct Atag {
    dwords: u32,
    tag: u32,
    kind: Kind
}
```

ATAGは8バイトのヘッダーである`dwords`と`tag`で始まります。`dwords`
フィールドは全ATAGのサイズを _ダブルワード_（32 ビットワード）単位で
指定します。これにはヘッダーも含まれます。したがって、最小サイズは`2`
です。`tag`フィールドはATAGのタイプを指定します。10種類のタグが指定されて
おり[ATAGSリファレンス](http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html#d0e428)にすべて記載されています。Raspberry Piは4つ
しか使用しません。以下はその説明です。

| 名前 | タイプ(`tag`) | サイズ | 説明 |
|:-----|:--------------|:-------|:-----|
| [CORE](file:///Users/dspace/xv6_memos/book/raspi/booting_arm_linux.html#atag_core) | 0x54410001 | 5, 空の場合は2  | リストの開始に使用する最初のタグ |
| [NONE](file:///Users/dspace/xv6_memos/book/raspi/booting_arm_linux.html#atag_none) | 0x00000000 | 2 | リストの終端に使用するエンプティタグ |
| [MEM](file:///Users/dspace/xv6_memos/book/raspi/booting_arm_linux.html#atag_mem) | 0x54410002 | 4 | 物理メモリ領域を記述する |
| [CMDLINE](file:///Users/dspace/xv6_memos/book/raspi/booting_arm_linux.html#atag_cmdline) | 0x54410009 | 可変 | カーネルに渡すコマンドライン |

タグのタイプはヘッダー後のデータがどのように解釈されるべきかを決めます。
スケルトンコードではヘッダーに続くデータは様々な種類のタグのunionである
`kind`という名前のフィールドで表現されています。上の表でタグの名前を
クリックするとそのタグのデータレイアウトを含むタグのリファレンスに
ジャンプします。たとえば、`MEM`タグのデータは以下のような構造になって
います。

```c
struct Mem {
    size: u32,
    start: u32
}
```

タグはメモリ上に順次配置され、各タグ間は0詰めされています。最初のタグは
`CORE`タグと規定されており、最後のタグは`NONE`タグで示されます。その他の
タグの順番は任意です。`dwords`フィールドは隣接するATAGのアドレスの決定に
使用されます。下図は一般的なレイアウトを示しています。

![ATAGSレイアウト](atags.png)

#### Unionと安全性

生のATAGデータ構造体は`lib/pi/src/atags/raw.rs`で宣言されています。以下に
コピーしたメインの宣言ではRustの`union`を使用しています。Rustのunionは
Cのユニオンと同じで、すべてのフィールドが共通のストレージを共有する構造を
定義します。

```rust
pub struct Atag {
    dwords: u32,
    tag: u32,
    kind: Kind
}

pub union Kind {
    core: Core,
    mem: Mem,
    cmd: Cmd
}
```

事実上、unionはそのキャストが正しいかどうかに関係なく、メモリを任意の
構造体にキャストできます。そのためRustにおけるunionフィールドのアクセスは
unsafeです。

`atags`モジュールですでに大部分のunsafeを処理しているのでunionの扱いに
ついては心配する必要はありません。とはいえ、`pi`ライブラリのエンドユーザに
unionを公開するのは悪い考えです。そのため、`lib/pi/src/atags/atag.rs`に
2つ目の`Atag`構造体を宣言しました。この構造体の使用とアクセスは完全に
安全です。これが`pi`ライブラリが公開する構造体です。このサブフェーズの
後半で`atag`モジュールの実装を終える際に`raw`構造体から安全な構造体への
変換を書くことになります。

**質問 (enduser-unssfe): エンドユーザにunionを公開するのはなぜ悪い考えなのか**
> unsafeなデータ構造を安全なインターフェイスを公開するために多くの労力を
> 費やしてきています。標準ライブラリを代表例としてRustではこのようなことが
> 何度も何度も見られます。Rustでunsafeな構造体や操作を安全なインタフェースで
> 公開することにどのような利点があるのでしょうか。C言語のような言語でも
> 同じような利点が得られるでしょうか。

#### コマンドライン引数

`CMDLINE`タグは特に注目に値します。その定義は次のとおりです。

```rust
struct Cmd {
    /// コマンドライン文字列の最初のバイト
    cmd: u8
}
```

コメントで示したように`cmd`フィールドはコマンドライン文字列の最初の
バイトを保持します。言い換えれば、`&cmd`はCと同様なヌル終端の文字列への
ポインタです。安全版の`Cmd`タグは`Cmd(&'static str)`です。`raw`の`Cmd`
タグから安全版の`Cmd`タグへの変換を記述する場合、文字列内でヌル終端を
検索してC類似の文字列のサイズを決定する必要があります。次に、そのアドレスとサイズを`slice::from_raw_parts()`を使ってスライスにキャストし、最後に
そのスライスを`str::from_utf8()`か`str::from_utf8_unchecked()`を使って
文字列にキャストする必要があります。この2つの関数はラボ2で使っています。

#### `atgs`の実装

これで`lib/pi/src/atags`にある`atags`モジュールを実装する準備ができました。
`atags/raw.rs`にある`raw::Atag::next()`メソッドの実装から始めましょう。
このメソッドは`self`に続くATAGのアドレスを決定し、その参照を返します。
実装では`unsafe`を使用する必要があります。次に、`atags/atag.rs`にある
ヘルパーメソッドとraw構造体から安全な構造体へ変換するトレイトを実装
します。`unsafe`を使用する必要があるのは`From<&'a raw::Cmd> for Atag`を
実装するときだけです。最後に、`atags/mod.rs`にある`Atag`用の
`Iterator`トレイトの実装を完了させます。これには`unsafe`は必要ありません。

**ヒント**
> `x as *const T as *const u32`を使って`x: &T`から`*const u32`へ変換する
> ことができます。

**ヒント**
> `&*x`を使って`x: *const T`から`T`に変換することができます・しかし、
> この変換は**極めて**unsafeです。Rust参照のエイリアス規則に違反しない
> ように注意してください。

**ヒント**
> ポインタ演算は`add()`, `sub()`, `offset()`で実行できます。

#### `atggs`のテスト

`lib/pi`ディレクトリで`cargo test`コマンドを実行して実装をテストして
ください。次に、`kern/src/main.rs`にすべてのATAGSを走査してコンソールに
デバッグプリントするコードを書いてRPiボードでATAGS実装をテストしてください。
3つの`NONE`以外のタグが少なくとも1つずつ表示されるはずです。それぞれの
ATAGの値が期待通りであることを確認してください。実装が期待通りに実行
されたら、次のサブフェーズに進んでください。

**ヒント**
フォーマット指定子`{:#?}`は構造体のデバッグ出力をプリティにします。

**質問 (atag-cmdlin): `CMDLINE` ATAGには何が含まれていますか**
Raspberry Piで見つかった`CMDLINE` ATAGに含まれているコマンドライン文字列
の値は何ですか。そのパラメータは何を制御していると思いますか。

    `"bcm2708_fb.fbwidth=656 bcm2708_fb.fbheight=416 bcm2708_fb.fbswap=1 dma.dmachans=0x7f35 bcm2709.boardrev=0xa020d3 bcm2709.serial=0x4aabe848 bcm27...`

**質問  (atag-mem): `MEM`タグではどのくらいのメモリが報告されましたか**
> `MEM` ATAGによって報告される利用可能なメモリの正確な開始アドレスと
> サイズは何でしたか。これはRaspberry Piの1GBのRAMと言われているものに
> どれくらい近いですか。

    開始アドレスは 0x0, サイズは 994,050,048

### サブフェーズC: ウォーミングアップ

このサブフェイズでは次のサブフェイズで2つのメモリアロケータを書くための
準備をします。ここではアドレスを2のべき乗にアラインする2つのユーティリティ
関数: `align_up`と`align_down`を実装します。また、システムで利用可能な
メモリの開始アドレスと終了アドレスを返す`memory_map`関数を実装します。
この`memory_map`関数は割り当て可能なメモリを決定するために2つのメモリ
アロケータの両者で使用されます。

#### アライメント

メモリアドレスは`n`の倍数である場合 _nバイトアライン_ されているといいます。
別の言い方をすれば、メモリ・アドレス`k`は`k % n == 0`の場合、_nバイトアライン_ です。_通常_、メモリアドレスのアラインメントを気にする必要は
ありませんが、新進のシステムプログラマとしては気にする必要があります。
なぜなら、ハードウェアやプロトコル、その他の外的要因によってアライメント
プロパティが強制されるからです。たとえば、ARM 32ビットアーキテクチャでは
スタックポインタは8バイトアラインメントである必要があります。私達のOSに
選んだAArch64アーキテクチャではスタックポインターが16バイトアライメントで
ある必要があります。x86-64でも同じアライメントが必要とされます。仮想
メモリに使われるページアドレスは通常、4kバイトアライメントが必要です。
他にも例はたくさんありますが、メモリアドレスのアライメントが重要である
というだけで十分です。

C言語ではlibCアロケータから返されるメモリーアドレスは32ビットシステムでは
8バイトアライン、64ビットシステムでは16バイトアラインであることが保証されて
います。これを超えると、呼び出し元は返されたメモリーアドレスのアライメントを
制御できないので自分で解決しなければなりません（`posix_memalign`などの
POSIX関数は後にこれを修正しました）。

**質問 (libc-align): なぜCはこのアライメントを選択したのですか**
> libCの`malloc`が8バイトまたは16バイトのアライメント保証を選択したこと
> には理由がないわけではありません。なぜlibCはこれらの特定のアライメント
> 保証を選んだのですか。

C言語の`malloc()`と`free()`のシグネチャを思い出してください。

```c
void malloc(size_t size);
void free(void *pointer);
```

対照的に`GlobalAlloc`トレイトにあるRustoの低水準でunsafeな`alloc`と
`dealloc`は次のシグネチャを持っています。

```rust
// `layout.size()`は要求サイズ、`layout.align()`は要求アライメント
unsafe fn alloc(&self, layout: Layout) -> *mut u8;

// `layout`は`ptr`を返した呼び出しに使ったものと同じである必要がある
unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout)
```

呼び出し側は2つのパラメタ`size`と`align`で定義される[layout](https://doc.rust-lang.org/std/alloc/struct.Layout.html)
引数でアライメントを指定できることに注意してください。そのため、適切に
アラインメントされたメモリーアドレスを返す責任は呼び出し側ではなく
アロケータ側にあります。次のフェーズでメモリアロケータを実装する際には
返すアドレスがlayoutパラメータで指定された条件を満たすようにする必要が
あります。

2つ目の注意点は、Cの`free`と同様に、呼び出し元に`alloc`の呼び出し時に
使用した`Layout`を`dealloc`関数に渡すよう要求していることです。そのため、
アロケーションの要求サイズとアライメントを覚えておく責任はアロケータでは
なく、呼び出し側にあります。

**注記: Rustにおけるサイズとアライメントの保証**
> Rustでは、すべてのレイアウトは負値でないサイズと2のべき乗のアライメントを
> 待たなければなりません。これらの条件はレイアウトの作成時にチェック
> されます。

**質問 (onus): Rustはなぜこのような責任の分担をすると思いますか**
> C言語ではアロケータが返すメモリアドレスのアライメントに関する制約は
> 殆どありませんが、後で使用するためにアロケーションのサイズを記録して
> おく必要があります。Rustではその逆です。なぜRustはこのような逆の道を
> 選んだと思いますか。アロケータと呼び出し側にとってどのような利点が
> あるのでしょうか。

#### ユーティリティ: `align_up`と`align_down`

次のサブフェーズでアロケータを実装する際、メモリアドレス`u`が与えられた
場合に2のべき乗にアラインする最初のアドレスを`≧ n`か`≦ u`のいずれかに
できると便利です。`kernel/src/allocator/util.rs`にある（未実装の）
`align_up`関数と`align_down`関数はまさにこれを行います。

```rust
/// `addr` を `align` の最も近い倍数の下方向にアラインする.
/// `align` は2のべき乗でない場合はパニック.
fn align_down(addr: usize, align: usize) -> usize;

/// `addr` を `align` の最も近い倍数の上方向にアラインする.
/// `align` は2のべき乗でない、または、アライメントでアドレスが
/// オーバーフローする場合はパニック.
fn align_up(addr: usize, align: usize) -> usize;
```

これらの関数を今すぐ実装してください。`kernel`ディレクトリで`make test`
または`cargo test`を実行すると実装をユニットテストすることができます。
これにより`kern/src/allocator/tests.rs`のテストが実行されます。
`align_util`のユニットテストがすべてパスするはずです。

**警告: テスト**
> テスト中、kprint{ln}! の呼び出しは print{ln}!の呼び出しになります。

#### スレッドセーフ性

libCの`malloc()`やこれから実装する2つのメモリアロケータは _グローバル_
です。任意のスレッドから任意の時点で呼び出される可能性があります。
そのため、アロケータは _スレッドセーフ_ である必要があります。それが
`alloc()`メソッドと`dealloc()`メソッドが[Mutex](https://doc.rust-lang.org/std/sync/struct.Mutex.html)や
[RwLock](https://doc.rust-lang.org/std/sync/struct.RwLock.html)などの
他の同期プリミティブと同様に共有された（エイリアス可能な）参照 `&self` を
取る理由です。Rustはスレッドセーフ性を非常に重要視しています。そのため、
システムがスレッドなどの並行性のメカニズムをまだ持っていないとしても
スレッドセーフでないアロケータを実装することは困難です。

スレッドセーフのメモリアロケータに関する話題は広範囲に渡っており、まさに
この話題に関して多くの研究論文が発表されています。余談に陥るのを避ける
ためこの話題については完全に無視し、私達のアロケータは`Mutex`でラップし、
排他の力でスレッドセーフであることを保証することにします。アロケータを
ラップするコードを`kern/src/allocator.rs`に用意しました。今すぐこの
コードを読んでみてください。コードがRustの[GlobalAlloc](https://doc.rust-lang.org/beta/std/alloc/trait.GlobalAlloc.html)
トレイトをどのように実装しているかに注目してください。このトレイトを実装
するには構造体のインスタンスを`#[global_allocator]`として登録する必要が
ありますが、それは`main.rs`ですでに行っています。`#[global_allocator]`
アノテーションでインスタンスが登録されたら[alloc crate](https://doc.rust-lang.org/alloc/index.html)
経由で`Vec`, `String`, `Box`などの構造体が使用できるようになりRustは
`alloc()`と`dealloc()`の呼び出しを登録したインスタンスに転送するように
なります。

#### ユーティリティ: `memory_map`

`kern/src/allocator.rs`ファイルの最後の項目は`memory_map`関数です。
この関数は`Allocator::initialize()`メソッドから呼び出され、そのメソッドは
`kmain()`から呼び出されます。`initialize()`メソッドは後で割り当てと
割り当て解除で使用する内部`imp::Allocator`構造体のインスタンスを構築
します。

`memory_map`関数はシステムのすべての空きメモリの開始アドレスと終了
アドレスを返す役割を持っています。空きメモリの量はシステムのメモリ _総量_
（これはATAGSで知ることができます）と同じとは限らないことに注意して
ください。メモリはカーネルバイナリなどのデータによりすでに使用されて
いるからです。`memory_map`は使用済みメモリを空きメモリとしてマークしない
ように注意する必要があります。これを支援するためにカーネルバイナリの後の
最初のアドレスを保持する`binary_end`変数を宣言してあります。

サブフェーズBで作成した`Atags`の実装と`binary_end`変数を使用して
`memory_map`関数を実装してください。関数が期待される値を返すことを確認
してください。次に、`String::from("Hi!")`(または他のアロケータの呼び出し
を行うコード)を追加し、バンプアロケータが実装されていないので`panic!()`が
起きることを確認してください。`memory_map()`が期待通りの値を返し、
`AllocatorImpl::new()`の呼び出しによりバンプアロケータがまだ実装されて
いないのでパニックになる場合は次のサブフェーズに進んでください。

### サブフェーズD: バンプアロケータ

このサブフェーズでは最も単純なアロケータであるバンプアロケータを実装
します。`kern/src/allocator/bump.rs`で作業します。

**注記: 実装の切り替え**
> `kernel/src/allocator.rs`にある`Allocator`用の`GlobalAlloc`の実装は
> ロックを取った後に内部の`AllocatorImpl`に呼び出しを転送するだけです。
> まずは`bump.rs`にある`bump::Allocator`から始め、後で`bin.rs`にある
> `bin::Allocator`に切り替えます。

バンプアロケータは次のように動作します。`alloc`が呼ばれるとアロケータは
要求されたアライメントを保証するために必要に応じて変更した`current`
ポインタを返し、要求されたアロケートサイズにアライメント要求を満たす
ために必要なサイズを加えた分だけ`current`ポインタを _動かします_。
アロケータがメモリを使い果たした場合はエラーを返します。`dealloc`が
呼ぼれた場合、このアロケータは何もしません。

下図はまず`1k`バイトが割り当てられ、それに続いて`512`バイトが割り当て
られた後に`current`ポインタがどうなるかを示しています。この図では
アライメントが考慮されていないことに注意してください。

![バンプアロケータ](bump_allocator.png)

ここでの課題は`kernel/src/allocator/bump.rs`にバンプアロケータを実装する
ことです。`bump::Allocator`の`new()`, `alloc()`, `dealloc()`メソッドを
実装してください。返されるアドレスに適切なアラインメントを保証するために
必要に応じて作成した`align_up`と`align_down`ユーティリティ関数を使用して
ください。実装の基本的な正しさをチェックするユニットテストを用意しました。
`kernel`ディレクトリで`make test`、または`cargo test`で実行できます。
`_allocator::bump_`ユニットテストをすべてパスしてください。

**警告: オーバーフローする可能性のある操作を実行しないようにしてください**
> 算術オーバーフローを防ぐため、必要に応じて<a href="https://doc.rust-lang.org/std/primitive.usize.html#method.saturating_add">saturating_add()</a>メソッドと
> <a href="https://doc.rust-lang.org/std/primitive.usize.> html#method.saturating_sub">saturating_sub()</a>メソッドを使用してください。

すべてのユニットテストに合格したら、`kmain()`でメモリを割り当て、
アロケータが動作するか「見て」みましょう。以下はその簡単なテストです。

```rust
use alloc::vec::Vec;

let mut v = Vec::new();
for i in 0..30 {
    v.push(i);
    kprintln!("{:?}", v);
}
```

実装が期待通りに動いたら次のサブフェーズに進んでください。

**質問 (bump-chain): `alloc`コールチェーンはどのようになりますか**
> `bump::Allocator::alloc()`が呼ばれたときに実行を一時停止した場合、
> バックトレースはどのようになりますか。`v.push(i)`のような呼び出しが
> どのようにして`bump::Allocator::alloc()`メソッドの呼び出しにつながる
> かを詳しく説明してください。

### サブフェーズE: ビンアロケータ

このサブフェーズではより完全なアロケータである _ビン_ アロケータを実装します。
`kern/src/allocator/bin.rs`で作業します。

ビンアロケータはメモリ割り当てをサイズ _クラス_ （_ビン_）に分割します。
サイズクラスはアロケータが任意に決定します。各ビンはビンのサイズクラスの
メモリへのポインタのリンクリストを保持します。割り当ては最も近いビンに丸め
あげられます。ビンのリンクリストにアイテムがあるとポップされて返されます。
そのビンに空きメモリがない場合、新しいメモリがグローバルプールから割り当てられ、
返されます。割り当て解除は対応するビンのリンクリストにアイテムをプッシュします。

一般的なアプローチの1つはビンを2の累乗に分割することです。たとえば、
アロケータは`3`から`k`までの`n`についてサイズ`2^n`の`k - 2`個のビン（`2^3`,
`2^4`, ..., `2^k`）にメモリ割り当てを分割することを選択することができます。
`2^3`バイト以下の割り当てまたは割り当て解除要求は`2^3`ビンで処理され、
`2^3`バイトと`2^4`バイトの間の要求は`2^4ビン`で処理されます。

- ビン 0 (`2^3`バイト): `(0, 2^3]`バイトの割り当てを処理する
- ビン 1 (`2^4`バイト): `(2^3, 2^4]`バイトの割り当てを処理する
- ...
- ビン 29 (`2^32`バイト): `(2^31, 2^32]`バイトの割り当てを処理する

#### リンクリスト

`kern/src/allocator/linked_list.rs`にメモリアドレスの _侵入型_ リンクリストの
実装を用意しました。また、`kern/src/allocator/bin.rs`で`LinkedList`構造体を
インポートしています。

**注記: 侵入型リンクリストとは何か**
> 侵入型リンクリストでは`next`ポインタと`next`ポインタが（もしあれば）`push`
> されたアイテム自体に格納されています。侵入型リンクリストではアイテムの管理の
> ためにアイテム以外に追加のメモリを必要としません。一方、ユーザはこれらの
> ポインタのためにアイテム内に有効なストレージを用意しなければなりません。

新しい空のリストは`LinkedList::new()`を使って作成します。新しいアドレスを
リストに追加するには`push()`を使用します。リストの最初のアドレスは（もしあれば）
`pop()`を使用して削除して返すか、`peek()`を使用して（削除せずに）返すことが
できます。

```rust
let mut list = LinkedList::new();
unsafe {
    list.push(address_1);
    list.push(address_2);
}

assert_eq!(list.peek(), Some(address_2));
assert_eq!(list.pop(), Some(address_2));
assert_eq!(list.pop(), Some(address_1));
assert_eq!(list.pop(), None);
```

LinkedListは2つのイテレータを公開しています。1つは`iter()`により得られる
ものでリスト内のすべてのアドレスをイテレートします。もう1つは`iter_mut()`で
返されるものでリスト内の各アドレスを参照する`Node`を返します。`Node`の
`value()`メソッドと`pop()`メソッドを使って各々リストから値を読み取ったり、
値をポップしたりすることができます。

```rust
let mut list = LinkedList::new();
unsafe {
    list.push(address_1);
    list.push(address_2);
    list.push(address_3);
}

for node in list.iter_mut() {
    if node.value() == address_2 {
        node.pop();
    }
}

assert_eq!(list.pop(), Some(address_3));
assert_eq!(list.pop(), Some(address_1));
assert_eq!(list.pop(), None);
```

今すぐ`LinkedList`のコードを読んでください。`push()`を安全に呼び出すために
必要な安全性のプロパティに特に注意してください。メモリアロケータでビンを管理
するために`LinkedList`を使いたいと思うでしょう。

**質問 (ll-aloc): 侵入型リンクリストを使うとなぜ便利なのですか**
> メモリアロケータに _侵入型_ リンクリストを使うことはとても便利な決定である
> ことがわかりました。代わりに普通の「push時に追加のメモリ割り当てを行う」
> リンクリストを使うことにしていたらどんな問題が起きたでしょうか。

#### フラグメンテーション

_フラグメンテーション_ とは未使用だが割り当てできないメモリのことをいいます。
アロケータが割り当てを行う過程で使用できないメモリを大量に生成すると
_大きなフラグメンテーション_ が発生したり、生成されたりします。_理想的な_
アロケータのフラグメンテーションはゼロです。リクエストを処理するのに必要
以上のメモリを使うことはなく、常に新しいリクエストを処理するために利用可能な
メモリを使うことができます。実際には、他の設計上の制約を考えると、これは
望ましいことでも達成可能なことでもありません。しかし、フラグメンテーションを
できるだけ少なくすることは優れたメモリアロケータの重要な品質です。

通常、2種類のフラグメンテーションを定義します。

- **内部フラグメンテーション**

  アロケータが割り当てを丸める上げるために無駄になるメモリの量です。
  ビンアロケータの場合、リクエストされたアロケーションサイズとそれが処理
  されるビンのサイズクラスとの差です。

- **外部フラグメンテーション**

  アロケータが新しい割り当てのために空きメモリを使用できないために
  無駄になるメモリの量です。これはビンアロケータの場合、すべての空き領域の
  合計が  要求されたサイズ以上であるにもかかわらず、リクエストされたより
  大きなアロケーションを処理するために使用することができないすべてのビンの
  空き領域の量に相当します。

作成するアロケータは合理的な範囲内でフラグメンテーションを抑えるように
する必要があります。

#### 実装

`kern/src/allocator/bin.rs`にあるビンロケータを実装してください。ビン類似の
アロケータであることを除けばアロケータの設計は完全にあなた次第です。
アロケータは解放されたメモリを再利用できなければ _なりません_。また、
アロケータは過剰な内部フラグメンテーションや外部フラグメンテーションを
起こしては _いけません_。`make test`で実行できるユニットテストはこれらの
特性をチェックします。`kern/src/allocator.rs`にある`AllocatorImpl`を
`bin::Allocator`に変更し、作成したビンアロケータがグローバルな割り当てに
使われるようにすることを忘れないでください。

アロケータがすべてのテストに合格し、グローバルアロケータとして設定したら
次のフェーズに進んでください。

**質問 (bin-about): あなたのアロケータはどのようなものですか**
> あなたのアロケータの設計を簡単に説明してください。特に以下の質問に
> 答えてください。
> - どのサイズクラスを選びましたか、それはなぜですか。
> - アロケータはどのようにアラインメントを処理しますか。
> - 設計の選択において内部フラグメンテーションと外部フラグメンテーションの
>   制限はなんですか。

**質問 (bin-frag0: アロケータのフラグメンテーションをどのように減らすことができましたか**
> あなたのアロケータはおそらく必要以上にフラグメンテーションを生成
> するでしょう。それでいいです。どうすればもっと良くなりますか。
> アロケータのフラグメンテーションを改善するための簡単な設計案を
> 2つ書いてください。

## フェーズ2: 32ビットの脂質

このフェーズでは読み取り専用のFAT32ファイルシステムを実装します。主に
`lib/fat32`ディレクトリで作業します。

### ディスクとファイルシステム

ディスク上のデータは1つ以上のファイルシステムにより管理されます。メモリ
アロケータと同じように、ファイルシステムはディスクの空き領域の管理、
割り当て、割り当て解除を行います。アロケータにより管理されるメモリとは
異なり、ディスクは _永続的_ です。ディスク障害がなければ、割り当てられた
ディスク領域への書き込みはマシンの再起動後を含め、将来のどの時点でも見る
ことができます。一般的なファイルシステムにはLinuxのEXT4、macOSのHFS+とAPFS、
WindowsのNTFSなどがあります。FAT32はLinux、macOS、Windowsを含むほとんどの
OSで実装されているもう1つのファイルシステムであり、古いバージョンのWindowsや
後期バージョンのDOSで使用されていました。FAT32の主な利点はそのユビキタス性
です。これほどクロスプラットフォームでサポートされているファイルシステムは
他にありません。

物理ディスク上に複数のファイルシステムを常駐させるために、ディスクは
_パーティションに分割_ することができます。各パーティションは異なる
ファイルシステム用に_フォーマット_ できます。ディスクをパーティションに
分割するにはディスク上の既知の場所に各パーティションの始まりと終わり、
パーティションが使用するファイルシステムのタイプを示すテーブルを書き出し
ます。一般的に使用されているパーティション分割方式ではマスターブートレコード
（MBR）を使用します。MBRには4つのパーティションエントリのテーブルがあり、
各パーティションは未使用の場合もありますが、パーティションの開始位置と
サイズを示しています。GPTはより現代的なパーティション分割方式であり、中でも
5つ以上のパーティションをもつことができます。

この課題ではFAT32パーティションを含むMBRで分割されたディスクを解釈する
コードを書きます。これはRaspberry Piで使用される組み合わせです。SDカードは
FAT32にフォーマットされた1つのパーティションを持つMBRスキームを使用します

### ディスクレイアウト

以下の図はFAT32ファイルシステムを持つMBRでパーティションされたディスクの
物理的なレイアウトを示しています。

![ディスクレイアウト](disk_layout.png)

PDF文書の[「FATの構造」](fat-structs.md)にはサイズ、フィールドの位置、
フィールドの説明など、FATのすべての構造に関する具体的な詳細が記載されて
います。ファイルシステムを実装する際にはこの文書を参照することになるで
しょう。また、ファイルシステムを実装する際には[WikipediaのFAT32設計の項](https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system)も
役に立つかもしれません。

#### マスターブートレコード

MBRは常にディスクのセクタ0にあります。MBRには4つのパーティションエントリが
あり、各々はパーティションのタイプ（パーティション上のファイルシステム）、
そのパーティションのディスクの先頭からのオフセット（セクタ単位）、
パーティションがブート可能なシステムで使用されているか否かを示すブート/
アクティブインジケータを示しています。CHS（シリンダ、ヘッダ、セクタ）
フィールドは最近の実装では通常無視されることに注意してください。みなさんも
このフィールドは無視するべきです。FAT32パーティションのパーティションタイプは
`0xB`か`0xC`です。

#### 拡張BIOSパラメタブロック

FAT32パーティションの最初のセクタには拡張BIOSパラメタブロック（EBPB）が
含まれています。EBPB自体はBIOSパラメータブロック（BPB）で始まります。
これらの構造を合わせてFATファイルシステムのレイアウトを定義しています。

EBPBで特に重要なフィールドは「予約セクタ数」を示すものです。これはFAT32
パーティションの開始位置からの（セクタ単位の）オフセットであり、そこに
（次に説明する）FATが存在します。最後のFATの直後には _クラスタ_ のデータを
保持する _データ領域_ があります。FAT、データ領域、クラスタについては次に
説明します。

#### クラスタ

FATファイルシステムに保存されるデータはすべて _クラスタ_ に分けられます。
クラスタのサイズはEBPBの「クラスタあたりのセクタ数」フィールドによって
決まります。クラスタは2から番号付けされます。図にあるように、クラスタ2の
データはデータ領域の先頭に位置し、クラスタ3のデータはクラスタ2の直後に
位置します。以下同様です。

#### ファイルアロケーションテーブル

_FAT_ は"file allocation table"の略です。その名の通り、FATはFATエントリの
テーブル（配列）です。FAT32では各エントリは32ビット幅であり、これが名前の
由来です。完全なFATのサイズはEBPBのフィールドである「FATあたりのセクタ数」と
「セクタあたりのバイト数」によって決まります。冗長性のためにFAT32ファイル
システムには複数のFATを含めることができます。FATの数はEBPBの同名の
フィールドによって決定されます。

エントリ0と1を除いて、FATの各エントリがクラスタの _ステータス_ を決定
します。エントリ2はクラスタ2のステータス、エントリ3はクラスタ3のステータス、といった具合です。各クラスタはFAT内に関連するFATエントリを持っています。

FATエントリの0と1は特別です。

- エントリ 0: `0xFFFFFFFN`, IDを示す
- エントリ 1: _チェイン終了_ マーカーを示す

この2つのエントリを除けば、他のすべてのエントリはそのデータがデータ領域に
あるクラスタに対応します。FATエントリは物理的には32ビット幅ですが、実際に
使用されるのは28ビットだけで、上位4ビットは無視されます。エントリの値は
次のいずれかです。

- `0x?0000000`: 未使用の空きクラスタ
- `0x?0000001`: 予約
- `0x?00000002 - 0x?7FFFFFEF`: データクラスタ; 値はチェーン内の次のクラスタを指す
- `0x?7FFFFFF0 - 0x?7FFFFFF6`: 予約
- `0x?7FFFFFF7`: クラスタ内の不良ブロック、または予約済みクラスタ
- `0x?7FFFFFF8 - 0x?7FFFFFFF`: チェイン内の最後のクラスタ。EOCマーカーであるべきだがそうでない場合もある

#### クラスタチェーン

クラスターは _チェーン_ （クラスターのリンクリスト）を形成します。ある
クラスタがデータに使用されている場合、対応するFATのエントリの値はチェーンの
次のクラスタへのポインタかチェーンの最後のクラスタであることを示すEOCマーカーのいずれかです。

例として、8つのエントリを持つFATを描いた下図を考えます。

![クラスタチェーン](cluster_chain.png)

クラスタはどのクラスタに属しているかを示すために色分けされています。
最初の2つのエントリはそれぞれIDとEOCマーカーです。エントリ2はクラスター2が
データクラスタであり、そのチェーンは1クラスター長であることを示しています。
エントリ3はクラスタ3がデータクラスタであり、そのチェーンの次のクラスタは
クラスタ5であり、チェーンの最後のクラスタはクラスタ6であることを示して
います。同様に、クラスタ7と5はチェーンを形成しています。クラスタ8はフリーで
未使用です。

#### ディレクトリとエントリ

クラスタチェーンはファイルやディレクトリ用のデータを構成します。
_ディレクトリ_ はファイル名と関連するメタデータをファイルの日付用の
開始クラスタにマップする特別なファイルです。具体的には、ディレクトリは
ディレクトリエントリの配列です。各エントリはエントリの名前、エントリは
ファイルかディレクトリか、その開始クラスタなどを示しています。

ルートディレクトリはディレクトリエントリ経由でリンクされていない唯一の
ファイルまたはディレクトリです。ルートディレクトリの開始クラスタはEBPBに
記録されます。そこから、他のすべてのファイルの場所を決定することができます。

歴史的な理由から、すべての物理ディレクトリエントリは2つの異なる方法で解釈
できます。エントリーの属性フィールドはエントリがどちらの方法で解釈される
べきかを示すためにオーバーロードされています。エントリは以下のいずれかです。

- 通常のディレクトリエントリ
- _長いファイル名_ エントリ。

長いファイル名（LFN）エントリは11文字を超えるファイル名を許容するために
FAT32から追加されました。エントリが11文字を超える長さの名前を持つ場合、
通常のディレクトリエントリの前にエントリ名のバイト数を格納するために
必要な数のLFNエントリが置かれます。LFNエントリは物理的に並べ替えられる
ことはありません。エントリの順番を示すフィールドが含まれています。そのため、
LFNエントリの物理的な順序を頼りに個々のコンポーネントがどのように結合されて
いるかを判断することはできません。

#### まとめ

以下に進む前に[「FATの構造」](fat-structs.md)とあなたの理解を照らし合わせて
ください。そして次の質問に答えてください。

**質問 (mbr-magic): 最初のセクタがMBRかどうかをどのように判断しますか**
> ディスクの最初のセクタにMBRがあるとは限りません。最初のセクタに有効なMBRが
> 含まれているかどうかをどのように判断しますか。

    オフセット`510-511`が`9x55, 0xAA`であれば有効なMBRである

**質問 (max-clusters): FAT32クラスタの最大数はいくつですか**
> FAT32の設計にはファイルの制約がいくつかあります。FAT32ファイルシステムが
> 含むことができるクラスタの最大数はいくつですか。何がその制約を規定して
> いますか。この制約はFAT16というファイルシステムでも同じだと思いますか、
> それとも違うとおもいますか。

    FAT32: 合計論理セクタ数(BPB 32-35) / クラスタあたりセクタ数(BPB 11-12)
    FAT16: 合計論理セクタ数(BPB 19-20) / クラスタあたりセクタ数(BPB 11-12)
    FAT32の合計論理セクタ数は4バイトで最大4096M-1個指定できるが、FAT16では2バイトで指定できるのは最大64K-1個なので両者は異なる

**質問 (max-file-size): 1ファイルの最大サイズは**
> ファイルのサイズに制限はありますか。もしあるのなら1ファイルの最大サイズは
> 何バイトで、何で規定されていますか。
>  **ヒント**
>  ディレクトリエントリの構造をよく見てください

    ファイルのバイト単位のサイズが4バイトで定義されているので最大サイズは4096MB-1である

**質問 (lfn-identity): エントリがLFNであるか否かはどのように判断しますか**
> ディレクトリエントリのバイトが与えられたとき、そのエントリがLFNエントリか
> 通常のディレクトリエントリかをどのように正確に判断しますか。どのバイトを
> 読み取るべきか、その値からどのように判断するかを具体的に記述してください。

    ディレクトリエントリのオフセット11のバイトが通常のエントリかLFNエントリかを決定する。
    値が0x0Fの場合はLFNエントリ、その他の値の場合は通常のエントリである。

**質問 (manual-lookup): `/a/b/c.txt`をどのように検索しますか**
> EBPBが与えられたとき、ファイル`/a/b/c.txt`の開始クラスタを見つけるために
> 取るべき一連の手順を記述してください。

    1. EBPB オフセット44からルートディレクトリのクラスタ番号root_cを取得する
    2. root_cから始まるクラスタチェーンをたどり、ディレクトリエントリの
       オフセット0-8が"a"で、オフセット11が0x10のエントリを見つける
    3. 当該エントリの(オフセット 20-21 << 16 | オフセット 26-21) でこの
       ディレクトリの開始クラスタの番号を得る
    4. 当該クラスタ番号から始まるチェーンをたどり、ディレクトリエントリの
       オフセット0-8が"b"で、オフセット11が0x10のエントリを見つける
    5. 当該エントリの(オフセット 20-21 << 16 | オフセット 26-21) でこの
       ディレクトリの開始クラスタの番号を得る
    6. 当該クラスタ番号から始まるチェーンをたどり、ディレクトリエントリの
       オフセット0-8が"c"、オフセット8-3が"txt"のエントリを見つける
    7. 当該エントリの(オフセット 20-21 << 16 | オフセット 26-21) でこの
       ディレクトリの開始クラスタの番号を得る

### コードの構成

どのような種類のファイルシステムであれそれを書くのは大変な作業であり、
読み取り専用のFAT32ファイルシステムも例外ではありません。`lib/fat32`
プロジェクトにあるコードは実装のための基本的な構造を提供していますが、
設計上の多くの決定や実装の大部分はあなた次第です。

これからその構造について説明します。さまざまなコンポーネントとそれらが
どのように組み合わされているかを説明しますので`fat32/src`ディレクトリに
ある関連するコードを読んでください。

#### ファイルシステムトレイト

`traits/mod.rs`をルートとする`traits`モジュールは**7つ**のトレイトの宣言と
**1つの**構造体の宣言を提供しています。ファイルシステムの実装は主にこの
7つのトレイトを実装することになります。

1つの構造体`Dummy`は7つのトレイトのうち5つのトレイトのダミー実装を提供
する型です。この型はプレースホルダとして役立ちます。この型はコードの
いくつかの場所ですでに使用されていることに気づくでしょう。課題に取り
組んでいる間にあたなもこの型が役に立つことがわかるでしょう。

`traits/`ディレクトリにあるコードは次の順序で読んでください。

- **`traits/block_device.rs`にある`BlockDevice`トレイトのドキュメントを読む**

  ファイルシステムは物理バッキングストレージと仮想バッキングストレージ用に
  ジェネリックに書かれています。言い換えれば、ファイルシステムは`BlockDevice`
  トレイトを実装している限り、_任意の_ デバイス上で動作します。ファイル
  システムのテストの際には通常、`BlockDevice`はローカルファイルシステム上の
  ファイルにより支援されます。Raspberry Pi上でファイルシステムを実行する
  際には、`BlockDevice`は物理的なSDカードとEMMCコントローラにより支援
  されます。

- **`traits/fs.rs`にある`File`, `Dir`, `Entry`の各トレイトを読む**

  これらのトレイトはファイルシステムにおいてファイル、ディレクトリ、
  ディレクトリエントリが（最小限）何を意味するかを定義します。トレイトの
  関連する型が互いに依存していることに注意してください。たとえば、
  `Entry`トレイトは`File`トレイトを実装するために関連する`File`型を
  必要とします。

- **`traits/fs.rs`にある`FileSystem`トレイトを読む**

  このトレイトはファイルシステムが何を意味するかを定義し、その関連型を
  通じて残りの特性を統一します。特に、`File`トレイトを実装する`File`、
  `Entry`の関連型がファイルシステムの`Entry`関連型と同じである`Dir`
  トレイトを実装する`Dir`、最後にファイルシステムと同じ`File`と`Dir`
  関連型を持つ`Entry`を実装する`Entry`の関連型を必要とします。これらの
  制約が一つになることにより`File`、`Dir`、`Entry`の具体的な型が1つだけ
  存在することが保証されます。

- **`traits/metadata.rs`にある`Metadata`トレイトを`Timestamp`トレイトを読む**

  すべての`Entry`はファイルやディレクトリの詳細へのアクセスを可能にする
  `Metadata`と関連付けられる必要があります。`Timestamp`トレイトはある時点を
  指定する型が必要とする操作を定義します。

#### キャッシュパーティション

`vfat/cache.rs`にある`CachedPartition`構造体は`BlockDevice`と`Partition`を
ラップし、EBPBで指定された論理セクタをディスクで指定された物理セクタに変換
します。まさにこれを行うメソッドである`virtual_to_physical()`の実装を用意
しました。ディスクからどの物理セクタを読み取るかを決定する際にはこの
メソッドを使用する必要があります。`CachedPartition`はキャッシュレイヤも
提供します。これは物理ディスクを直接アクセスする際にかかる高価なコストを
削減します。その`get()`メソッドと`get_mut()`メソッドを使用するとセクタを
キャッシュから克雪参照することができます。

製品OSにおける実際のディスクキャッシュの実装はディスクキャッシュを非常に
スマートに管理しています。その実装はディスクアクセスパターンを予測して
ディスクコンテンツを事前ロードし、近々にアクセスがないとキャッシュを
ディスクに書き戻します。簡単にするため私たちの実装ではこのような機能は
実装しません。ディスクコンテンツをメモリに無期限に保持します。

#### ユーティリティ

`util.rs`ファイルにはスライス(`&[T]`)とベクタ(`Vec<T>`)用の2つの
_拡張トレイト_ の宣言と実装が含まれています。これらのトレイトはベクトル型と
スライス型で何らかの条件が成立する場合に、ある型のベクトルまたはスライスから
別の型のベクトルまたはスライスにキャストするために使用できます。たとえば、
`&[u32]`から`&[u8]`にキャストするには次のように書きます。

```rust
use util::SliceExt;

let x: &[u32] = &[1, 2, 3, 4];
assert_eq!(x.len(), 4);

let y: &[u8] = unsafe { x.cast() };
assert_eq!(y.len(), 16);
```

#### MBRとEBPB

`mbr.rs`にある`MasterBootRecord`構造体は`BlockDevice`のMBRの読み込みと
解析を行います。同様に、`vfat/ebpb.rs`にある`BiosParameterBlock`構造体は
FAT32パーティションのBPBとEBPBの読み込みと解析を行います。

#### ファイルシステム

`vfat/vfat.rs`ファイルにはファイルシステムそのものである`VFat`構造体が
含まれています。この構造体には`CachedPartition`が含まれていることに
注意してください。あなたの実装では提供された`BlockDevice`を
`CachedPartition`でラップする必要があります。

**注記: VFATとは**
> VFATはFAT32の前身であるMicrosoftのもう一つのファイルシステムです。
> この名前は残念ながらFAT32の同義語となっており、ここでもその悪い伝統を
> 引き継いでいます。

`vfat/vfat.rs`ファイルでは`VFatHanle`トレイトも提供している。このトレイトは
スレッドセーフな方法で`VFat`インスタンスへの可変アクセスを共有する方法を
定義しています。ファイルシステムを実装する際にファイル構造体とディレクトリ
構造体の間でファイルシステム自体への可変アクセスを共有する必要がでてくる
はずです。これを行うためにこのトレイトを利用することになります。ハンドルの
複製には`clone()`メソッドを、コードが`&mut VFat`にアクセスできる
クリティカルセクションに入るには`lock()`メソッドを使用してください。

`VFat`、および、`File`や`Dir`などのファイルシステムのいくつかの型は
`VFatHandle`トレイトを実装している`HANDLE`型パラメータに対してジェネリック
です。この設計によりライブラリのユーザは自分の型に`VFatHandle`トレイトを
実装することでロック実装を _注入する_ ことができます。私たちのカーネルは
内部で独自の`Mutex`実装を使用している`PiVFatHandle`構造体を使用しています
が、テストコードでは標準ライブラリの型で実装されている`StdVFatHandle`
構造体を使用しています。

`VFat`は`VFatHandle`に対してジェネリックですが`VFat`は物理的には
`VFatHandle`を所有していません。関係は逆です。`VFatHandle`の実装者は
`VFatを自分のフィールドとして管理します。このような関係を表すために
`VFat`にはゼロサイズのマーカ型である[PhantomData](https://doc.rust-lang.org/core/marker/struct.PhantomData.html)が
追加されています。

`&'a HANDLE`に対する`FileSystem`トレイトの実装はすでに開始されています。
また、`FileSystem`の`from()`メソッドが`HANDLE`を返すことにも注意して
ください。あなたの主な仕事は`from()`メソッドの実装と`&'a HANDLE`に対する `FileSystem`トレイトの実装を完了することです。そのためにはファイルシステム
トレイトの残りのトレイトを実装する構造体を実装する必要があります。

これを助けるために`vfat/`に以下のコードを用意しました。

- `error.rs`

  FAT32の初期化で発生する可能性のあるエラー示す`Error`列挙型を含んでいます。

- `file.rs`

  未完の`traits::File`実装を持つ不完全な`File`構造体を含んでいます。

- `dir.rs`

  `trait::Dir`を実装するための不完全な`Dir`構造体が含まれています。
  また、ディスク上の生のディレクトリエントリの未完成の構造体の定義も
  含まれています。

- `entry.rs`

  `traits::Entry`を実装するための不完全な`Entry`構造体を含んでいます。

- `metadata.rs`

  生の、ディスク上のエントリのメタデータ（`Date`, `Time`, `Attributes`）に
  マップする構造体と、適切なファイルシステムトレイトを実装する必要がある
  不完全な構造体（`Timestamp`,, `Metadata`）が含まれています。

- `fat.rs`

  `FAT`エントリの値をラップし、その`FAT`エントリに対応するクラスタの
  ステータスを簡単に読み込むために使用できる`FatEntry`構造体が含まれて
  います。

- `claster.rs`

  生のクラスタ数をラップし、論理クラスタ番号の読み込みに使用できる
  `Cluster`構造体が含まれています。

ファイルシステムを実装する際にはこれらの構造体と型を完成させて使用する
必要があります。これらの構造体にヘルパーメソッドを追加することを恐れないで
ください。ただし、私たちが用意したトレイトの定義や既存のメソッドの
シグネチャは変更してはいけません。

`vfat.rs`を始めとするすべてのコードに目を通し、すべてがどのように
組み合わされているかを理解してください。

### 4-3: 実装

以上で読み取り専用のFAT32ファイルシステムを実装する準備が整いました。
どのような順序で実装を進めてもかまいません。

実装をチェックするためにやや厳密なテストセットを用意しました。テストでは
`ext/fat32-imgs`にあるファイルを使用します。このディレクトリにはいくつかの
実際のMBR、EBPB、FAT32ファイルシステムイメージと、我々のリファレンス実装に
対して実行されたファイルシステムトラバーサル用のハッシュ値があります。
`Bless`(Linux)、`Hex Fiend`(macOS)、`HxD`(Windows)などの16進エディタを
使用して生バイナリを再度解析し、理解度を確認する際に役に立つでしょう。

**注記: まずFat32テストイメージを展開してください**
> `ext/fat32-imgs`で提供しているイメージは圧縮されています。テストする前に
> まずアーカイブを解凍する必要があります。`bin/extract-fat.sh`を使ってそれを
> 行うことができます。

`cargo test`でテストを実行することができます。デバッグ中は
`cargo test -- --nocapture`でテストを実行することにより、Cargoが出力を
`stdout`や`stderr`にキャプチャしないようにしたほうが良いかもしれません。
また、実装が進むにつれて新しいテストを追加するのも役に立つでしょう。将来の
マージコンフリクトを防ぐために新しいテストは`tests.rs`とは別のファイルに
追加してください。

実装は以下のガイドラインに従ってください。

- **できる限り意味のある型を使用すること**

  たとえば、生の時間フィールドを表すのに`u16`ではなく`Time`構造体を
  使ってください。

- **できるだけ`unsafe`なコードは避けること**

  レファレンス実装では非`union`の`unsafe`は合計4行しか使用していません。
  さらに、unionのアクセスに関連する`unsafe`を3行使用しています。あなたの
  実装の`unsafe`コードの数はこれと同程度であるべきです。

- **必要に応じてヘルパーメソッドを使うことで重複を避けること**

  一般的な動作をヘルパーメソッドに抽象化することはしばしば有用です。
  理にかなっている場合はそうするべきです。

- **実装はクラスタサイズやセクタサイズに依存しないこと**

  セクタサイズやクラスタサイズに特定の値をハードコードしたり仮定したり
  してはいけません。作成する実装はEBPBに記録されている512の整数倍の任意の
  クラスタサイズとセクタサイズで機能しなければなりません。

- **不必要にダブルバッファにしないこと**

  メモリを節約するために、すでにセクタキャッシュに保持されているセクタは
  メモリに読み込まないようにしてください。

推奨の実装アプローチ方法は以下の通りです。

1. `mbr.rs`にあるMBRのパースを実装する

   実装には`unsafe`メソッドを使用する必要があるでしょうが、1行だけです。
   考えられる候補は`slice::from_raw_parts_mut()`か`mem::transmute()`です。
   `mem::transmute()`は信じられないほど強力なメソッドです。できれば避ける
   べきです。できない場合は使用する前にその意味を十分に理解する必要があります。

   `Debug`を実装する際には`Formatter`の`debug_struct()`メソッドを使用して
   ください。`CachedPartition`用に用意した`Debug`の実装を参考にしてください。

    **注記: Rustにおけるパック構造体**
    > Rustはアドレスのアラインメントに対し非常に厳格です。Rustのすべての
    > 参照は基礎となる型のアライメントを尊重する必要があります。この
    > 要件のためパック構造体のフィールドを借用すると不正になることがあります。
    > この制約は、値を一時変数にコピーしてそのローカル変数を借用する
    > 構文`&{ struct.field }`で回避することができます。

2. `vfat/ebpb.rs`にあるEBPBのパースを実装する

   MBRと同様に実装には`unsafe`メソッドを使用する必要があるでしょうが、
   1行だけです。

3. MBRとEBPBの実装をテストする

   MBRとEBPBをモックアップして、実装が値を正しくパースすることを確認して
   ください。`Cursor<&mut[u8]>`用の`BlockDevice`の実装を提供していることに
   注意してください。構造体は次の文を使用してプリティプリントできることを
   思い出してください。

   ```rust
   println!("{:?}", x);
   ```

4. `vfat/cache.rs`にある`CachedPartition`を実装する

5. `vfat/vfat.rs`にある`VFat::from()`を実装する

   `VFAT::from()`の実装にはすでに作成した`MasterBootRecord`,
   `BiosParameterBlock`, `CachedPartition`を使用してください。MBRと
   EBPBの実装に対して行ったように実装をテストしてください。

6. `vfat/fat.rs`にある`FatEntry`を実装する

7. `VFat::fat_entry`, `VFat::read_cluster()`, `VFat::read_chain()`を実装する

   これらのヘルパーメソッドは`Cluster`、または`Cluster`から始まるチェーン
   からバッファへの読み込みを抽象化します。これらのメソッドを実装するには
   クラスタ番号からディスクセクタを計算するメソッドなど、他のヘルパー
   メソッドが必要になるでしょう。`Cluster`型にヘルパーメソッドを追加すると
   よいでしょう。`read_cluster()`と`read_chain()`を実装する際には
   `VFat::fat_entry()`メソッドを使用する必要があります。

8. `vfat/metadata.rs`ファイルを完成させる

   `Date`型, `Time`型, `Attributes`型は、ディスク上のディレクトリエントリの
   フィールドに直接マップする必要があります。これらを実装する際には
   [「FATの構造」](fat-structs.md)を
   参照してください。`Timestamp`型と`Metadata`型には相当する構造が
   ディスク上にありませんが、ディスク上の生の構造をよりきれいに抽象化
   する役割を果たし、`Entry`, `File` `Dir`の各トレイトを実装する際に
   役に立ちます。

9. `vfat/dir.rs`にある`Dir`と`vfat/entry.rs`にある`Entry`を実装する

   ディレクトリの最初の`Cluster`とファイルシステムハンドルを格納する
   フィールドを`Dir`に追加することから始めてください。次に、`Dir`用の
   `trait::Dir`トレイトを実装してください。`Dir`の実装中は`vfat/file.rs`に
   ある`File`型用にダミーのトレイト実装を提供すると良いでしょう。
   `Iterator<Item = Entry>`を実装するセカンダリ構造体を作成して
   `entries()`メソッドからこの構造体を返すことになるでしょう。`entries()`を
   実装する際には最大でも1行の`unsafe`を使用する必要があるでしょう。
   ここで提供している`VecExt`トレイトと`SliceExt`トレイトの実装が特に
   役に立つことがわかるでしょう。`Dir`の実装中は頻繁に[「FATの構造」](fat-structs.md)を参照する必要があることに注意してください。

   **エントリのパース**


   ディレクトリエントリの名前をパースする際には非LFNベースのディレクトリ
   エントリにはファイルの拡張子を区切るために手動で`.`を追加する必要が
   あります。ファイルの拡張子が空でない場合のみ`.`を追加するべきです。
   最後に、LFNエントリをパースする際にはUTF-16文字をデコードする必要が
   あります。それを行うには[`decode_utf16()`](https://doc.rust-lang.org/core/char/fn.decode_utf16.html)関数を
   使用してください。長いファイル名をパースする間はUTF-16文字を1つ
   以上の`Vec<u16>`に格納すると便利です。

   **`Dir::find()`**

   `Dir::find()`の実装は`Dir`用の`trait::Dir`を実装した _後に_ 行う
   必要があります。`Dir::find()`は大文字と小文字を区別しないことに
   注意してください。実装は比較的短くなるはずです。大文字小文字を区別
   しない比較には[`eq_ignore_ascii_case()`](https://doc.rust-lang.org/std/primitive.str.html#method.eq_ignore_ascii_case)
   メソッドを使用することができます。

10. `vfat/file.rs`にある`File`を実装する

    ファイルの最初の`Cluster`とファイルシステムハンドルを格納するフィールドを
    `File`に追加することから始めてください。次に `trait::File`トレイトと
    必要なスーパートレイトを実装してください。必要に応じて、`entries()`から
    返すイテレータを変更してください。

11. `vfat/vfat.rs`にある｀VFat::open()`を実装する

    最後に`VFat::open()`メソッドを実装してください。`Path`のコンポーネント
    のイテレートには[`components()`](https://doc.rust-lang.org/std/path/struct.Path.html#method.components)
    メソッドを使用してください。`shim`ライブラリで提供している`Path`の
    実装にはファイルシステムを必要とするメソッドは含まれていないことに
    注意してください。これには`read_dir()`, `is_file()`, `is_dir()`などが
    あります。

    あなたの実装では作成した`Dir::find()`メソッドを使用してください。
    `Dir`にヘルパーメソッドを追加すると便利でしょう。

実装がすべての単体テストに合格し、期待通りに動作したら、再度喜びに浸る
ことができます。リアルなファイルシステムを実装したのです。十分に喜んだら、
次のフェーズに進んでください。

**質問 (undefined-behavior): スケルトンコードに未定義の動作はありましたか**
> _任意の加点問題です_。課題の作成中に、コメントで正当化されたものを除いて、
> スケルトンコードに未定義の動作、または不健全なAPIがあることに気づきましたか。
> それはどのようなRustの要件に違反していますか。それらが実際にうまく動作
> しているように見えるのはなぜですか。どうすれば修正できますか。

## フェーズ3: サドルアップ

このフェーズではRustの[FFI: Foreign function interface](https://en.wikipedia.org/wiki/Foreign_function_interface)を
使い、既存のRaspberry Pi 3用のSDカードコントローラドライバとインタフェース
します。RustのFFIについては[TRPL](https://doc.rust-jp.rs/book-ja/ch19-01-unsafe-rust.html#extern%E9%96%A2%E6%95%B0%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%A6%E5%A4%96%E9%83%A8%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%99)で
詳しく説明されています。また、OSが使用するファイルシステムのグローバル
ハンドルも作成します。主に `kernel/src/fs` で作業することになります。

### サブフェーズA: SDドライバFFI

RustのFFIはRustのコードと他のプログラミング言語で書かれたソフトウェアが
相互作用することを可能にします。外部の項目は`extern`ブロックで宣言します。

```rust
extern {
    static outside_global: u32;
    fn outside_function(param: i16) -> i32;
}
```

これは外部の`outside_function`と`outside_global`を宣言しています。この
関数とグローバル変数は次のように使用します。

```rust
unsafe {
    let y = outside_function(10);
    let global = outside_global;
}
```

`unsafe`を使用する必要があることに注意してください。Rustは指定したシグネチャが
正しいことを保証できないため`unsafe`の使用が必要になります。Rustコンパイラは
関数呼び出しや変数の読み込みを要求されたとおりそのまま実行します。
言い換えれば、他での`unsafe`の使用と同様にコンパイラはあなたが行ったことが
正しいと仮定します。リンク時にはプログラムが正常にリンクされるためには
`outside_function`と`outside_global`というシンボルが存在しなければなりません。

Rust関数を外部プログラムから呼び出すには、関数の場所（メモリアドレス）が
既知のシンボルでエクスポートされていなければなりません。通常、Rustは
バージョンと名前空間を管理するために関数シンボルを _マングル_ します。
そのため、デフォルトでは、Rustがある関数に対して生成するシンボルを知ることは
できず、外部プログラムからその関数を呼び出すことができません。Rustがシンボルを
マングルしないようにするには`#[no_mangle]`属性を使用します。

```rust
#[no_mangle]
fn call_me_maybe(ptr: *mut u8) { .. }
```

Cプログラムではこの関数を次のようにして呼び出すことができ舞う。

```c
void call_me_maybe(unsigned char *);
call_me_maybe(...);
```

**質問 (foreign-safety): どうしてRustは外部コードの使用が安全であると保証できないのか**
> どうしてRustは外部コードの使用が安全であると保証できないのか説明して
> ください。また、Rustは _他の_ Rustコードはたとえ現在のクレートの外に
> あっても安全であると保証できるのに、どうしてRust以外のコードに対しては
> 同じことができないのか説明してください。

**質問 (mangling): どうしてRustはシンボルをマングルするのか**
> Cはシンボルをマングルしません。一方、C++とRustはします。名前の
> マングリングを必要とすることに関してこれらの言語の違いはなんですか。
> Rustが名前のマングリングを _しない_ としたら何が問題になるのか、
> 具体的な例を挙げてください。

#### SDドライバ

コンパイル済みのSDカードドライバライブラリを`kern/.cargo/libsd.a`に
用意しました。また、ライブラリがカーネルにリンクされるようにビルド
プロセスを変更しました。`kern/src/fs/sd.rs`の`extern`ブロックに
ライブラリからエクスポートされる項目の定義を用意しました。

ライブラリはカーネルに存在することを期待する`wait_micros`関数に依存します。
この関数は渡されたマイクロ秒数だけスリープする必要があります。カーネルを
正常にリンクするにはこの関数を作成してエクスポートする必要があります。
この関数のCシグネチャは次のとおりです。

```c
/*
 * `us` マイクロ秒スリープする。
 */
 void wait_micros(unsigned int us);
 ```

あなたの仕事は安全でない外部APIを安全なRusty APIでラップすることです。
`new()`メソッドでSDカードを初期化する`Sd`構造体を実装してください。
次に、`Sd`用の`BlockDevice`トレイトを実装してください。外部アイテムとの
やり取りには`unsafe`を使用する必要があるでしょう。`kmain`で手動で
カードのMBRを読み込んで作成した実装をテストしてください。読み込んだ
バイトが期待したものと一致していることを確認してください。すべてが期待
通りに動作したら次のサブフェーズに進んでください。

**ヒント**
> 64ビットARMではCの`unsigned int`はRustでは`u32`です。

**質問 (foreign-sync): あなたの実装はスレッドセーフですか**
> 提供したコンパイル済みのSDドライバはグローバル変数(`sd_err`)を使用して
> いかなる同期も行わずにエラー状態を追跡しています。そのため、スレッド
> セーフになる見込みはありません。このことはバインディングの正しさに
> どのような影響を与えますか。`unsafe`コードではRustのデータ競合保証を
> 守らなければならないことを思い出してください。カーネルが`sd_init`を
> 正しく呼び出したと仮定して、あなたの`Sd`用`BlockDevice`の実装は
> 要求通りにスレッドセーフになっていますか。その理由は何ですか。

### サブフェーズB: ファイルシステム

このサブフェーズではカーネルが使用するグローバルファイルシステムを公開し、
初期化します。主に`kern/src/fs.rs`で作業します。

メモリアロケータと同じくファイルシステムは _グローバルな_ リソースです。
ディスク上のデータにいつでもアクセスできるように常に利用可能であることが
望まれます。これを可能にするために`main.rs`にグローバルな
`static ILE_SYSTEM: FileSystem`を作成しました。これはファイルシステムへの
グローバルなハンドルを提供します。アロケータと同様、ファイルシステムも
初期化されない状態で始まります。

#### 結びつける

これまでにディスクドライバとファイルシステムを実装してきました。両者を
結びつける時がきました。FAT32ファイルシステムとSDカードドライバの
Rustyバインディングを使用して`kernel/src/fs.rs`にある`FileSystem`構造体の
実装を完了させます。`initialize()`関数で`Sd` `BlockDevice`を使ってファイル
システムを初期化してください。次に、この構造体に`FileSystem`トレイトを実装
し、内部の`VFat`への呼び出しをすべて任せます。最後に`kmain`において
アロケータの直後にファイルシステムを初期化するようにしてください。

`kmain`でSDカードのルート（`"/"`）にあるファイルを表示することにより
実装をテストしてください。すべてが期待通りに動いたら、次のフェーズに
進んでください。
