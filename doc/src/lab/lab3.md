# Lab3: FAT32ファイルシステム

## はじめに

この課題ではメモリアロケータを書くことでRustの[コレクション](https://doc.rust-lang.org/alloc/collections/index.html)
モジュール（`Vec`、`String`、`HashMap`とその仲間）を使えるようにし、
FAT32ファイルシステムとRaspberry PiのEMMC（SDカードコントローラ）
ドライバのRustインタフェースを実装し、`cd`, `ls`, `pwd`, `cat`コマンドで
シェルを拡張します。

## フェーズ0: 始めよう

[一部省略]

以下はリポジトリのディレクトリ構成です。この課題で作業するファイルには
`*`がついています。

```
.
├── bin : common binaries/utilities
├── doc : reference documents
├── ext : external files (e.g., resources for testing)
├── tut : tutorial/practices
│    ├── 0-rustlings
│    ├── 1-blinky
│    ├── 2-shell
│    └── 3-fs : questions for lab3 *
├── boot : bootloader
├── kern : the main os kernel *
└── lib  : required libraries
     ├── fat32 *
     ├── pi *
     ├── shim
     ├── stack-vec
     ├── ttywrite
     ├── volatile
     └── xmodem
```

[一部省略]

### `make transmit`コマンド

前回のラボでブートローダを書き終えたので`make transmit`コマンドを使う
ことができます。このコマンドはカーネルバイナリをビルドし、`ttywrite`を
呼び出してブートローダがロードできるようにRaspberry Piに送信します。
その結果、ブートローダが`kernel8.img`としてインストールされていると仮定
するとRaspberry Piをリセットして`make transmit`を実行するだけで新しい
バイナリをテストできるようになります。

前回のラボで`ttywrite`ユーティリティをインストールしたはずです。何らかの
理由でインストールしていない場合は今すぐ`lib/ttywrite`ディレクトリで
`cargo install --path .`を実行してインストールしてください。t
`tywrite --help`を実行することによりユーティリティが正しくインストール
されたことを確認してください。

`make transmit`ターゲットはデフォルトで`/dev/ttyUSB0`に書き込むように
設定されています。使用するTTYデバイスが異なる場合は`kern/Makefile`の
7行目の`TTY_PATH`宣言を適切に変更してください。

**注記: ユーザ名をdialoutグループに追加する**
> TTYへアクセスした際にパーミッションの問題が発生した場合はユーザ名を
> dialoutグループに追加してみてください。
    sudo usermod -a -G dialout $USER
    sudo reboot


**警告: lab3マージ後のコンパイルエラー**
> lab3の最終フェーズ用のテンプレートコードを提供していますがそこには
> 未完のコードがたくさん含まれています。このラボの作業中にコードを
> コンパイルするとマージしたばかりのコードのいくつかについてコンパイラが
> 警告を発することがわかります。後で修正するまで対象のコードをコメント
> することができます。たとえば、フェーズ1の作業中はファイルシステム
> コンポーネントを無効にしたいと思うでしょう。コメントアウトは最小限の
> コードだけにするようにしてください。

**警告: `ALLOCATOR.initialize()`の呼び出しはパニックになります**
> 前回作成したシェルは依然として機能するはずです。ただし、現時点で
> `make install`ターゲットをテストするとシェルが動作しないように見える
> かもしれません。その原因として考えられるのは`shell()`の呼び出しの前に
> ある`ALLOCATOR.initialize()`の呼び出しです。まだメモリアロケータがない
> ので、この呼び出しは`panic!()`を引き起こし、警告なしにシステムを停止
> させます。これはすぐに修正します。すべてが期待どおりに動作するように
> 対象の行を一時的にコメントアウトしてください。

## フェーズ1: メモリレーン

このフェーズではメモリアロケータを2つ実装します。シンプルな _バンプ_
アロケータとより完全な機能を持つ _ビン_  アロケータです。これらにより
`Vec`、`Box`、`String`などのヒープ割り当ての構造体がすぐに使用できる
ようになります。システムで割り当て可能なメモリを決定するために
ARMタグ（`ATAGS`）を読み込みます。また、`panic!`呼び出しを正しく
処理するためにパニックハンドラを実装します。

### サブフェーズA: Panic!

このサブフェーズではパニックハンドラを実装します。`kern/src/init/panic.rs`
で作業します。

#### Rustにおけるエラー処理

Rustには2つの大きなエラーカテゴリーがあります。_回復可能な_ エラーと
_回復不可能な_ エラーです。Rustでは回復可能なエラーを`Result<T, E>`型で
表します。一方、Rustプログラムが回復不可能なエラーに遭遇するとRustは
プログラムの実行を完全に停止します。この動作をRustの用語では
`panic!`と呼びます。

標準的なオペレーティングシステムを対象としている場合、Rustコンパイラは
バックトレースを表示してパニック時のプロセス終了コードを設定する
プログラムを生成します。しかし、私達がRaspberry Pi用に行っているような
オペレーティングシステムのサポートのない対象向けにRustプログラムの
コンパイルを指示した場合、Rustコンパイラは _パニックハンドラ_ の
実装を要求します。

パニックハンドラは`panic!`が発生したときに呼び出される関数です。その型は
`fn panic(info: PanicInfo) -> !` です。これは引数として
[PanicInfo](https://doc.rust-lang.org/core/panic/struct.PanicInfo.html)を
受け取り、決して復帰しないことを意味します。`PanicInfo`構造体には
`panic!`が発生したファイル名、行番号、列数の情報が格納されています。

`kern/src/init/panic.rs`には無限にループするパニックハンドラを提供して
います。この`panic`関数の実装を拡張して有用な情報をコンソールにログ出力
するようにします。

#### パニックハンドラの実装

`panic`関数を実装してください。実装では渡された情報をコンソールに表示し、
既にある`loop`を実行できるようにする必要があります。関数の実装は自由です。
例として、私たちの実装は`Linuxカーネルのops`メッセージからヒントを得て
います。

```bash
            (
       (      )     )
         )   (    (
        (          `
    .-""^"""^""^"""^""-.
  (//\\//\\//\\//\\//\\//)
   ~\^^^^^^^^^^^^^^^^^^/~
     `================`

    The pi is overdone.

---------- PANIC ----------

FILE: src/kmain.rs
LINE: 40
COL: 5

index out of bounds: the len is 3 but the index is 4
```

カーネルをパニックさせて新しい`panic`関数の実装をテストしてください。
新規`make install`ターゲットを使うとカーネルをコンパイルしてRaspberry Piに
送信できることを思い出してください。`ALLOCATOR.initialize()`の呼び出しで
すでに`panic!`になるので変更は不要であることに注意してくだい。 この関数が
`shell()`の前に呼び出されることを確認してください。

次に、不正な`unwrap()`、明示的な`panic!()`、`unreachable!()`などの他の
方法でカーネルをパニックにしてみてください。そしてすべてが期待通りに
操作することを確認してください。実装に満足したら次のサブフェーズに
進んでください。

### サブフェーズB: ATAGS

このサブフェーズではRaspberry Piのファームウェアによってロードされる
ARMタグ（ATAGS）に対するイテレータを実装します。イテレータを使って
システムで利用可能なメモリ量を指定するATAGを見つけます。`lib/pi/src/atags`
ディレクトリと`kern/src/allocator.rs`で作業します。

#### ARMタグ

[ATAGS](http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html#d0e428)（ARMタグ）は
ARMブートローダやファームウェアがシステムに関する情報をカーネルに渡す
ために使用するメカニズムです。たとえば、LinuxはARMアーキテクチャ用に
構成されているとATAGSを使用することができます。

Raspberry Piはアドレス0x100にATAG構造体の配列を配置します。以下はATAGS
構造をRust構文で書いたものです。

```rust
#[repr(C)]
struct Atag {
    dwords: u32,
    tag: u32,
    kind: Kind
}
```

ATAGは8バイトのヘッダーである`dwords`と`tag`で始まります。`dwords`
フィールドは全ATAGのサイズを _ダブルワード_（32 ビットワード）単位で
指定します。これにはヘッダーも含まれます。したがって、最小サイズは`2`
です。`tag`フィールドはATAGのタイプを指定します。10種類のタグが指定されて
おり[ATAGSリファレンス](http://www.simtec.co.uk/products/SWLINUX/files/booting_article.html#d0e428)にすべて記載されています。Raspberry Piは4つ
しか使用しません。以下はその説明です。

| 名前 | タイプ(`tag`) | サイズ | 説明 |
|:-----|:--------------|:-------|:-----|
| [CORE](file:///Users/dspace/xv6_memos/book/raspi/booting_arm_linux.html#atag_core) | 0x54410001 | 5, 空の場合は2  | リストの開始に使用する最初のタグ |
| [NONE](file:///Users/dspace/xv6_memos/book/raspi/booting_arm_linux.html#atag_none) | 0x00000000 | 2 | リストの終端に使用するエンプティタグ |
| [MEM](file:///Users/dspace/xv6_memos/book/raspi/booting_arm_linux.html#atag_mem) | 0x54410002 | 4 | 物理メモリ領域を記述する |
| [CMDLINE](file:///Users/dspace/xv6_memos/book/raspi/booting_arm_linux.html#atag_cmdline) | 0x54410009 | 可変 | カーネルに渡すコマンドライン |

タグのタイプはヘッダー後のデータがどのように解釈されるべきかを決めます。
スケルトンコードではヘッダーに続くデータは様々な種類のタグのunionである
`kind`という名前のフィールドで表現されています。上の表でタグの名前を
クリックするとそのタグのデータレイアウトを含むタグのリファレンスに
ジャンプします。たとえば、`MEM`タグのデータは以下のような構造になって
います。

```c
struct Mem {
    size: u32,
    start: u32
}
```

タグはメモリ上に順次配置され、各タグ間は0詰めされています。最初のタグは
`CORE`タグと規定されており、最後のタグは`NONE`タグで示されます。その他の
タグの順番は任意です。`dwords`フィールドは隣接するATAGのアドレスの決定に
使用されます。下図は一般的なレイアウトを示しています。

![ATAGSレイアウト](atags.png)

#### Unionと安全性

生のATAGデータ構造体は`lib/pi/src/atags/raw.rs`で宣言されています。以下に
コピーしたメインの宣言ではRustの`union`を使用しています。Rustのunionは
Cのユニオンと同じで、すべてのフィールドが共通のストレージを共有する構造を
定義します。

```rust
pub struct Atag {
    dwords: u32,
    tag: u32,
    kind: Kind
}

pub union Kind {
    core: Core,
    mem: Mem,
    cmd: Cmd
}
```

事実上、unionはそのキャストが正しいかどうかに関係なく、メモリを任意の
構造体にキャストできます。そのためRustにおけるunionフィールドのアクセスは
unsafeです。

`atags`モジュールですでに大部分のunsafeを処理しているのでunionの扱いに
ついては心配する必要はありません。とはいえ、`pi`ライブラリのエンドユーザに
unionを公開するのは悪い考えです。そのため、`lib/pi/src/atags/atag.rs`に
2つ目の`Atag`構造体を宣言しました。この構造体の使用とアクセスは完全に
安全です。これが`pi`ライブラリが公開する構造体です。このサブフェーズの
後半で`atag`モジュールの実装を終える際に`raw`構造体から安全な構造体への
変換を書くことになります。

**質問 (enduser-unssfe): エンドユーザにunionを公開するのはなぜ悪い考えなのか**
> unsafeなデータ構造を安全なインターフェイスを公開するために多くの労力を
> 費やしてきています。標準ライブラリを代表例としてRustではこのようなことが
> 何度も何度も見られます。Rustでunsafeな構造体や操作を安全なインタフェースで
> 公開することにどのような利点があるのでしょうか。C言語のような言語でも
> 同じような利点が得られるでしょうか。

#### コマンドライン引数

`CMDLINE`タグは特に注目に値します。その定義は次のとおりです。

```rust
struct Cmd {
    /// コマンドライン文字列の最初のバイト
    cmd: u8
}
```

コメントで示したように`cmd`フィールドはコマンドライン文字列の最初の
バイトを保持します。言い換えれば、`&cmd`はCと同様なヌル終端の文字列への
ポインタです。安全版の`Cmd`タグは`Cmd(&'static str)`です。`raw`の`Cmd`
タグから安全版の`Cmd`タグへの変換を記述する場合、文字列内でヌル終端を
検索してC類似の文字列のサイズを決定する必要があります。次に、そのアドレスとサイズを`slice::from_raw_parts()`を使ってスライスにキャストし、最後に
そのスライスを`str::from_utf8()`か`str::from_utf8_unchecked()`を使って
文字列にキャストする必要があります。この2つの関数はラボ2で使っています。

#### `atgs`の実装

これで`lib/pi/src/atags`にある`atags`モジュールを実装する準備ができました。
`atags/raw.rs`にある`raw::Atag::next()`メソッドの実装から始めましょう。
このメソッドは`self`に続くATAGのアドレスを決定し、その参照を返します。
実装では`unsafe`を使用する必要があります。次に、`atags/atag.rs`にある
ヘルパーメソッドとraw構造体から安全な構造体へ変換するトレイトを実装
します。`unsafe`を使用する必要があるのは`From<&'a raw::Cmd> for Atag`を
実装するときだけです。最後に、`atags/mod.rs`にある`Atag`用の
`Iterator`トレイトの実装を完了させます。これには`unsafe`は必要ありません。

**ヒント**
> `x as *const T as *const u32`を使って`x: &T`から`*const u32`へ変換する
> ことができます。

**ヒント**
> `&*x`を使って`x: *const T`から`T`に変換することができます・しかし、
> この変換は**極めて**unsafeです。Rust参照のエイリアス規則に違反しない
> ように注意してください。

**ヒント**
> ポインタ演算は`add()`, `sub()`, `offset()`で実行できます。

#### `atggs`のテスト

`lib/pi`ディレクトリで`cargo test`コマンドを実行して実装をテストして
ください。次に、`kern/src/main.rs`にすべてのATAGSを走査してコンソールに
デバッグプリントするコードを書いてRPiボードでATAGS実装をテストしてください。
3つの`NONE`以外のタグが少なくとも1つずつ表示されるはずです。それぞれの
ATAGの値が期待通りであることを確認してください。実装が期待通りに実行
されたら、次のサブフェーズに進んでください。

**ヒント**
フォーマット指定子`{:#?}`は構造体のデバッグ出力をプリティにします。

**質問 (atag-cmdlin): `CMDLINE` ATAGには何が含まれていますか**
Raspberry Piで見つかった`CMDLINE` ATAGに含まれているコマンドライン文字列
の値は何ですか。そのパラメータは何を制御していると思いますか。

    `"bcm2708_fb.fbwidth=656 bcm2708_fb.fbheight=416 bcm2708_fb.fbswap=1 dma.dmachans=0x7f35 bcm2709.boardrev=0xa020d3 bcm2709.serial=0x4aabe848 bcm27...`

**質問  (atag-mem): `MEM`タグではどのくらいのメモリが報告されましたか**
> `MEM` ATAGによって報告される利用可能なメモリの正確な開始アドレスと
> サイズは何でしたか。これはRaspberry Piの1GBのRAMと言われているものに
> どれくらい近いですか。

    開始アドレスは 0x0, サイズは 994,050,048

### サブフェーズ C: ウォーミングアップ

このサブフェイズでは次のサブフェイズで2つのメモリアロケータを書くための
準備をします。ここではアドレスを2のべき乗にアラインする2つのユーティリティ
関数: `align_up`と`align_down`を実装します。また、システムで利用可能な
メモリの開始アドレスと終了アドレスを返す`memory_map`関数を実装します。
この`memory_map`関数は割り当て可能なメモリを決定するために2つのメモリ
アロケータの両者で使用されます。

#### アライメント

メモリアドレスは`n`の倍数である場合 _nバイトアライン_ されているといいます。
別の言い方をすれば、メモリ・アドレス`k`は`k % n == 0`の場合、_nバイトアライン_ です。_通常_、メモリアドレスのアラインメントを気にする必要は
ありませんが、新進のシステムプログラマとしては気にする必要があります。
なぜなら、ハードウェアやプロトコル、その他の外的要因によってアライメント
プロパティが強制されるからです。たとえば、ARM 32ビットアーキテクチャでは
スタックポインタは8バイトアラインメントである必要があります。私達のOSに
選んだAArch64アーキテクチャではスタックポインターが16バイトアライメントで
ある必要があります。x86-64でも同じアライメントが必要とされます。仮想
メモリに使われるページアドレスは通常、4kバイトアライメントが必要です。
他にも例はたくさんありますが、メモリアドレスのアライメントが重要である
というだけで十分です。

C言語ではlibCアロケータから返されるメモリーアドレスは32ビットシステムでは
8バイトアライン、64ビットシステムでは16バイトアラインであることが保証されて
います。これを超えると、呼び出し元は返されたメモリーアドレスのアライメントを
制御できないので自分で解決しなければなりません（`posix_memalign`などの
POSIX関数は後にこれを修正しました）。

**質問 (libc-align): なぜCはこのアライメントを選択したのですか**
> libCの`malloc`が8バイトまたは16バイトのアライメント保証を選択したこと
> には理由がないわけではありません。なぜlibCはこれらの特定のアライメント
> 保証を選んだのですか。

C言語の`malloc()`と`free()`のシグネチャを思い出してください。

```c
void malloc(size_t size);
void free(void *pointer);
```

対照的に`GlobalAlloc`トレイトにあるRustoの低水準でunsafeな`alloc`と
`dealloc`は次のシグネチャを持っています。

```rust
// `layout.size()`は要求サイズ、`layout.align()`は要求アライメント
unsafe fn alloc(&self, layout: Layout) -> *mut u8;

// `layout`は`ptr`を返した呼び出しに使ったものと同じである必要がある
unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout)
```

呼び出し側は2つのパラメタ`size`と`align`で定義される[layout](https://doc.rust-lang.org/std/alloc/struct.Layout.html)
引数でアライメントを指定できることに注意してください。そのため、適切に
アラインメントされたメモリーアドレスを返す責任は呼び出し側ではなく
アロケータ側にあります。次のフェーズでメモリアロケータを実装する際には
返すアドレスがlayoutパラメータで指定された条件を満たすようにする必要が
あります。

2つ目の注意点は、Cの`free`と同様に、呼び出し元に`alloc`の呼び出し時に
使用した`Layout`を`dealloc`関数に渡すよう要求していることです。そのため、
アロケーションの要求サイズとアライメントを覚えておく責任はアロケータでは
なく、呼び出し側にあります。

**注記: Rustにおけるサイズとアライメントの保証**
> Rustでは、すべてのレイアウトは負値でないサイズと2のべき乗のアライメントを
> 待たなければなりません。これらの条件はレイアウトの作成時にチェック
> されます。

**質問 (onus): Rustはなぜこのような責任の分担をすると思いますか**
> C言語ではアロケータが返すメモリアドレスのアライメントに関する制約は
> 殆どありませんが、後で使用するためにアロケーションのサイズを記録して
> おく必要があります。Rustではその逆です。なぜRustはこのような逆の道を
> 選んだと思いますか。アロケータと呼び出し側にとってどのような利点が
> あるのでしょうか。

#### ユーティリティ: `align_up`と`align_down`

次のサブフェーズでアロケータを実装する際、メモリアドレス`u`が与えられた
場合に2のべき乗にアラインする最初のアドレスを`≧ n`か`≦ u`のいずれかに
できると便利です。`kernel/src/allocator/util.rs`にある（未実装の）
`align_up`関数と`align_down`関数はまさにこれを行います。

```rust
/// `addr` を `align` の最も近い倍数の下方向にアラインする.
/// `align` は2のべき乗でない場合はパニック.
fn align_down(addr: usize, align: usize) -> usize;

/// `addr` を `align` の最も近い倍数の上方向にアラインする.
/// `align` は2のべき乗でない、または、アライメントでアドレスが
/// オーバーフローする場合はパニック.
fn align_up(addr: usize, align: usize) -> usize;
```

これらの関数を今すぐ実装してください。`kernel`ディレクトリで`make test`
または`cargo test`を実行すると実装をユニットテストすることができます。
これにより`kern/src/allocator/tests.rs`のテストが実行されます。
`align_util`のユニットテストがすべてパスするはずです。

**警告: テスト**
> テスト中、kprint{ln}! の呼び出しは print{ln}!の呼び出しになります。
