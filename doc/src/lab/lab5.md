# Lab 5: マルチコアとネットワーク

## はじめに

現在のところ、カーネルはRPiボードにある4つのコアのうち1つのコアしか利用
していません。この課題では、他の3つのコアを有効にし、既存のコンポーネントを
調整してプログラムを正しく並列実行できるようにします。その後、RPi用の既存の
イーサネット実装 (USPi) と最小限のTCPスタック (smoltcp) をカーネルに統合し、
ホストコンピュータとRaspberry Piボードをイーサネットケーブルを介して通信
できるようにします。最後にエコーサーバをカーネル上のユーザプログラムとして
書き、ホストコンピュータからnetcatコマンドを使ってそのサーバとやりとり
します。

## フェーズ 0: 始めるために

lab5 用の更新データをgitリポジトリから各自の開発マシンに取り込みます。

```bash
$ git fetch skeleton
$ git merge skeleton/lab5
```

以下はリポジトリのディレクトリ構成です。この課題で作業するディレクトリには
`*`マークが付いています。

```bash
.
├── bin : common binaries/utilities
├── doc : reference documents
├── ext : external files (e.g., resources for testing)
├── tut : tutorial/practices
│    ├── 0-rustlings
│    ├── 1-blinky
│    ├── 2-shell
│    ├── 3-fs
│    ├── 4-spawn
│    └── 5-multicore : questions for lab5 *
├── boot : bootloader
├── kern : the main os kernel *
├── lib  : required libraries
│     ├── aarch *
│     ├── kernel_api *
│     ├── fat32
│     ├── pi *
│     ├── shim
│     ├── stack-vec
│     ├── ttywrite
│     ├── volatile
│     └── xmodem
└── user : user level program *
      ├── fib
      ├── sleep
      └── socket *
```

## マージガイドライン

作業を進める前にコンフリクトを解決する必要があるかもしれません。たとえば、
次のようなメッセージが表示された場合:

```bash
Auto-merging kern/src/main.rs
CONFLICT (content): Merge conflict in kern/src/main.rs
Automatic merge failed; fix conflicts and then commit the result.
```

コンフリクトを解決するには`main.rs`ファイルを修正する必要があります。
Lab 4での変更をすべて残しておくようにしてください。すべてのコンフリクトが
解決したら`git add`と`git commit`で解決したファイルを追加してください。
マージコンフリクトを解決する方法については[githowto.comのチュートリアル](https://githowto.com/resolving_conflicts)を
参照してください。

Lab 4から様々なデザインが変更されています。マージガイドラインは以下の
変更概要を参照してください。

- Safe / Unsafe の変更
  Rustの安全保障により適合するようにいくつかの safe / unsafe 定義が変更
  されました。この点に関するマージコンフリクトがあった場合は更新された
  定義に従ってください。
- スケジューラ
    - GlobalSchedulerのその定義で`Box`を使うようになりました。これに伴い
      `Scheduler::new()`関数を更新しました。
    - タイマー操作を`start()`から`initialize_global_timer_interrupt()`に
      移動しました。この関数を`GlobalScheduler::start()`で呼び出してくだ
      さい。
- ページテーブル
  カーネルがローカルタイマーアドレスにアクセスできるように`IO_BASE_END`の
  値を上げました。これをサポートするためにカーネルページテーブルはこれまでの
  2つから3つのL3エントリを使用するようになりました。
  `kern/src/vm/pagetable.rs`にある関連する関数を調整してください。
- VMM
  VMMが以前より多くのフィールドを含むようになりました。`initialize()`で
  カーネルテーブルのベースアドレスを計算して`self.kern_pt_addr.store(kern_pt_addr, Ordering::Relaxed);`
  で`kern_pt_addr`フィールドに保存してください。この行が何を意味するかは
  このラボを通して学ぶことになります。

  さらに、`setup()`が`initialize()`で自動的に呼び出されなくなりました。
  これは、仮想メモリーマネージャを初期化する動作とカレントコアのMMUを
  セットアップする動作を分離するためであり、これにより複数のコアにおいて
  両者を独立に呼び出せるようになります。`kmain()`で`VMM.initialize()`の
  直後に`VMM.setup()`の呼び出しを追加する必要があります。
- IRQ / トラップ
  IRQは再設計されトレイトベースのロジックを使用するようになりました。
  `kern/src/traps/irq.rs`の変更箇所を読んでください。関数`register()`と
  `invoke()`を変更し、必要に応じて`handle_exception()`も変更してください。
- `write_str` syscall
  以前のラボではシリアルに1バイトを出力する`write()`システムコールしか
  ありませんでした。あらたに`write_str()` syscallを追加しました。これは
  ユーザからsliceを受け取りatomicallyに出力します。`kerenl.api`ライブラリは
  これを使用するように変更されました。ユーザプログラムを再コンパイルして
  SDカードにコピーしてください。

## ロギング基盤

カーネルコードではメッセージロギングに`kprintln!`ではなく、Rustの`log`
クレートを使うようになりました。これにより`trace!`, `debug!`, `info!`,
`warn!`, `error!`の5つのロギングマクロが使えるようになります。

ロギングコードは`kern/src/logger.rs`で定義されています。ビルド時に
`VERBOSE_BUILD`環境変数が設定された場合（たとえば、`VERBOSE_BUILD=1 make`）、
すべてのログが有効になります。そうでなければtraceレベルのログは表示され
ません。各状況においてどのレベルのログを使うべきかについては具体的な
要件はありませんが、簡単なガイドラインを以下に示します。

- Trece: カーネルデバッグには役立つがデフォルトで有効にするには冗長
  すぎる情報
    - スケジューラスイッチログ
    - IRQ割り込みログ
- Debug: 開発者が興味を持ちそうな情報
    - ページテーブルアドレス
- Info: カーネルユーザが興味を持ちそうな情報
    - システムのメモリ容量
    - カーネルの初期化ステータス
- Warn: 例外的なエラー状況の表示
    - メモリ不足
    - ユーザプログラムの不明な例外
- Error: カーネルの通常実行中には発生してはならない事象の表示
    - デバッグのアサーション違反
    - カーネル内部の不明な例外

## ARMドキュメント

lab 4で紹介した次の3つのドキュメントに加えて

- [ARMv8リファレンスマニュアル](https://tc.gts3.org/cs3210/2020/spring/r/ARMv8-Reference-Manual.pdf)
  ARMv8アーキテクチャの公式リファレンスマニュアルです。アーキテクチャ全体を
  一般的な方法で網羅する完全マニュアルです。Raspberry Pi 3向けのアーキ
  テクチャの具体的な実装についてはARM Cortex-A53マニュアルを参照して
  ください。このマニュアルのセクションは([ref](https://tc.gts3.org/cs3210/2020/spring/r/ARMv8-Reference-Manual.pdf): C5.2)と
  いう形の注記で参照し、ARMv8リファレンスマニュアルのセクションC5.2を参照
  する必要があることを示します。
- [ARM Cortex-A53マニュアル](https://tc.gts3.org/cs3210/2020/spring/r/ARM-Cortex-A53-Manual.pdf)
  Raspberry Pi 3で使用されているARMv8 (v8.0-A)アーキテクチャの具体的な
  実装に関するマニュアルです。このマニュアルのセクションは([A53](https://tc.gts3.org/cs3210/2020/spring/r/ARM-Cortex-A53-Manual.pdf): 4.3.30)と
  いう形の注記で参照し、ARM Cortex-A53マニュアルのセクション4.3.30を参照
  する必要があることを示します。
- [ARMv8-Aプログラマガイド](https://tc.gts3.org/cs3210/2020/spring/r/ARMv8-A-Programmer-Guide.pdf)
  ARMv8-Aプロセスのプログラミング方法に関する高レベルのガイドです。
  このマニュアルのセクションは([guide](https://tc.gts3.org/cs3210/2020/spring/r/ARMv8-A-Programmer-Guide.pdf): 10.1)と
  いう形の注記で参照し、ARMv8-Aプログラマガイドのセクション10.1を参照
  する必要があることを示します。

Lab 5ではさらに2つのドキュメントを使用します。

- [AArch64プログラマガイド: 汎用タイマー](https://tc.gts3.org/cs3210/2020/spring/r/aarch64-generic-timer.pdf)
  ARMアーキテクチャの汎用タイマーに関するガイドです。このマニュアルの
  セクションは([timer](https://tc.gts3.org/cs3210/2020/spring/r/aarch64-generic-timer.pdf): 3.2)と
  いう形の注記で参照し、AArch64プログラマガイド: 汎用タイマーのセクション
  3.2を参照する必要があることを示します。
- [Quad-A7 Control](https://tc.gts3.org/cs3210/2020/spring/r/QA7_rev3.4.pdf)
  Quad-A7制御に関するガイドで、コアごとのタイマーと割り込み処理に関する
  説明があります。このマニュアルのセクションは([QA7](https://tc.gts3.org/cs3210/2020/spring/r/QA7_rev3.4.pdf): 4.10)と
  いう形の注記で参照し、Quad-A7 Controlのセクション4.10を参照する必要が
  あることを示します。

これら5つの文書はすべて研究室リポジトリの`doc/`サブディレクトリにあります。
今すぐこの5つのドキュメントをダウンロードして、すぐ手の届くところに置いて
おくことを勧めます。

## フェース 1: マルチコアの有効化

ラボ4ではプリエンプティブスケジューリングについて学びました。これは
コンテキストスイッチングにより1つのカーネル内で複数のユーザプログラムを
同時に実行することを可能にするものでした。複数のプログラムがカーネル上で
_同時 (concurrently)_ 実行されていましたが、ある時点では1つのユーザ
プログラムだけがコアを占有していたことに注意してください。このフェーズでは
RPiボードにある残りの3つのコアを有効にしてユーザプログラムの _並列 (parallel)_
実行をサポートします。並列プログラミングにはシングルスレッドプログラミングには
存在しない多くの固有の問題があります。これを解決するためにミューテックス、
IRQハンドラ、スケジューラの設計を再検討し、マルチコア環境に合わせて調整します。

### サブフェース A: 他のコアを起床させる

このサブフェーズではスピンテーブル機構を使用してBCM2837の残りの3つのコアを
有効にします。

#### スピンテーブル

CPUのすべてのコアはメインメモリ（RAM）を共有しています。そのため、RAMを
コア間の通信媒体として利用できます。_スピンテーブル_ はこのRAMの特性を
利用した起動メカニズムであす。RPiの電源を入れると最初のコアであるコア0は
`kern/src/init.rs`で定義されている`_start`関数にジャンプします。他のコアは
すべてカーネルの外でスピンして、スピニングアドレスをポーリングしています。

[RPiファームウェア](https://github.com/raspberrypi/tools/blob/b0c869bc929587a7e1d20a98e2dc828a24ca396a/armstubs/armstub8.S#L132-L154)の
以下のコードがスピンテーブル機構を実装しています。

```
in_el2:
    mrs x6, MPIDR_EL1
    and x6, x6, #0x3
    cbz x6, primary_cpu

    adr x5, spin_cpu0

secondary_spin:
    wfe
    ldr x4, [x5, x6, lsl #3]
    cbz x4, secondary_spin
    mov x0, #0
    b boot_kernel

primary_cpu:
    ldr w4, kernel_entry32
    ldr w0, dtb_ptr32

boot_kernel:
    mov x1, #0
    mov x2, #0
    mov x3, #0
    br x4
```

RPiが起動するとコア0はシンボル`kernel_entry32`からカーネルアドレスを
ロードしてそのアドレスに分岐します。RPiファームウェアはこのルーチンの前に
`config.txt`で指定された`kernel_address`の値を`kernel_entry32`にセットします。
他のすべてのコアは`secondary_spin`ループ内で`wfe`でスピンします。ループ中、
これらのコアは`spin_cpu0 + 8 * core_idx`から8バイトのアドレスをロードし、
0でなければそのアドレスに分岐します。そのため、他のコアを起床させるに
コア0は開始アドレスをスピニングアドレスに書き込み、`sev`命令でイベントを
送信する必要があります。他のコアのエントリポイントには`init::start2`を
使います。

各コアは他のコアと干渉しないように各自のスタックポインタを使用する必要が
あります。関数`_start`はコア0のスタックレジスタとして`KERN_STACK_BASE`を
割り当てています。私たちのカーネル設計ではコア`i+1`はコア`i`のスタックの
直下を使用します。すなわち、コア`i`のスタックポインタは
`KERN_STACK_BASE - KERN_STACK_SIZE * i`です。

#### 実装

これでコアの初期化ルーチンを実装する準備ができました。`kern/src/main.rs`に
ある`kmain()`と`kern/src/init.rs`にある`initialize_app_cores()`,
`start2()`, `kmain2()`を作成します。

これらの関数は好きな順番で実装死て構いません。

- **`initialize_app_cores()`では`start2()`のアドレスを各コアのスピニングアドレスに書き込みます**

    スピニングベースである`spin_cpu0`は`pi/src/common.rs`において定数
    `SPINNING_BASE`として定義されています。コア0は各コアのスピニング
    アドレスを計算してそのアドレスに`start2()`のアドレスを書き込み、
    `sev()`を実行し、各コアからの確認を待ちます。他のコアは完全に目覚めたら、
    `kmain2()`でスピニングアドレスに0を書き込みます。コア0はすべてのコアの
    スピニングアドレスが0で上書きされたことを確認した上で
    `initialize_app_cores()`から復帰する必要があります。

- **`start2()`ではスタックポインタをセットして`kinit2()`に分岐します**

    上で説明したようにスタックポインタをセットしてください。コアの
    インデックスは`MPIDR_EL1`から抽出できることを思い出してください。
    次に、スタックレジスタをセットしてから`kinit2`に分岐してください。
    スタックポインタを変更しているので`start2()`ではスタック変数を使用
    しないように注意してください。

    **警告: `aarch64::affinity()`は動作しない可能性があります**

    `aarch64::affinity()`はインライン化されることが保証されておらず、
    関数を呼び出すためにスタック空間を使用する可能性があります。
    スタックポインタはまだセットしていないので`aarch64::affinity()`を
    使うことができないかもしれません。`MPIDR_EL1`レジスタに直接
    アクセスしてみてください。

- **`kmain2()`ではメッセージを表示し、コアが使用可能であることを確認します**

    初期化が成功すると各コアは`kmain2()`に到達し、**EL1**で実行を開始します。
    `kmain2()`ではコアのスピンingアドレスンに0を書き込んでコア0に通知します。
    その後、コンソールに任意のメッセージを表示して無限ループに入ってください。
    新しく追加されたロギングマクロを使ってください。

コードを書き終えたら、`kmain()`を次のように変更してください。

```rust
unsafe fn kmain() -> ! {
    ALLOCATOR.initilaiize();
    FILESYSTEM.initialize();
    VMM.initialize();
    SCHEDULER.initialize();

    init::initialize_app_cores();
    VMM.setup();

    SCHEDULER.start();
}
```

RPiボード上でカーネルを実行すると各コアからの初期化メッセージが表示される
はずです。ただし、これらの新しいコアはまだ何の役にも立っていません。私たちの
カーネルのいくつかのコンポーネントはまだパラレル対応になっていないからです。
次のステップはこれらの古い設計を修正することです。

**警告: 不健全なミューテックスに注意**
> 私たちのミューテックスは健全ではないので、内部的にミューテックスを使用
> している`kprintln!()`やロギングマクロを複数のコアからアクセスすると
> デッドロックを起こしたり、データ競合を引き起こしたりする可能性があります。
> これはまれなケースであり、十分な時間リトライすれば成功するケースが
> 見られるはずです。すぐに修正する予定です。

**質問 (spin-address): アドレスをハードコードせずにスピンベースを検出する方法は**
> Raspberry Piのスピンアドレスをカーネルにハードコードしているので
> スピンアドレスの異なる他のハードウェアではカーネルは動作しません。
> Linuxカーネルはこの問題をどのように解決していますか。

### サブフェース B: Mutex再び

私たちのスケルトンコードのmutexのコードは実際にはスレッドセーフではなく、
SendトレイトとSyncトレイトをunsafeで実装することによりRustコンパイラを
騙しています。こうしたのはスレッドセーフなmutexの実装に必要なアトミックな
メモリ操作がAArch64アーキテクチャではMMUが初期化されていないと利用できない
からです。これはラボ4で追加されたところです。システムで使用できるコアが1つ
しかないことを理由に私たちの設計を正当化してきました。しかし、今やMMUと
マルチコアが共に有効になったのでその嘘を正す時です。このサブフェーズでは
複数のコアが健全な方法でmutexを使用できるようにmutexの設計を修正します。
`kern/src/mutex.rs`で作業することになります。

#### Per-coreデータ管理

カーネルで複数のコアがアクティブになっている場合、カーネルはper-カーネルの
リソースの初期化とper-コアのリソースの初期化を区別する必要があります。per-
カーネルのリソースは起動時に一度だけ初期化する必要があります。私たちの
カーネルのper-カーネルのリソースは`main.rs`で定義されています。`ALLOCATOR`,
`FILESYSTEM`, `SCHEDULER`などの静的構造体はper-カーネルのリソースです。コ
ア0は他のコアを起床させる前にper-カーネルのリソースを初期化する必要があり
ます。一方、per-コアのリソースは`kmain()`と`kmain2()`でコアごとに初期化する
必要があります。

では`kern/src/percore.rs`にあるper-コアのリソースの定義を読んでください。
各`PerCore`構造体は3つのデータフィールド: `preemption`, `mmu_ready`,
`local_irq`を持っています。`preemption`はコアが保持しているロックの数を
カウントし、`mmu_ready`フラグはMMUが各コアでセットされているか否かを保存し、
`local_irq`は各ローカル割り込みのIRQハンドラを保存します。

`PerCore`構造体の定義にアトミック型が使われていることに気づいたかも
しれません。現時点ではアトミック型は内部可変性 (mutabliity) を持つ
プレーンな型だと考えてください。アトミック型については後で詳しく説明します。

次は`kern/src/vm.rs`のコードを読んでください。ラボ4では`setup()`は
`initialize()`から直接呼び出され、コア0は仮想メモリマネージャを初期化した後、
直ちにMMUを初期化していました。しかし、ラボ5では両者の役割を分離します。
コア0はグローバルな初期化ルーチンの中で仮想メモリマネージャを初期化し、
コア0を含む各コアはコアの初期化が終わった後に各自のMMUを設定します。

`wait()`の部分的な実装を用意しました。これがどのように`setup()`を呼び
出しているか、`set_mmu_ready()`と`is_mmu_ready()`がper-コアのMMU初期化
情報の追跡にどのように使用されているかを確認してください。後ほどすべての
コアのMMU初期化が終了して一緒に復帰するまで各コアがループして待機するように
コードの残りの部分を埋めることになります。

#### メモリ一貫性モデル

RAMはすべてのコアで共有されることを思い出してください。複数のコアが同じ
アドレスを読み書きする場合、どの順番で値を読み書きするでしょうか。
プログラムでどのように出力したらこれを観測することができるでしょうか。
x86-64とAArch64では同一のプログラムが異なる動作をすることがあるでしょうか。
アーキテクチャの _メモリ一貫性モデル_ によりこれらの質問の答えがわかります。

2つのスレッドが値を変更してそれを出力するメモリ順序の典型的な例を見て
みましょう。Rustの型システムではunsafeブロックがないとこの例はコンパイル
できませんが、デモンストレーションのために、このコードはRustのバリアントで
書かれたと仮定します。AとBは両方とも0に初期化されていると仮定します。

```rust
/* スレッド 1 */
A = 1; // (1)
print!("{}", B); // (2)

/* スレッド 2 */
B = 1; // (3)
print!("{}", A); // (4)
```

最も直感的なメモリ一貫性モデルの1つは、逐次一貫性 (**SC: Sequential Consistency**)
です。これは次の2つ: (1) すべての読み書きに _大域的な順序_ が存在する、
(2) インタリーブがあっても同じスレッド内の命令の順序（プログラムの順序）は
保持される、を仮定します。このモデルにおいて上のプログラムが出力する
可能性のある結果の1つは`01`です。これは1つのスレッドが実行を完了して
から他方のスレッドが実行を開始した場合です。この結果を出力するプログラムの
実行順序は`1-2-3-4`または`3-4-1-2`です。`11`は少しわかりにくい出力ですが、
2つのスレッドの実行が`1-3-2-4`や`3-1-2-4`のようにインタリーブされる
場合です。このモデルでは上のプログラムから`00`は出力されません。

**注記: マルチスレッドとマルチコア**
> 厳密に言えばマルチスレッドとマルチコアは異なる概念です。複数のスレッドが
> 1つのコアで実行されている場合、メモリ一貫性の問題は発生しません。しかし、
> 最近ではほとんどすべてのCPUが複数のコアを搭載しており、2つの用語は交換
> 可能な用語として使われる場合があります。このラボの文書で「マルチ
> スレッド」と書かれている場合は、特に断りがなければ、マルチコアCPU上で
> 複数のスレッドが実行されていることを意味すると考えてください。

最新のCPUはアウトオブオーダ実行、per-コアキャッシュ、ロード/ストア最適化
など、実行性能を大幅に向上させる数々の最適化を活用しています。残念ながら、
SCはこれらの最適化を許すには厳しすぎます。SCは複数のコアで実行されている
すべてのメモリ操作のグローバルな順序付けを要求しており、これは本質的には
マルチコアアーキテクチャにシングルスレッドの振る舞いを要求しています。
その結果、最新のアーキテクチャはSCよりも弱いメモリ一貫性モデルを採用して
います。

![ARM Coretex-A53](cortex-a53.png)

**TSO (Total store ordering)** はSCより若干弱い一貫性モデルです。ストア
バッファリングが可能で、書き込み操作の他のコアへの伝搬を遅らせることが
できます。この弱体化によりSCモデルよりも大幅な性能向上が可能になります。
x86とx86-64ではTSOに非常に近いメモリ一貫性を規定しています。

TSOはSCの多くの保証を維持していますが、SCでは除外されていたある動作を許可
します。もう一度上のサンプルコードを見てみましょう。

```rust
/* スレッド 1 */
A = 1; // (1)
print!("{}", B); // (2)

/* スレッド 2 */
B = 1; // (3)
print!("{}", A); // (4)
```

TSOモデルではこのプログラムの結果として`00`が観察されることがあります。
`A=1`がスレッド1のキャッシュに格納され、`B=1`がスレッド2のキャッシュに
格納され、さらに書き込みが互いに伝播する前に各スレッドが実行を続行した場合、
両スレッドが結果として0を出力する可能性があるからです。これはSCでは許されない
動作です。

ARMアーキテクチャではさらに弱いメモリモデルを規定しています。次の
プログラムを考えて見ましょう。

```rust
/* スレッド 1 */
B = 1; // (1)
A = 1; // (2)

/* スレッド 2 */
print!("{}", A); // (3)
print!("{}", B); // (4)
```

ARMの一貫性モデルでは驚くべきことにこのプログラムは結果として`10`を
出力することができます。これは、スレッド2はスレッド1の書き込みを、
スレッド1が書き込む順序とは異なる順序で観察することができることを
意味します。TSOの下ではこれは許されません。後続の書き込みはそれが書き
込まれた順序で他のコアから見えるようになるからです（そのために"total
store ordering"と呼ばれます）。

ARMアーキテクチャは「データ依存性を持つ弱いメモリ順序」を持つと言われて
います。一般に、弱いメモリ順序モデルではプログラムの順序に関係なく、
2つの異なるメモリ位置の間の一貫性は保証されません。ただし、あるメモリ
位置の値が別のメモリ位置の値に依存する場合は、データ依存性が保証されます。

次の2つの例を考えてみましょう。

```rust
/* プログラム 1 */
A = 1; // (1)
B = 1; // (2)

/* プログラム 2 */
C = 1; // (3)
D = C; // (4)
```

プログラム1ではAとBは独立したメモリ位置なので他のスレッドは(1)よりも先に
(2)を観測することができます。しかし、プログラム2ではDの値はCの値に依存する
ので、他のスレッドがメモリ位置Dで1を観測したとすればメモリ位置Cでは1が
観測されることが保証されます。

**質問 (consistency-handson): メモリ一貫性の例**
> 2つのスレッドを使用して、SC、TSO、ARMハードウェア上で異なる結果セットを
> 表示する例を書いてください。各メモリ一貫性モデルで何が出力できるかを指定
> してください。

さらに、ハードウェアだけでなく、言語もそのメモリ一貫性モデルを定義しています。
コンパイラがプログラムコードを最適化する際に言語仕様に基づいて特定の
ステートメントを並べ替えたり、完全に削除したりすることがあります。

```rust
/* プログラム 1 */
let mut x = &mut 1;
for i in 0..1000 {
    println!("{}", *x);
}

/* プログラム 2 */
for i in 0..1000 {
    println!("{}", 1);
}
```

このコードスニペットではループ中に変数`x`を変更する他のスレッドがなければ
プログラム1と2は等価です。では、Rustコンパイラがプログラム1をプログラム2に
最適化することは妥当でしょうか。Rustの可変参照は元となる値への排他的
アクセスを意味することを思い出してください。つまり、Rustでは答えはイエス
です。コンパイラは`x`が元となるメモリ位置への一意のアクセスであるという
仮定に基づいてプログラム1をプログラム2に最適化することができます。`x`が
他のスレッドにより変更される可能性があることをコンパイラに伝えるには
可変参照`&mut`の代わりに生ポインタや`UnsafeCell`を使用する必要があります。

#### メモリバリアとアトミック命令

この時点で感じているはずですが、正しい並列プログラムを書くのは正しい
シングルスレッドプログラムを書くよりもかなり難しいです。並列プログラミング
には数多くの認識上の落とし穴があり、AArch64の弱いメモリ一貫性モデルは並列
プログラムの推論をさらに複雑にしています。

メモリバリアとアトミック命令はアーキテクチャがメモリ順序の複雑さを和らげる
ために提供しているツールです。これらのツールによりプログラマはより強力な
メモリ順序保証を局所的かつ制御された方法を自ら導入することができます。
また、言語レベルでも、異なるメモリ一貫性保証を持つ複数のアーキテクチャに
コンパイル可能な移植性の高いコードを書く方法を提供しています。

**メモリバリア**はバリア前後の命令間の依存関係を保証します。メモリバリア
によりプログラムの正しさのために強力なメモリ順序保証が必要な場合にバリア
前後の命令間の依存関係を明示的に指定することができます。

ARMアーキテクチャには3種類のメモリバリア命令があります (ref: B2.3.5)。
デフォルトでは完全なシステムバリア操作として動作します。これはバリア前後の
命令を（命令タイプに応じて）完全に同期させます。オプションパラメータを
使って、特定の命令タイプだけを待つように動作を調整することができます。
たとえば、ロードではなくストアだけを待機させることができます。

- **DMB**: データメモリバリア

  データメモリバリアはメモリバリアとして機能します。DMBはプログラム順序で
  DMB命令より前に現れるすべての明示的なメモリアクセスが、プログラム順序で
  DMB命令より後に現れる明示的なメモリアクセスより前に観測されることを保証
  します。

- **DSB**: データ同期バリア

    データ同期バリアは特殊なメモリバリアとして機能します。この命令が
    完了するまでプログラム順序でこの命令より後の命令は実行されません。

- **ISB**: 命令同期バリア

    命令同期化バリアはプロセッサ内のパイプラインをフラッシュし、この
    命令に続くすべての命令はISB命令が完了した後にキャッシュまたはメモリから
    フェッチされるようにします。

**質問 (context-restore-barrier): context_restoreにおけるバリア**
> ラボ4でTTBRレジスタを上書きした後に以下の4つの命令を追加した
> ことを思い出してください。これらの行が何を意味しているか、ページ
> テーブルの更新時にこれらの命令が必要な理由を説明してください。

```
dsb   ishst
tlbi  vmalle1
dsb   ish
isb
```

**アトミック命令**は並列プログラミングを容易にするためにアーキテクチャが
提供しているもう1つのツールです。アトミック命令はある動作を部分的に実行する
ことができないことを保証します。

```
/* スレッド 1 */
mov x0, #0
mov x1, addr of counter
loop:
    ldr x2, [x1]
    add x2, x2, #1
    str x2, [x1]
    add x0, x0, #1
    cmp x0, #1000
    ble loop

/* プログラム 2 */
mov x0, #0
mov x1, addr of counter
loop:
    ldr x2, [x1]
    add x2, x2, #1
    str x2, [x1]
    add x0, x0, #1
    cmp x0, #1000
    ble loop
```

2つのスレッドが同じメモリアドレスをインクリメントしているこのプログラムを
考えてみましょう。両スレッドは1000回ループしているのでスレッドが実行を
終了した際にカウンタは理想的には2000になっているはずです。残念ながら
インクリメントはアトミックに実行されていないので各スレッドはお互いの
「中間」値を読むことができます。このプログラムはスレッド1がロードとストアを
する間の時間枠にスレッド2がカウンタの値をロードすることを防ぎません。
これが起きるとスレッド1とスレッド2の双方が同じ値をカウンタに書き込むことに
なり、その結果、カウンタは2ではなく1しかインクリメントされないことに
なります。

アトミック命令はノンプリエンプティブな方法でアクションを実行する
（フェッチと加算を単一命令で実行する）か、データ競合を検出するメカニズムを
提供して操作を再試行できるようにすることでこの問題を解決します。これらの
アトミック命令はmutexなどのより高レベルな同期プリミティブの構想要素です。AArch64のアトミック命令の詳細についてはARMv8-Aアーキテクチャリファレンス
マニュアルの C3.2.12-14とARMv8-A Synchronization Primitivesドキュメントを
参照してください。

**質問 (atomic-handson): アトミックアセンブリコードの作成**
> 上のプログラムをアトミック命令で書き直して答えが常に正しくなるように
> してください。

**注記: アーキテクチャのバージョンを確認**
> アトミック命令を記述する際にはアーキテクチャのバージョンを確認する必要
> があります。たとえば、CAS (Compare and swap) 命令はARMv8.1以降でしか
> 使用できず、ARMv8では使用できません。Rustを使用している場合、これは
> LLVMバックエンドが自動的に処理します。

低レベルのインラインアセンブリレベルで作業する場合を除いて、Rustの標準
ライブラリが提供する[AtomicBool](https://doc.rust-lang.org/core/sync/atomic/struct.AtomicBool.html)や
[AtomicUsize](https://doc.rust-lang.org/core/sync/atomic/struct.AtomicUsize.html)
などのアトミックデータ型を使用するべきです。これらは`fetch_and()`や
`compare_and_swap()`などの高レベルなアトミック操作を提供しています。
アーキテクチャがこれらを単一の演算としてサポートしていなくても、
コンパイラはこのセマンティクスを保持して複数の小さなアトミック演算を
使って実装しています。

```rust
impl AtmicBool {
    pub fn fetch_adn(&self, val: bool, order: Ordering) -> bool { ... }
}

impl AtomicUsize {
    pub fn compare_and_swap(
        &self,
        current: usize,
        new: usize,
        order: Ordering
    ) -> usize { ... }
}
```

これらの操作では`&self`が必要であることに注意してください。Rustの不変参照は
値へのアクセスが共有されていることを意味します。複数のコードが同時にこの
値にアクセスしてもアトミック操作はデータ競合が起こらないことを保証します。
したがって、これらの操作では`&mut self`ではなく`&self`を使用することが
妥当です。

![acquire and release semantics](acq_rel_semantics.png)

これらのアトミック命令は`Ordering`パラメータを受け取ります。Rustは
[5種類のメモリ順序](https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html)を
提供しており、これは[C++20と同じ](https://en.cppreference.com/w/cpp/atomic/memory_order)です。
_Relaxed_ 順序は順序付けを保証しないアトミック操作を提供します。_acquire_
順序と _release_ 順序はペアで使用されます。acquire順序を持つロードは
このロード命令の後にある命令がロード前に並び替えられるのを防ぎ、
release順序を持つストアはこのストア命令の前にある命令がストア後に並び
替えられるのを防ぎます。その結果、あるアドレスのacquire/releaseペアは
クリティカル領域を形成し、その間にある命令がクリティカル領域外に並び
替えられるの防ぎます。さらに、スレッドAがrelease順序で変数に書き込み、
スレッドBが同じ変数をacquire順序で読み取る場合、スレッドBの後続のすべての
ロードは、release順序で書き込み前のスレッドBからのストアを見ることが
できます。_AcqRel_ はロードとストアを実行するアトミック命令のための
_Acquire_ ＋ _Release_ です。_SeqCst_ はすべてのスレッドが同じ順序の
連続的に一貫性のある操作を見ることができることを保証することを _AcqRel_ に
追加したものです。

**注記: さらなる参考資料**
> [Rust裏本の第8章](https://doc.rust-jp.rs/rust-nomicon-ja/concurrency.html)に
> これまで取り上げた内容の要約があります。

#### 実装

これでmutexのコードを修正するのに十分な知識が得られました。主に
`kern/src/mutex.rs`で作業しますが`kern/src/vm.rs`、`kern/src/main.rs`、
`kern/src/init.rs`にある他の関数も修正します。

まず、per-コアのMMU初期化から始めてください。以下のように`kmain()`に
`VMM.wait()`を追加してください。

```rust
unsafe fn kmain() -> ! {
    ALLOCATOR.initialize();
    FILESYSTEM.initialize();
    VMM.initialize();
    SCHEDULER.initialize();

    init::initialze_app_cores();
    VMM.wait();

    SCHDULER.start();
}
```

次に、`kern/src/init.rs`にある`kmain2()`を修正し、コアのブートシーケンスを
確認するためにスピニングアドレスに0を書き込んだ後に`VMM.wait()`を呼び出す
ようにしてください。これが終わったら次の行の無限ループ内で何らかの
メッセージを表示してください。

次に、`kern/src/vm.rs`にある`wait()`の実装を完了させてください。具体的には
各コアが`setup()`を呼び出してMMUを設定した後（これはスケルトンコードに
含まれています）、`ready_core_cnt`を1だけインクリメントし、カウントが
コアの数 `pi::common::NCORES` になるまでループします。ここでどのアトミック
順序を使うべきかを考えてください。

提供したmutexのコードはコア間で同期をとらないrelaxedなロード/ストアを
使用しています。そのため、この時点でコードをテストすると、コアからの
出力結果が混ざってしまったり、時にはカーネルがデッドロックして実行が
止まってしまうこともあります。

それでは`kern/src/mutex.rs`にある`try_lock()`と`unlock()`を修正してください。
mutexを正しく実装するには`kern/src/percore.rs`にあるAPIだけでなく
アトミック操作を使用する必要があります。具体的には、`is_mmu_ready()`を使って
MMUが有効か無効かをチェックし、mutexをロックする際には`getcpu()`を使って
コアのプリエンプションカウンタをインクリメントし、mutexをアンロックする
際には`putcpu()`を使ってコアのプリエンプションカウンタをデクリメントします。

以下は、MMUが有効な場合と無効な場合にmutexがどのように動作するかを説明した
ものです。

- **MMUが無効の場合**

  この状態のmutexはコア0がper-カーネルのリソースを初期化している際に
  使用されます。MMUが無効になっている場合、一般的なアトミック操作は
  relaxedロード/ストアを除いて利用できません。そのため、MMUが無効の場合は
  コア0だけにmutexの使用を許可します。mutexにアクセスするコアが1つだけの
  場合、これらの操作はmutexを1つ実装するだけで十分です。実際、これは
  `RefCell`の可変専用バージョンと考えることができます。

  これを実装するには現在のmutexコードのほとんどを再利用することができます。
  mutexがRustの安全性要件に従っていることを確認するために必要なチェックを
  追加してください。

**ヒント**
> mutexのオリジナルコードはリエントラントをサポートしており、mutexの
> 所有者はmutexを複数回ロックできます。しかし、この設計はRustの
> 可変所有者は一人モデルと互換性がありません。mutexの設計を修正する場合、
> これを実装する必要はありません。

- **MMUが有効の場合**

  MMUが有効の場合、アトミック操作で正しいロックとアンロックを実行します。
  全体的なコードの構成はMMUが無効な状態と似ていますが、relaxedなload/
  storeではなく`compare_and_swap`や`swap`のようなアトミック演算を正しい
  順序パラメータで使用する必要があります。[AtomicBool](https://doc.rust-lang.org/core/sync/atomic/struct.AtomicBool.html)の
  APIをチェックして必要なアトミック演算を選んでください。

実装が完了すると各コアからのメッセージは重なりやデッドロックすることなしに
一行ずつ出力されるはずです。期待通りの動作が得られたとしても実装をダブル
チェックしてください。並列コードは本質的に不確定なのでそれに潜むバグを
再現して修正するのは非常に困難です。後で不可解な動作に悩まされるよりは
今時間を割いてバグを防いだ方がずっとましです。自分の設計に自信が持てたら、
次のサブフェーズに進んでください。

**警告: MMUを初期化する前にmutexを使用しないよう注意すること**
> この指示に正しく従った場合、MMUがカレントコアで初期化されていない場合
> `mutex`はコア番号が0に等しいことをアサートします。他のコアがMMUの
> 初期化前にmutexを使おうとすると無限再帰でコアを停止させます。なぜなら、
> `assert!()`は`kprintln!()`を呼び出し、`kprintln!()`は`Mutex::lock()`を
> 呼び出し、`Mutex::lock()`は`assert!()`を呼び出すからです。
>
> これが発生するとカーネルはコンソールに何も表示せずに応答しなくなります。
> カーネルがこのような動作をする場合は、MMUの前にロックの利用を探して
> ください。`kprintln!()`とロギングマクロは内部でコンソールロックを使用
> していることに注意してください。

**警告: `Send`と`Sync`の変性は難しい**
> ラッパー型のトレイト実装は内部型のトレイト実装に依存することがあります。
> これは"変性 (variance)"と呼ばれています。
>
> `Vec<T>`などのコンテナは`T`が`Send`ならば`Send`を実装し、`T`が`Sync`
> ならば`Sync`を実装します。`Mutex`は`T`が`Send`ならば`Send`を実装し、
> `T`が`Send`ならば`Sync`を実装します。`Sync`トレイトと`Send`トレイトの
> 変性ルールはトリッキーで推論が困難です。迷ったら、Rustの標準ライブラリで
> 最も近い型を調べて、その設計に従ってください。

**質問 (mutex-design): mutex設計の説明**
> その順序要件を選択したのはなぜですか。この設計が健全性を保証する
> のはなぜですか。簡潔に説明してください。

**質問 (mutex-bad-state): mutexの状態遷移**
> スレッドがlock()を呼び出し、MMUを初期化し、unlock()を呼び出す場合、
> 何が問題が発生する可能性はありますか。これを防ぐべきだと思うのであれば、
> なぜそれが問題になるのか、どうすれば防げるのかを説明してください。
> `VMManager::wait()`にチェックを追加すると良いかもしれません。そのような
> 動作を許可しても構わないと思うのであれば、その考えを正当化してください。
> どちらの答えが正しいかはmutexをどのように実装したかによります。

### サブフェーズ C: マルチコアスケジューリング

#### Per-core IRQ処理

#### スケジューラの修正

## フェーズ 2: TCPネットワーキング
