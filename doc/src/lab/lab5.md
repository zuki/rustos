# Lab 5: マルチコアとネットワーク

- [フェーズ 0: 始めるために](#フェーズ-0-始めるために)
- [フェース 1: マルチコアの有効化](#フェース-1-マルチコアの有効化)
  - [サブフェース A: 他のコアを起床させる](#サブフェース-a-他のコアを起床させる)
  - [サブフェース B: Mutex再び](#サブフェース-b-mutex再び)
  - [サブフェーズ C: マルチコアスケジューリング](#サブフェーズ-c-マルチコアスケジューリング)
- [フェーズ 2: TCPネットワーキング](#フェーズ-2-tcpネットワーキング)
  - [サブフェーズ A: ネットワーキング101](#サブフェーズ-a-ネットワーキング101)
  - [サブフェーズ B: ネットワークドライバ](#サブフェーズ-b-ネットワークドライバ)
  - [サブフェーズ C: プロセスリソース管理](#サブフェーズ-c-プロセスリソース管理)
  - [サブフェーズ D: ソケットシステムコール](#サブフェーズ-d-ソケットシステムコール)
- [フェーズ 3: エコーサーバ](#フェーズ-3-エコーサーバ)

## はじめに

現在のところ、カーネルはRPiボードにある4つのコアのうち1つのコアしか利用
していません。この課題では、他の3つのコアを有効にし、既存のコンポーネントを
調整してプログラムを正しく並列実行できるようにします。その後、RPi用の既存の
イーサネット実装 (USPi) と最小限のTCPスタック (smoltcp) をカーネルに統合し、
ホストコンピュータとRaspberry Piボードをイーサネットケーブルを介して通信
できるようにします。最後にエコーサーバをカーネル上のユーザプログラムとして
書き、ホストコンピュータからnetcatコマンドを使ってそのサーバとやりとり
します。

## フェーズ 0: 始めるために

lab5 用の更新データをgitリポジトリから各自の開発マシンに取り込みます。

```bash
$ git fetch skeleton
$ git merge skeleton/lab5
```

以下はリポジトリのディレクトリ構成です。この課題で作業するディレクトリには
`*`マークが付いています。

```bash
.
├── bin : common binaries/utilities
├── doc : reference documents
├── ext : external files (e.g., resources for testing)
├── tut : tutorial/practices
│    ├── 0-rustlings
│    ├── 1-blinky
│    ├── 2-shell
│    ├── 3-fs
│    ├── 4-spawn
│    └── 5-multicore : questions for lab5 *
├── boot : bootloader
├── kern : the main os kernel *
├── lib  : required libraries
│     ├── aarch *
│     ├── kernel_api *
│     ├── fat32
│     ├── pi *
│     ├── shim
│     ├── stack-vec
│     ├── ttywrite
│     ├── volatile
│     └── xmodem
└── user : user level program *
      ├── fib
      ├── sleep
      └── socket *
```

## マージガイドライン

作業を進める前にコンフリクトを解決する必要があるかもしれません。たとえば、
次のようなメッセージが表示された場合:

```bash
Auto-merging kern/src/main.rs
CONFLICT (content): Merge conflict in kern/src/main.rs
Automatic merge failed; fix conflicts and then commit the result.
```

コンフリクトを解決するには`main.rs`ファイルを修正する必要があります。
Lab 4での変更をすべて残しておくようにしてください。すべてのコンフリクトが
解決したら`git add`と`git commit`で解決したファイルを追加してください。
マージコンフリクトを解決する方法については[githowto.comのチュートリアル](https://githowto.com/resolving_conflicts)を
参照してください。

Lab 4から様々なデザインが変更されています。マージガイドラインは以下の
変更概要を参照してください。

- Safe / Unsafe の変更

  Rustの安全保障により適合するようにいくつかの safe / unsafe 定義が変更
  されました。この点に関するマージコンフリクトがあった場合は更新された
  定義に従ってください。

- スケジューラ

    - GlobalSchedulerのその定義で`Box`を使うようになりました。これに伴い
      `Scheduler::new()`関数を更新しました。
    - タイマー操作を`start()`から`initialize_global_timer_interrupt()`に
      移動しました。この関数を`GlobalScheduler::start()`で呼び出してくだ
      さい。

- ページテーブル

  カーネルがローカルタイマーアドレスにアクセスできるように`IO_BASE_END`の
  値を上げました。これをサポートするためにカーネルページテーブルはこれまでの
  2つから3つのL3エントリを使用するようになりました。
  `kern/src/vm/pagetable.rs`にある関連する関数を調整してください。

- VMM

  VMMが以前より多くのフィールドを含むようになりました。`initialize()`で
  カーネルテーブルのベースアドレスを計算して`self.kern_pt_addr.store(kern_pt_addr, Ordering::Relaxed);`
  で`kern_pt_addr`フィールドに保存してください。この行が何を意味するかは
  このラボを通して学ぶことになります。

  さらに、`setup()`が`initialize()`で自動的に呼び出されなくなりました。
  これは、仮想メモリーマネージャを初期化する動作とカレントコアのMMUを
  セットアップする動作を分離するためであり、これにより複数のコアにおいて
  両者を独立に呼び出せるようになります。`kmain()`で`VMM.initialize()`の
  直後に`VMM.setup()`の呼び出しを追加する必要があります。

- IRQ / トラップ

  IRQは再設計されトレイトベースのロジックを使用するようになりました。
  `kern/src/traps/irq.rs`の変更箇所を読んでください。関数`register()`と
  `invoke()`を変更し、必要に応じて`handle_exception()`も変更してください。

- `write_str` syscall

  以前のラボではシリアルに1バイトを出力する`write()`システムコールしか
  ありませんでした。あらたに`write_str()` syscallを追加しました。これは
  ユーザからsliceを受け取りatomicallyに出力します。`kerenl.api`ライブラリは
  これを使用するように変更されました。ユーザプログラムを再コンパイルして
  SDカードにコピーしてください。

## ロギング基盤

カーネルコードではメッセージロギングに`kprintln!`ではなく、Rustの`log`
クレートを使うようになりました。これにより`trace!`, `debug!`, `info!`,
`warn!`, `error!`の5つのロギングマクロが使えるようになります。

ロギングコードは`kern/src/logger.rs`で定義されています。ビルド時に
`VERBOSE_BUILD`環境変数が設定された場合（たとえば、`VERBOSE_BUILD=1 make`）、
すべてのログが有効になります。そうでなければtraceレベルのログは表示され
ません。各状況においてどのレベルのログを使うべきかについては具体的な
要件はありませんが、簡単なガイドラインを以下に示します。

- Trece: カーネルデバッグには役立つがデフォルトで有効にするには冗長
  すぎる情報
    - スケジューラスイッチログ
    - IRQ割り込みログ
- Debug: 開発者が興味を持ちそうな情報
    - ページテーブルアドレス
- Info: カーネルユーザが興味を持ちそうな情報
    - システムのメモリ容量
    - カーネルの初期化ステータス
- Warn: 例外的なエラー状況の表示
    - メモリ不足
    - ユーザプログラムの不明な例外
- Error: カーネルの通常実行中には発生してはならない事象の表示
    - デバッグのアサーション違反
    - カーネル内部の不明な例外

## ARMドキュメント

lab 4で紹介した次の3つのドキュメントに加えて

- [ARMv8リファレンスマニュアル](https://tc.gts3.org/cs3210/2020/spring/r/ARMv8-Reference-Manual.pdf)
  ARMv8アーキテクチャの公式リファレンスマニュアルです。アーキテクチャ全体を
  一般的な方法で網羅する完全マニュアルです。Raspberry Pi 3向けのアーキ
  テクチャの具体的な実装についてはARM Cortex-A53マニュアルを参照して
  ください。このマニュアルのセクションは([ref](https://tc.gts3.org/cs3210/2020/spring/r/ARMv8-Reference-Manual.pdf): C5.2)と
  いう形の注記で参照し、ARMv8リファレンスマニュアルのセクションC5.2を参照
  する必要があることを示します。
- [ARM Cortex-A53マニュアル](https://tc.gts3.org/cs3210/2020/spring/r/ARM-Cortex-A53-Manual.pdf)
  Raspberry Pi 3で使用されているARMv8 (v8.0-A)アーキテクチャの具体的な
  実装に関するマニュアルです。このマニュアルのセクションは([A53](https://tc.gts3.org/cs3210/2020/spring/r/ARM-Cortex-A53-Manual.pdf): 4.3.30)と
  いう形の注記で参照し、ARM Cortex-A53マニュアルのセクション4.3.30を参照
  する必要があることを示します。
- [ARMv8-Aプログラマガイド](https://tc.gts3.org/cs3210/2020/spring/r/ARMv8-A-Programmer-Guide.pdf)
  ARMv8-Aプロセスのプログラミング方法に関する高レベルのガイドです。
  このマニュアルのセクションは([guide](https://tc.gts3.org/cs3210/2020/spring/r/ARMv8-A-Programmer-Guide.pdf): 10.1)と
  いう形の注記で参照し、ARMv8-Aプログラマガイドのセクション10.1を参照
  する必要があることを示します。

Lab 5ではさらに2つのドキュメントを使用します。

- [AArch64プログラマガイド: 汎用タイマー](https://tc.gts3.org/cs3210/2020/spring/r/aarch64-generic-timer.pdf)
  ARMアーキテクチャの汎用タイマーに関するガイドです。このマニュアルの
  セクションは([timer](https://tc.gts3.org/cs3210/2020/spring/r/aarch64-generic-timer.pdf): 3.2)と
  いう形の注記で参照し、AArch64プログラマガイド: 汎用タイマーのセクション
  3.2を参照する必要があることを示します。
- [Quad-A7 Control](https://tc.gts3.org/cs3210/2020/spring/r/QA7_rev3.4.pdf)
  Quad-A7制御に関するガイドで、コアごとのタイマーと割り込み処理に関する
  説明があります。このマニュアルのセクションは([QA7](https://tc.gts3.org/cs3210/2020/spring/r/QA7_rev3.4.pdf): 4.10)と
  いう形の注記で参照し、Quad-A7 Controlのセクション4.10を参照する必要が
  あることを示します。

これら5つの文書はすべて研究室リポジトリの`doc/`サブディレクトリにあります。
今すぐこの5つのドキュメントをダウンロードして、すぐ手の届くところに置いて
おくことを勧めます。

## フェース 1: マルチコアの有効化

ラボ4ではプリエンプティブスケジューリングについて学びました。これは
コンテキストスイッチングにより1つのカーネル内で複数のユーザプログラムを
同時に実行することを可能にするものでした。複数のプログラムがカーネル上で
_同時 (concurrently)_ 実行されていましたが、ある時点では1つのユーザ
プログラムだけがコアを占有していたことに注意してください。このフェーズでは
RPiボードにある残りの3つのコアを有効にしてユーザプログラムの _並列 (parallel)_
実行をサポートします。並列プログラミングにはシングルスレッドプログラミングには
存在しない多くの固有の問題があります。これを解決するためにミューテックス、
IRQハンドラ、スケジューラの設計を再検討し、マルチコア環境に合わせて調整します。

### サブフェース A: 他のコアを起床させる

このサブフェーズではスピンテーブル機構を使用してBCM2837の残りの3つのコアを
有効にします。

#### スピンテーブル

CPUのすべてのコアはメインメモリ（RAM）を共有しています。そのため、RAMを
コア間の通信媒体として利用できます。_スピンテーブル_ はこのRAMの特性を
利用した起動メカニズムであす。RPiの電源を入れると最初のコアであるコア0は
`kern/src/init.rs`で定義されている`_start`関数にジャンプします。他のコアは
すべてカーネルの外でスピンして、スピニングアドレスをポーリングしています。

[RPiファームウェア](https://github.com/raspberrypi/tools/blob/b0c869bc929587a7e1d20a98e2dc828a24ca396a/armstubs/armstub8.S#L132-L154)の
以下のコードがスピンテーブル機構を実装しています。

```
in_el2:
    mrs x6, MPIDR_EL1
    and x6, x6, #0x3
    cbz x6, primary_cpu

    adr x5, spin_cpu0

secondary_spin:
    wfe
    ldr x4, [x5, x6, lsl #3]
    cbz x4, secondary_spin
    mov x0, #0
    b boot_kernel

primary_cpu:
    ldr w4, kernel_entry32
    ldr w0, dtb_ptr32

boot_kernel:
    mov x1, #0
    mov x2, #0
    mov x3, #0
    br x4
```

RPiが起動するとコア0はシンボル`kernel_entry32`からカーネルアドレスを
ロードしてそのアドレスに分岐します。RPiファームウェアはこのルーチンの前に
`config.txt`で指定された`kernel_address`の値を`kernel_entry32`にセットします。
他のすべてのコアは`secondary_spin`ループ内で`wfe`でスピンします。ループ中、
これらのコアは`spin_cpu0 + 8 * core_idx`から8バイトのアドレスをロードし、
0でなければそのアドレスに分岐します。そのため、他のコアを起床させるに
コア0は開始アドレスをスピニングアドレスに書き込み、`sev`命令でイベントを
送信する必要があります。他のコアのエントリポイントには`init::start2`を
使います。

各コアは他のコアと干渉しないように各自のスタックポインタを使用する必要が
あります。関数`_start`はコア0のスタックレジスタとして`KERN_STACK_BASE`を
割り当てています。私たちのカーネル設計ではコア`i+1`はコア`i`のスタックの
直下を使用します。すなわち、コア`i`のスタックポインタは
`KERN_STACK_BASE - KERN_STACK_SIZE * i`です。

#### 実装

これでコアの初期化ルーチンを実装する準備ができました。`kern/src/main.rs`に
ある`kmain()`と`kern/src/init.rs`にある`initialize_app_cores()`,
`start2()`, `kmain2()`を作成します。

これらの関数は好きな順番で実装して構いません。

- **`initialize_app_cores()`では`start2()`のアドレスを各コアのスピニングアドレスに書き込みます**

    スピニングベースである`spin_cpu0`は`pi/src/common.rs`において定数
    `SPINNING_BASE`として定義されています。コア0は各コアのスピニング
    アドレスを計算してそのアドレスに`start2()`のアドレスを書き込み、
    `sev()`を実行し、各コアからの確認を待ちます。他のコアは完全に目覚めたら、
    `kmain2()`でスピニングアドレスに0を書き込みます。コア0はすべてのコアの
    スピニングアドレスが0で上書きされたことを確認した上で
    `initialize_app_cores()`から復帰する必要があります。

- **`start2()`ではスタックポインタをセットして`kinit2()`に分岐します**

    上で説明したようにスタックポインタをセットしてください。コアの
    インデックスは`MPIDR_EL1`から抽出できることを思い出してください。
    次に、スタックレジスタをセットしてから`kinit2`に分岐してください。
    スタックポインタを変更しているので`start2()`ではスタック変数を使用
    しないように注意してください。

    **警告: `aarch64::affinity()`は動作しない可能性があります**

    `aarch64::affinity()`はインライン化されることが保証されておらず、
    関数を呼び出すためにスタック空間を使用する可能性があります。
    スタックポインタはまだセットしていないので`aarch64::affinity()`を
    使うことができないかもしれません。`MPIDR_EL1`レジスタに直接
    アクセスしてみてください。

- **`kmain2()`ではメッセージを表示し、コアが使用可能であることを確認します**

    初期化が成功すると各コアは`kmain2()`に到達し、**EL1**で実行を開始します。
    `kmain2()`ではコアのスピンingアドレスンに0を書き込んでコア0に通知します。
    その後、コンソールに任意のメッセージを表示して無限ループに入ってください。
    新しく追加されたロギングマクロを使ってください。

コードを書き終えたら、`kmain()`を次のように変更してください。

```rust
unsafe fn kmain() -> ! {
    ALLOCATOR.initilaiize();
    FILESYSTEM.initialize();
    VMM.initialize();
    SCHEDULER.initialize();

    init::initialize_app_cores();
    VMM.setup();

    SCHEDULER.start();
}
```

RPiボード上でカーネルを実行すると各コアからの初期化メッセージが表示される
はずです。ただし、これらの新しいコアはまだ何の役にも立っていません。私たちの
カーネルのいくつかのコンポーネントはまだパラレル対応になっていないからです。
次のステップはこれらの古い設計を修正することです。

**警告: 不健全なミューテックスに注意**
> 私たちのミューテックスは健全ではないので、内部的にミューテックスを使用
> している`kprintln!()`やロギングマクロを複数のコアからアクセスすると
> デッドロックを起こしたり、データ競合を引き起こしたりする可能性があります。
> これはまれなケースであり、十分な時間リトライすれば成功するケースが
> 見られるはずです。すぐに修正する予定です。

**質問 (spin-address): アドレスをハードコードせずにスピンベースを検出する方法は**
> Raspberry Piのスピンアドレスをカーネルにハードコードしているので
> スピンアドレスの異なる他のハードウェアではカーネルは動作しません。
> Linuxカーネルはこの問題をどのように解決していますか。

### サブフェース B: Mutex再び

私たちのスケルトンコードのmutexのコードは実際にはスレッドセーフではなく、
SendトレイトとSyncトレイトをunsafeで実装することによりRustコンパイラを
騙しています。こうしたのはスレッドセーフなmutexの実装に必要なアトミックな
メモリ操作がAArch64アーキテクチャではMMUが初期化されていないと利用できない
からです。これはラボ4で追加されたところです。システムで使用できるコアが1つ
しかないことを理由に私たちの設計を正当化してきました。しかし、今やMMUと
マルチコアが共に有効になったのでその嘘を正す時です。このサブフェーズでは
複数のコアが健全な方法でmutexを使用できるようにmutexの設計を修正します。
`kern/src/mutex.rs`で作業することになります。

#### Per-coreデータ管理

カーネルで複数のコアがアクティブになっている場合、カーネルはper-カーネルの
リソースの初期化とper-コアのリソースの初期化を区別する必要があります。per-
カーネルのリソースは起動時に一度だけ初期化する必要があります。私たちの
カーネルのper-カーネルのリソースは`main.rs`で定義されています。`ALLOCATOR`,
`FILESYSTEM`, `SCHEDULER`などの静的構造体はper-カーネルのリソースです。コ
ア0は他のコアを起床させる前にper-カーネルのリソースを初期化する必要があり
ます。一方、per-コアのリソースは`kmain()`と`kmain2()`でコアごとに初期化する
必要があります。

では`kern/src/percore.rs`にあるper-コアのリソースの定義を読んでください。
各`PerCore`構造体は3つのデータフィールド: `preemption`, `mmu_ready`,
`local_irq`を持っています。`preemption`はコアが保持しているロックの数を
カウントし、`mmu_ready`フラグはMMUが各コアでセットされているか否かを保存し、
`local_irq`は各ローカル割り込みのIRQハンドラを保存します。

`PerCore`構造体の定義にアトミック型が使われていることに気づいたかも
しれません。現時点ではアトミック型は内部可変性 (mutabliity) を持つ
プレーンな型だと考えてください。アトミック型については後で詳しく説明します。

次は`kern/src/vm.rs`のコードを読んでください。ラボ4では`setup()`は
`initialize()`から直接呼び出され、コア0は仮想メモリマネージャを初期化した後、
直ちにMMUを初期化していました。しかし、ラボ5では両者の役割を分離します。
コア0はグローバルな初期化ルーチンの中で仮想メモリマネージャを初期化し、
コア0を含む各コアはコアの初期化が終わった後に各自のMMUを設定します。

`wait()`の部分的な実装を用意しました。これがどのように`setup()`を呼び
出しているか、`set_mmu_ready()`と`is_mmu_ready()`がper-コアのMMU初期化
情報の追跡にどのように使用されているかを確認してください。後ほどすべての
コアのMMU初期化が終了して一緒に復帰するまで各コアがループして待機するように
コードの残りの部分を埋めることになります。

#### メモリ一貫性モデル

RAMはすべてのコアで共有されることを思い出してください。複数のコアが同じ
アドレスを読み書きする場合、どの順番で値を読み書きするでしょうか。
プログラムでどのように出力したらこれを観測することができるでしょうか。
x86-64とAArch64では同一のプログラムが異なる動作をすることがあるでしょうか。
アーキテクチャの _メモリ一貫性モデル_ によりこれらの質問の答えがわかります。

2つのスレッドが値を変更してそれを出力するメモリ順序の典型的な例を見て
みましょう。Rustの型システムではunsafeブロックがないとこの例はコンパイル
できませんが、デモンストレーションのために、このコードはRustのバリアントで
書かれたと仮定します。AとBは両方とも0に初期化されていると仮定します。

```rust
/* スレッド 1 */
A = 1; // (1)
print!("{}", B); // (2)

/* スレッド 2 */
B = 1; // (3)
print!("{}", A); // (4)
```

最も直感的なメモリ一貫性モデルの1つは、逐次一貫性 (**SC: Sequential Consistency**)
です。これは次の2つ: (1) すべての読み書きに _大域的な順序_ が存在する、
(2) インタリーブがあっても同じスレッド内の命令の順序（プログラムの順序）は
保持される、を仮定します。このモデルにおいて上のプログラムが出力する
可能性のある結果の1つは`01`です。これは1つのスレッドが実行を完了して
から他方のスレッドが実行を開始した場合です。この結果を出力するプログラムの
実行順序は`1-2-3-4`または`3-4-1-2`です。`11`は少しわかりにくい出力ですが、
2つのスレッドの実行が`1-3-2-4`や`3-1-2-4`のようにインタリーブされる
場合です。このモデルでは上のプログラムから`00`は出力されません。
（訳注: 前提(2)により変数の設定よりprintが先に実行されることはないため）

**注記: マルチスレッドとマルチコア**
> 厳密に言えばマルチスレッドとマルチコアは異なる概念です。複数のスレッドが
> 1つのコアで実行されている場合、メモリ一貫性の問題は発生しません。しかし、
> 最近ではほとんどすべてのCPUが複数のコアを搭載しており、2つの用語は交換
> 可能な用語として使われる場合があります。このラボの文書で「マルチ
> スレッド」と書かれている場合は、特に断りがなければ、マルチコアCPU上で
> 複数のスレッドが実行されていることを意味すると考えてください。

最新のCPUはアウトオブオーダ実行、per-コアキャッシュ、ロード/ストア最適化
など、実行性能を大幅に向上させる数々の最適化を活用しています。残念ながら、
SCはこれらの最適化を許すには厳しすぎます。SCは複数のコアで実行されている
すべてのメモリ操作のグローバルな順序付けを要求しており、これは本質的には
マルチコアアーキテクチャにシングルスレッドの振る舞いを要求します。
そのため、最新のアーキテクチャではSCよりも弱いメモリ一貫性モデルを採用して
います。

![ARM Coretex-A53](cortex-a53.png)

**TSO (Total store ordering)** はSCより若干弱い一貫性モデルです。ストア
バッファリングが可能で、書き込み操作の他のコアへの伝搬を遅らせることが
できます。この緩和によりSCモデルよりも大幅な性能向上が可能になります。
x86とx86-64ではTSOに非常に近いメモリ一貫性を規定しています。

TSOはSCの多くの保証を維持していますが、SCでは除外されていたある動作を許可
します。もう一度上のサンプルコードを見てみましょう。

```rust
/* スレッド 1 */
A = 1; // (1)
print!("{}", B); // (2)

/* スレッド 2 */
B = 1; // (3)
print!("{}", A); // (4)
```

TSOモデルではこのプログラムの結果として`00`が観察されることがあります。
`A=1`がスレッド1のキャッシュに格納され、`B=1`がスレッド2のキャッシュに
格納され、さらに書き込みが互いに伝播する前に各スレッドが実行を続行した場合、
両スレッドが結果として0を出力する可能性があるからです。これはSCでは許されない
動作です。

ARMアーキテクチャではさらに弱いメモリモデルを規定しています。次の
プログラムを考えて見ましょう。

```rust
/* スレッド 1 */
B = 1; // (1)
A = 1; // (2)

/* スレッド 2 */
print!("{}", A); // (3)
print!("{}", B); // (4)
```

ARMの一貫性モデルでは驚くべきことにこのプログラムは結果として`10`を
出力することができます。これは、スレッド2はスレッド1の書き込みを、
スレッド1が書き込む順序とは異なる順序で観察することができることを
意味します。TSOの下ではこれは許されません。後続の書き込みはそれが書き
込まれた順序で他のコアから見えるようになるからです（そのために"total
store ordering"と呼ばれます）。

ARMアーキテクチャは「データ依存性を持つ弱いメモリ順序」を持つと言われて
います。一般に、弱いメモリ順序モデルではプログラムの順序に関係なく、
2つの異なるメモリ位置の間の一貫性は保証されません。ただし、あるメモリ
位置の値が別のメモリ位置の値に依存する場合は、データ依存性が保証されます。

次の2つの例を考えてみましょう。

```rust
/* プログラム 1 */
A = 1; // (1)
B = 1; // (2)

/* プログラム 2 */
C = 1; // (3)
D = C; // (4)
```

プログラム1ではAとBは独立したメモリ位置なので他のスレッドは(1)よりも先に
(2)を観測することができます。しかし、プログラム2ではDの値はCの値に依存する
ので、他のスレッドがメモリ位置Dで1を観測したとすればメモリ位置Cでは1が
観測されることが保証されます。

**質問 (consistency-handson): メモリ一貫性の例**
> 2つのスレッドを使用して、SC、TSO、ARMハードウェア上で異なる結果セットを
> 表示する例を書いてください。各メモリ一貫性モデルで何が出力できるかを指定
> してください。

さらに、ハードウェアだけでなく、言語もそのメモリ一貫性モデルを定義しています。
コンパイラがプログラムコードを最適化する際に言語仕様に基づいて特定の
ステートメントを並べ替えたり、完全に削除したりすることがあります。

```rust
/* プログラム 1 */
let mut x = &mut 1;
for i in 0..1000 {
    println!("{}", *x);
}

/* プログラム 2 */
for i in 0..1000 {
    println!("{}", 1);
}
```

このコードスニペットではループ中に変数`x`を変更する他のスレッドがなければ
プログラム1と2は等価です。では、Rustコンパイラがプログラム1をプログラム2に
最適化することは妥当でしょうか。Rustの可変参照は元となる値への排他的
アクセスを意味することを思い出してください。つまり、Rustでは答えはイエス
です。コンパイラは`x`が元となるメモリ位置への一意のアクセスであるという
仮定に基づいてプログラム1をプログラム2に最適化することができます。`x`が
他のスレッドにより変更される可能性があることをコンパイラに伝えるには
可変参照`&mut`の代わりに生ポインタや`UnsafeCell`を使用する必要があります。

#### メモリバリアとアトミック命令

この時点で感じているはずですが、正しい並列プログラムを書くのは正しい
シングルスレッドプログラムを書くよりもかなり難しいです。並列プログラミング
には数多くの認識上の落とし穴があり、AArch64の弱いメモリ一貫性モデルは並列
プログラムの推論をさらに複雑にしています。

メモリバリアとアトミック命令はアーキテクチャがメモリ順序の複雑さを和らげる
ために提供しているツールです。これらのツールによりプログラマはより強力な
メモリ順序保証を局所的かつ制御された方法を自ら導入することができます。
また、言語レベルでも、異なるメモリ一貫性保証を持つ複数のアーキテクチャに
コンパイル可能な移植性の高いコードを書く方法を提供しています。

**メモリバリア**はバリア前後の命令間の依存関係を保証します。メモリバリア
によりプログラムの正しさのために強力なメモリ順序保証が必要な場合にバリア
前後の命令間の依存関係を明示的に指定することができます。

ARMアーキテクチャには3種類のメモリバリア命令があります (ref: B2.3.5)。
デフォルトでは完全なシステムバリア操作として動作します。これはバリア前後の
命令を（命令タイプに応じて）完全に同期させます。オプションパラメータを
使って、特定の命令タイプだけを待つように動作を調整することができます。
たとえば、ロードではなくストアだけを待機させることができます。

- **DMB**: データメモリバリア

  データメモリバリアはメモリバリアとして機能します。DMBはプログラム順序で
  DMB命令より前に現れるすべての明示的なメモリアクセスが、プログラム順序で
  DMB命令より後に現れる明示的なメモリアクセスより前に観測されることを保証
  します。

- **DSB**: データ同期バリア

    データ同期バリアは特殊なメモリバリアとして機能します。この命令が
    完了するまでプログラム順序でこの命令より後の命令は実行されません。

- **ISB**: 命令同期バリア

    命令同期バリアはプロセッサ内のパイプラインをフラッシュし、この
    命令に続くすべての命令がISB命令の完了後にキャッシュまたはメモリから
    フェッチされるようにします。

**質問 (context-restore-barrier): context_restoreにおけるバリア**
> ラボ4でTTBRレジスタを上書きした後に以下の4つの命令を追加した
> ことを思い出してください。これらの行が何を意味しているか、ページ
> テーブルの更新時にこれらの命令が必要な理由を説明してください。

```
dsb   ishst
tlbi  vmalle1
dsb   ish
isb
```

**アトミック命令**は並列プログラミングを容易にするためにアーキテクチャが
提供しているもう1つのツールです。アトミック命令はある動作を部分的に実行する
ことができないことを保証します。

```
/* スレッド 1 */
mov x0, #0
mov x1, addr of counter
loop:
    ldr x2, [x1]
    add x2, x2, #1
    str x2, [x1]
    add x0, x0, #1
    cmp x0, #1000
    ble loop

/* プログラム 2 */
mov x0, #0
mov x1, addr of counter
loop:
    ldr x2, [x1]
    add x2, x2, #1
    str x2, [x1]
    add x0, x0, #1
    cmp x0, #1000
    ble loop
```

2つのスレッドが同じメモリアドレスをインクリメントしているこのプログラムを
考えてみましょう。両スレッドは1000回ループしているのでスレッドが実行を
終了した際にカウンタは理想的には2000になっているはずです。残念ながら
インクリメントはアトミックに実行されていないので各スレッドはお互いの
「中間」値を読むことができます。このプログラムはスレッド1がロードとストアを
する間の時間枠にスレッド2がカウンタの値をロードすることを防ぎません。
これが起きるとスレッド1とスレッド2の双方が同じ値をカウンタに書き込むことに
なり、その結果、カウンタは2ではなく1しかインクリメントされないことに
なります。

アトミック命令はノンプリエンプティブな方法でアクションを実行する
（フェッチと加算を単一命令で実行する）か、データ競合を検出するメカニズムを
提供して操作を再試行できるようにすることでこの問題を解決します。これらの
アトミック命令はmutexなどのより高レベルな同期プリミティブの構成要素です。
AArch64のアトミック命令の詳細についてはARMv8-Aアーキテクチャリファレンス
マニュアルの C3.2.12-14とARMv8-A Synchronization Primitivesドキュメントを
参照してください。

**質問 (atomic-handson): アトミックアセンブリコードの作成**
> 上のプログラムをアトミック命令で書き直して答えが常に正しくなるように
> してください。

**注記: アーキテクチャのバージョンを確認**
> アトミック命令を記述する際にはアーキテクチャのバージョンを確認する必要
> があります。たとえば、CAS (Compare and swap) 命令はARMv8.1以降でしか
> 使用できず、ARMv8では使用できません。Rustを使用している場合、これは
> LLVMバックエンドが自動的に処理します。

低レベルのインラインアセンブリレベルで作業する場合を除いて、Rustの標準
ライブラリが提供する[AtomicBool](https://doc.rust-lang.org/core/sync/atomic/struct.AtomicBool.html)や
[AtomicUsize](https://doc.rust-lang.org/core/sync/atomic/struct.AtomicUsize.html)
などのアトミックデータ型を使用するべきです。これらは`fetch_and()`や
`compare_and_swap()`などの高レベルなアトミック操作を提供しています。
アーキテクチャがこれらを単一の演算としてサポートしていなくても、
コンパイラはこのセマンティクスを保持して複数の小さなアトミック演算を
使って実装しています。

```rust
impl AtmicBool {
    pub fn fetch_and(&self, val: bool, order: Ordering) -> bool { ... }
}

impl AtomicUsize {
    pub fn compare_and_swap(
        &self,
        current: usize,
        new: usize,
        order: Ordering
    ) -> usize { ... }
}
```

これらの操作の第1変数が`&self`となっていることに注意してください。Rustの不変参照は
その値へのアクセスが共有されていることを意味します。複数のコードが同時にこの
値にアクセスしたとしてもアトミック操作はデータ競合が起こらないことを保証します。
そのため、これらの操作では`&mut self`ではなく`&self`を使用しても問題ありません。

![acquire and release semantics](acq_rel_semantics.png)

これらのアトミック命令は`Ordering`パラメータを受け取ります。Rustは
[5種類のメモリ順序](https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html)を
提供しており、これは[C++20と同じ](https://en.cppreference.com/w/cpp/atomic/memory_order)です。
_Relaxed_ 順序は順序付けを保証しないアトミック操作を提供します。_acquire_
順序と _release_ 順序はペアで使用されます。acquire順序を持つロードは
このロード命令の後にある命令がロード前に並び替えられるのを防ぎ、
release順序を持つストアはこのストア命令の前にある命令がストア後に並び
替えられるのを防ぎます。その結果、あるアドレスのacquire/releaseペアは
クリティカル領域を形成し、その間にある命令がクリティカル領域外に並び
替えられるの防ぎます。さらに、スレッドAがrelease順序で変数に書き込み、
スレッドBが同じ変数をacquire順序で読み取る場合、スレッドBの後続のすべての
ロードは、release順序で書き込む前のスレッドBからのストアを見ることが
できます。_AcqRel_ はロードとストアを実行するアトミック命令のための
_Acquire_ ＋ _Release_ です。_SeqCst_ はすべてのスレッドが同じ順序の
連続的に一貫性のある操作を見ることができることを保証することを _AcqRel_ に
追加したものです。

**注記: さらなる参考資料**
> [Rust裏本の第8章](https://doc.rust-jp.rs/rust-nomicon-ja/concurrency.html)に
> これまで取り上げた内容の要約があります。

#### 実装

これでmutexのコードを修正するのに十分な知識が得られました。主に
`kern/src/mutex.rs`で作業しますが`kern/src/vm.rs`、`kern/src/main.rs`、
`kern/src/init.rs`にある他の関数も修正します。

まず、per-コアのMMU初期化から始めてください。以下のように`kmain()`に
`VMM.wait()`を追加してください。

```rust
unsafe fn kmain() -> ! {
    ALLOCATOR.initialize();
    FILESYSTEM.initialize();
    VMM.initialize();
    SCHEDULER.initialize();

    init::initialze_app_cores();
    VMM.wait();

    SCHDULER.start();
}
```

次に、`kern/src/init.rs`にある`kmain2()`を修正し、コアのブートシーケンスを
確認するためにスピニングアドレスに0を書き込んだ後に`VMM.wait()`を呼び出す
ようにしてください。これが終わったら次の行の無限ループ内で何らかの
メッセージを表示してください。

次に、`kern/src/vm.rs`にある`wait()`の実装を完了させてください。具体的には
各コアが`setup()`を呼び出してMMUを設定した後（これはスケルトンコードに
含まれています）、`ready_core_cnt`を1だけインクリメントし、カウントが
コアの数 `pi::common::NCORES` になるまでループします。ここでどのアトミック
順序を使うべきかを考えてください。

提供したmutexのコードはコア間で同期をとらないrelaxedなロード/ストアを
使用しています。そのため、この時点でコードをテストすると、コアからの
出力結果が混ざってしまったり、時にはカーネルがデッドロックして実行が
止まってしまうこともあります。

それでは`kern/src/mutex.rs`にある`try_lock()`と`unlock()`を修正してください。
mutexを正しく実装するには`kern/src/percore.rs`にあるAPIだけでなく
アトミック操作を使用する必要があります。具体的には、`is_mmu_ready()`を使って
MMUが有効か無効かをチェックし、mutexをロックする際には`getcpu()`を使って
コアのプリエンプションカウンタをインクリメントし、mutexをアンロックする
際には`putcpu()`を使ってコアのプリエンプションカウンタをデクリメントします。

以下は、MMUが有効な場合と無効な場合にmutexがどのように動作するかを説明した
ものです。

- **MMUが無効の場合**

  この状態のmutexはコア0がper-カーネルのリソースを初期化している際に
  使用されます。MMUが無効になっている場合、一般的なアトミック操作は
  relaxedロード/ストアを除いて利用できません。そのため、MMUが無効の場合は
  コア0だけにmutexの使用を許可します。mutexにアクセスするコアが1つだけの
  場合、これらの操作はmutexを1つ実装するだけで十分です。実際、これは
  `RefCell`の可変専用バージョンと考えることができます。

  これを実装するには現在のmutexコードのほとんどを再利用することができます。
  mutexがRustの安全性要件に従っていることを確認するために必要なチェックを
  追加してください。

**ヒント**
> mutexのオリジナルコードはリエントラントをサポートしており、mutexの
> 所有者はmutexを複数回ロックできます。しかし、この設計はRustの
> 可変所有者は一人モデルと互換性がありません。mutexの設計を修正する場合、
> これを実装する必要はありません。

- **MMUが有効の場合**

  MMUが有効の場合、アトミック操作で正しいロックとアンロックを実行します。
  全体的なコードの構成はMMUが無効な状態と似ていますが、relaxedなload/
  storeではなく`compare_and_swap`や`swap`のようなアトミック演算を正しい
  順序パラメータで使用する必要があります。[AtomicBool](https://doc.rust-lang.org/core/sync/atomic/struct.AtomicBool.html)の
  APIをチェックして必要なアトミック演算を選んでください。

実装が完了すると各コアからのメッセージは重なりやデッドロックすることなしに
一行ずつ出力されるはずです。期待通りの動作が得られたとしても実装をダブル
チェックしてください。並列コードは本質的に不確定なのでそれに潜むバグを
再現して修正するのは非常に困難です。後で不可解な動作に悩まされるよりは
今時間を割いてバグを防いだ方がずっとましです。自分の設計に自信が持てたら、
次のサブフェーズに進んでください。

**警告: MMUを初期化する前にmutexを使用しないよう注意すること**
> この指示に正しく従った場合、MMUがカレントコアで初期化されていない場合
> `mutex`はコア番号が0に等しいことをアサートします。他のコアがMMUの
> 初期化前にmutexを使おうとすると無限再帰でコアを停止させます。なぜなら、
> `assert!()`は`kprintln!()`を呼び出し、`kprintln!()`は`Mutex::lock()`を
> 呼び出し、`Mutex::lock()`は`assert!()`を呼び出すからです。
>
> これが発生するとカーネルはコンソールに何も表示せずに応答しなくなります。
> カーネルがこのような動作をする場合は、MMUの前にロックの利用を探して
> ください。`kprintln!()`とロギングマクロは内部でコンソールロックを使用
> していることに注意してください。

**警告: `Send`と`Sync`の変性は難しい**
> ラッパー型のトレイト実装は内部型のトレイト実装に依存することがあります。
> これは"変性 (variance)"と呼ばれています。
>
> `Vec<T>`などのコンテナは`T`が`Send`ならば`Send`を実装し、`T`が`Sync`
> ならば`Sync`を実装します。`Mutex`は`T`が`Send`ならば`Send`を実装し、
> `T`が`Send`ならば`Sync`を実装します。`Sync`トレイトと`Send`トレイトの
> 変性ルールはトリッキーで推論が困難です。迷ったら、Rustの標準ライブラリで
> 最も近い型を調べて、その設計に従ってください。

**質問 (mutex-design): mutex設計の説明**
> その順序要件を選択したのはなぜですか。この設計が健全性を保証する
> のはなぜですか。簡潔に説明してください。

**質問 (mutex-bad-state): mutexの状態遷移**
> スレッドがlock()を呼び出し、MMUを初期化し、unlock()を呼び出す場合、
> 何が問題が発生する可能性はありますか。これを防ぐべきだと思うのであれば、
> なぜそれが問題になるのか、どうすれば防げるのかを説明してください。
> `VMManager::wait()`にチェックを追加すると良いかもしれません。そのような
> 動作を許可しても構わないと思うのであれば、その考えを正当化してください。
> どちらの答えが正しいかはmutexをどのように実装したかによります。

### サブフェーズ C: マルチコアスケジューリング

現時点ではコア0だけがユーザープログラムのスケジューリングを行っています。
このサブフェーズでは他のコアもスケジューリングに参加させます。その結果、
私たちのカーネルはシングルコア版と比較してプロセスを実行するスループットが
約4倍になります。

#### Per-コアIRQ処理

このセクションではper-コアIRQ処理を有効にします。現在、`IO_BASE + 0x3000`に
あるタイマーレジスタを使用していますが、このタイマーからの割り込みはコア0に
しか伝搬しません。他のコアをスケジューリングに参加させるために`CNTPNSIRQ`
(Counter Physical Non-Secure IRQ) という別のタイマー割り込みに切り替えます。

主に`pi/src/local_interrupt.rs`で作業します。全体の構造は`pi/src/timer.rs`と
`pi/src/interrupt.rs`のそれとほぼ同じです。また、per-コアIRQ処理に関する作業を
行う際には参考文献として"AArch64 Programmer's Guides: Generic Timer" (timer)
と"Quad-A7 Control" (QA7)も読むことになるでしょう。前者はAArch64アーキテクチャで
汎用タイマーがどのように動作するかについて、後者は割り込みが汎用タイマーから
各コアへどのように伝搬するかについて説明しています。

まず、`Registers`の定義を完成させてください。レジスタの定義はQA7の第4章を
参照してください。レジスタの定義は"Core3 FIQ Source"までで構いません。
次に、`LocalInterrupt`の定義を完成させ、`LocalInterrupt`用の`From<usize>`を
実装してください。定義についてはQA7: 4.10を参照してくだあい。

次に、`LocalController`の以下の関数を実装してください。

- `enable_local_timer()`

  `CNTP_CTL_EL0`レジスタに適切なビットをセットしてCNTPタイマーを有効にして
  ください (ref: D7.5.10)。そして、Core X タイマー割り込み制御レジスタ
  (QA7: 4.6) に値を書き込んでper-コアCNTPNS IRQを有効にしてくださ。可能な限り
  インラインアセンブリは書かずに`lib/aarch64/src/regs.rs`にあるレジスタ定義を
  使用してください。

- `is_pending()`

  Core X 割り込みソースレジスタ (QA7: 4.10) の対応するビットを読み込んで
  ブール値に変換してください。

- `tick_in()`

  最後に、ラボ4で行ったように汎用タイマーの`tick_in()`メソッドを実装して
  ください。どのレジスタを使用するべきかはtimer: 3.1から3.3を参照してください。
  タイマーの周波数を使用して`Duration`をカウンターのtick値に変換する必要が
  あるでしょう。繰り返しますが、インラインアセンブリを書くより
  `lib/aarch64/src/regs.rs`のレジスタ定義を使用してください。

**質問 (cntpns-clear): CNTPNS IRQビットはどのようにクリアするか**
> ローカルタイマーが指定時間を経過すると、CNTPNS IRQビットがセットされ、
> コアはIRQ割り込みを受けることになります。グローバルタイマを使っていた
> 時は、CSレジスタに書き込むことで割り込みビットをクリアしました。では、
> CNTPNS IRQビットはどのようにクリアするのでしょうか。

#### スケジューラの修正

次のステップはスケジューラでper-コアタイマー割り込みを使ってマルチコア
スケジューリングを有効にすることです。次の手順に従ってください：

- **スケジューラにper-コアローカルタイマー割り込みを使わせる**

  `kern/src/scheduler.rs`を開いてください。このラボの冒頭のマージガイド
  ラインに従っていれば`GlobalScheduler::start()`内に
  `initialize_global_timer_interrupt()`があるはずです。コア番号のチェックを`initialize_global_timer_interrupt()`の周りに追加して、コア0だけがその関数を
  呼び出すようにしてください。そして、次の行で（すべてのコアに対して）
  `initialize_local_timer_interrupt()`を呼び出してください。

  次に、`initialize_global_timer_interrupt`の内容を削除し、同じロジックを
  ローカル割り込みコントローラを使って`initialize_local_timer_interrupt`で
  実装してください。`initialize_global_timer_interrupt`の中身はとりあえず
  空にしておきますが、`start()`内のこの関数の呼び出しは消さないでください。
  この関数はラボの後半で使用します。

- **ローカルタイマー割り込み処理のサポート**

  `kern/src/traps/irq.rs`に`LocalIrq`用の`Index<LocalInterrupt>`を実装して
  ください。そして、`kern/src/traps.rs`にローカルタイマー割り込み処理ロジックを
  追加してください。グローバル割り込みはコア0だけが処理する必要があり、
  すべてのコアは各自のローカル割り込みを処理する必要があります。

- **マルチコア環境用にスケジューラロジックを修正**

  マルチコア環境に切り替えるとスケジューラのいくつかの特徴が壊れます。

    - キューの最初のプロセスがそのコア上で現在実行中のプロセスと一致する
      ことはもはや保証されません。スケジューラのロジックがこの仮定に依存
      している場合は今すぐ修正してください。

    - `start()`内で`switch_to()`を呼び出して見つけたプロセスが初期状態に
      あることは保証されません。これはプロセスの数がコアの数より少ない場合に
      発生する可能性があります。その結果、プロセスのコンテキスト内のすべての
      レジスタがゼロであると仮定することができなくなり、`context_restore`から
      戻った後にユーザプロセスが使用するレジスタを上書きすることは不正となります。

      これを修正する方法はたくさんあります。1つの素朴な方法はスタック調整を
      あきらめ、カーネルスタックにコピーされたトラップフレームのアドレスを
      `SP`に設定することです。この解決策はトラップフレームのサイズに加えて
      約300バイトを無駄にします。この問題を解決するもう1つの方法は`tf`の内容を
      カーネルスタックのトップにコピーし、`context_restore`を呼び出す前に`SP`を
      巻き戻すことです。これはより多くのunsafeなコードを含みますがトラップ
      フレームのサイズしか無駄にしません。また、`context_restore`の後に一般
      レジスタの値をメモリに保存し、それを一時的なレジスタとして使用して
      `SP`を調整し、`eret`の前に復元することもできます。

    - `switch_to()`内で`wfe()`を使ってループしている場合は、`schedule_out()`に
      `sev()`を挿入して待機している他のコアに通知する必要があるでしょう。

- **他のコアをスケジューリングに参加させる**

  最後のステップは`kern/src/init.rs`にある`kmain2()`の最後の無限ループを
  `SCHEDULER::start()`に置き換えることです。

以上を完了させると4つのコアがスケジューリングに参加していることがわかる
はずです。ローカルIRQ処理ルーチンで`trace!()`ログを出力し、4つのコアすべてが
スケジューリングに参加していることを確認してください。トレースレベルのログを
有効にするには`VERBOSE_BUILD=1 make`を実行する必要があることを思い出して
ください。すべてが正しく動作したら次のフェーズに進んでください。

**質問 (multicore-performance): マルチコア性能実験**
> スケジューラに4つのFibプロセスを投入してください。それらをマルチコア
> ありとなしで実行し、実行時間を記録してください。シングルコアではどれだけの
> 時間がかかり、4コアではどれだけの時間がかかりましたか。4コアでは正確に
> 4倍速かったですか。そうでない場合、何がオーバーヘッドになったのでしょうか。

## フェーズ 2: TCPネットワーキング

このフェーズではネットワークドライバと関連するシステムコールを実装する
ことによりTCPネットワーク機能をカーネルに追加します。サブフェーズAでは
TCP over Ethernetがどのように動作するかを学びます。サブフェーズBではRPi用の
既存のイーサネット実装(USPi)と最小限のTCPスタック(smoltcp)をカーネルに統合
します。サブフェーズCではプロセスとスケジューラを調整してソケットがプロセス
リソースとして適切に管理されるようにします。最後に、サブフェーズDでは
ソケット関連のシステムコールを実装して、ネットワークドライバをユーザ
プログラムに公開します。

### サブフェーズ A: ネットワーキング101

このサブフェーズではコンピュータネットワークの概念を学びます。ここでは、
コンピュータネットワークの基本、ネットワークレイヤ、パケットがコンピュータ
ネットワーク上でどのようにルーティングされるか、OSが提供するソケットの
抽象化について説明します。

#### ネットワークレイヤモデル

ネットワークとは他のコンピュータと通信するための方法です。ネットワークの
構造を説明するモデルは数多くありますが、それらに共通するコンセプトは
ネットワークをレイヤ構造としてモデル化することです。このラボではTCP/IPの
4層モデルを使用します。TCP/IPモデルの4つのレイヤは下から次のとおりです。

- リンク層 (Ethernet, IEEE 802.11)
- インターネット層 (IP)
- トランスポート層 (TCP, UDP)
- アプリケーション層 (FTP, HTTP, プレーンテキスト)

**リンク層**は、同じスイッチに接続されているコンピュータなどのローカル
（すなわち直接接続されている）ネットワークでパケットを交換する方法を提供
します。_Ethernet_ と _IEEE 802.11 (Wi-Fi)_ は一般的な2つのリンク層の
プロトコルです。リンク層プロトコルの識別子としては通常、 _Media Access Control (MAC)_
アドレスが使用されます。TCP/IPはリンク層に依存しないように設計されており、
[リンク層として鳥類を使用する規格](https://ja.wikipedia.org/wiki/%E9%B3%A5%E9%A1%9E%E3%82%AD%E3%83%A3%E3%83%AA%E3%82%A2%E3%81%AB%E3%82%88%E3%82%8BIP)さえ存在します。

**インターネット層**は、ホストを識別するためのアドレスシステムとパケットを
宛先に届けるためのルーティング方法を定義します。_IPv4 (Internet Porotocl version 4)_
は最も広く使用されているアドレスシステムです。IPv4方式ではエンドポイントは
4オクテットのアドレスで識別され、通常、127.0.0.1のようにドットで区切られた
4つの10進数で表記されます。インターネットプロトコルは[ベストエフォートデリバリ](https://en.wikipedia.org/wiki/Best-effort_delivery)
であり、パケットが実際に宛先に到達することは保証しません。この懸念は
トランスポート層レベルで処理されます。

**トランスポート層**は、2つのホストコンピュータ間で複数のコネクションを
確立できるようにデータチャネルの抽象化を提供します。最も有名な2つのトランス
ポート層プロトコルが _TCP (Transmission Control Protocol)_ と _UDP (User Datagram Protocol)_ です。両者はエンドポイントの識別子として16ビットの整数で
あるポートを使用します。TCPはパケットの送達確認、エラーリカバリのための再送、
輻輳制御により2つのエンドポイント間の信頼性の高い接続を提供します。一方、
UDPはコネクションレスで損失の多いプロトコルですがより軽量で高速です。

最後に、**アプリケーション層**は、様々なアプリケーションレベルのプロトコルを
提供します。たとえば、ウェブコンテンツのための _HTTP (HyperText Transfer Protocol)_ 、ファイル共有のための _FTP (File Transfer Protocol)_ 、暗号化
通信のための _TLS (Transport Layer Security)_ などです。このラボではEthernet
ケーブルを使用してTCP/IPスタック上でプレーンテキストメッセージを送受信します。

#### パケットのルーティング

ルートテーブルはOSが管理するデータテーブルであり、あるIPアドレスに到達する
ためにどのインターフェースとゲートウェイを使用すべきかを決定するためのもの
です。ルートテーブルはUbuntu 18.04では`route`コマンドで出力できます（この
コマンドがない場合は`sudo apt install net-tools`を実行して`net-tools`
パッケージをインストールしてください）。

ルートテーブルの例は次のようなものです。

![ルートテーブル](route_table.png)

ルートテーブルのエントリには宛先、ゲートウェイ、サブネットマスク
(genmask) 、インタフェースID (iface) が含まれます。IPアドレスが与えられると
OSはルートテーブルの各エントリと比較してそのパケットをどこに配送（または
転送）するべきかを決定します。サブネットマスクでマスクされたパケットの
宛先IPアドレスがエントリの宛先IPと一致する場合、そのパケットは指定された
インタフェースに送られます。パケットの宛先IPがどのエントリにもマッチしない
場合、パケットはデフォルトゲートウェイ（この例では 192.168.0.1）に配送
されます。

宛先アドレスとサブネットマスクのペアは _CIDR (Classless Internet-Domain Routing)_
ブロックと呼ばれます。サブネットマスクは32ビットのアドレスをネットワーク
アドレスとホストアドレスの2つに分割します。ネットワークアドレスは固定部分で
あり、サブネットマスクではビット1で表されます。ホストアドレスは可変部分で
あり、サブネットマスクではビット0で表されます。サブネットマスクは常にnビット
の1と32-nビットの0で構成され、IPアドレスの後に"/サブネットマスクの1ビットの
数"と表記されることが多いです。たとえば、宛先IPが192.168.0.0で、サブネット
マスクが255.255.255.0の場合は192.168.0.0/24と表記され、宛先IPが172.17.0.0で、
サブネットマスクが255.255.0.0の場合は172.17.0.0/16と表記されます。

エントリがゲートウェイを定義していない場合、そのIPを持つホストは
インタフェイスを介して接続されているローカルネットワーク内で見つけることが
できます。たとえば、192.168.0.4は192.168.0.0/24にマッチするのでIPが
192.168.0.4のホストは`enp11s0f1`に接続されたローカルネットワークで見つける
ことができます。エントリがゲートウェイを定義している場合、宛先アドレスに
到達するためにパケットはまずそのIPに転送されます。たとえば、宛先IPが
1.1.1.1のパケットは宛先に到達するためにまずデフォルトゲートウェイ192.168.0.1
に転送されます。そして、192.168.0.1のマシン（ルーター）が自身のルーティング
テーブルに従ってそのパケットを次のホストにルーティングします。

![ARPパケット](arp_packet.png)

MACアドレスはEthernetリンク層を介してパケットを配信する際のアドレス
スキームとして使用されることを思い出してください。_ARP (Address Resolution Protocol)_
はIPv4アドレスとローカル近隣のMACアドレスの関連付けを発見するために使用
されます。ARPパケットはIPアドレスとMACアドレスのペアで構成され、ローカル
ネットワーク内の各コンピュータはその(IP, MAC)のペアを将来の使用のために
近隣キャッシュに保存します。

#### ソケット

MACがリンク層のアドレスであり、IPがインターネット層のアドレスであるように、
ポートはトランスポート層のアドレスと考えることができます。IPアドレスは
コンピュータの選択に使用され、ポートはそのコンピュータで実行されている
特定のプロセスの選択に使用されます。IPアドレスとポートのペアは一体となり
トランスポート層のエンドポイントを形成します。TCPやUDPなどのトランスポート
層のプロトコルは2つの異なるエンドポイントを接続します。

![TCP/IP](tcp_ip.png)

ほとんどのユーザアプリケーションはアプリケーション層レベルで動作します。
アプリケーションは接続を初期化する際に接続する（またはリッスンする）
エンドポイントと使用するトランスレーション層プロトコル（TCP/UDP）を選択する
必要がありますが、その後はアプリケーションデータの送受信だけを行います。
OSとネットワークドライバはユーザプログラムが生成した実際のパケットの
配信を管理し、その過程でさまざまなプロトコルヘッダでパケットをラップしたり
アンラップしたりします。

そのため、OSはアクティブなコネクションのリストを管理し、どのプロセスが
どのコネクションを使用しているかを覚えておく必要があります。ソケットは
この振る舞いを抽象化したシステムリソースです。ユーザプログラムはシステム
コールを使ってソケットを開き、操作し、閉じます。ユーザプログラムはソケット
ディスクリプタ（ソケットのハンドル）を使って特定のソケットを指定します。

Unixオペレーティングシステムは[Berkeley Socket API](https://en.wikipedia.org/wiki/Berkeley_sockets)を
使用しています。Berkeley Socket APIのうち重要なソケットAPIは以下のとおり
です。各APIの説明はWikipediaによります。

- `socket()`は整数番号で識別される特定のタイプの新規ソケットを作成し、
  そのソケットにシステムリソースを割り当てます。
- `bind()`は通常サーバ側で使用され、ソケットとソケットアドレス構造体を、
  すなわち指定されたローカルIPアドレスとポート番号を関連付けます。
- `listen()`はサーバ側で使用され、バインドされたTCPソケットをリスニング
  状態にします。
- `connect()`はクライアント側で使用され、空きローカルポート番号をソケットに
  割り当てます。TCPソケットの場合は新規TCP接続の確立を試みます。
- `accept()`はサーバ側で使用され、受信したリモートクライアントからの新規
  TCP接続確率の試行を受け付け、この接続のソケットアドレスのペアに関連付け
  られた新しいソケットを作成します。
- `send()`, `recv()`, `sendto()`, `recvfrom()`はデータの送受信に使用
  されます。
- `close()`はソケットに割り当てられていたリソースを解放します。TCPの場合、
  接続は終了します。

このラボでは[smoltcp](https://github.com/smoltcp-rs/smoltcp)というRustで
書かれたTCP/IPスタックを使います。`smoltcp`のAPIセットはBerkeley Socket
APIとは少し異なる機能を提供しているので`smoltcp`のAPIだけを使用します。
Berkeley Socket APIと比べて注目すべき違いは次のとおりです。

- `bind(Local Addr)`と`listen()`ではなく単一の`listen(Local Addr)`システム
  コールを使います。
- 新規接続を待機して新しいソケットを作成するブロッキングシステムコールである
  `accept()`は使用せず、Ethernetデバイスがポーリングされるとサーバソケットは
  自動的に接続されます。新規接続を受け付けるために新しいソケットを作成する
  必要があります。
- `send()`と`recv()`はデフォルトでノンブロッキングです。`send()`は
  メッセージをソケットのバッファにキューイングしてすぐに復帰します。
  `recv()`はメッセージがなくても直ちに復帰します。

### サブフェーズ B: ネットワークドライバ

このサブフェーズではネットワークドライバをカーネルに追加します。TCP/IPの仕様は
非常に複雑であり、また、数多くの拡張がある巨大なプロトコルのため、ネットワーク
スタックをゼロから書くのではなく、既存の実装を使用してOSに統合することに注力します。
具体的にはイーサネットドライバとしてはUSPiを、ネットワークスタックとしてはsmoltcpを
使用します。

#### USPiの統合

[USPi](https://github.com/rsta2/uspi)はCで書かれたRaspberry Pi用のベアメタル
USBドライバです。ここではRaspberry PiのEthernetコントローラをUSBプロトコルで
通信するために使用します。USPiは`env`と`lib`の2つの部分で構成されています。
`lib`がライブラリの主要部分であり、メモリ割り当て、タイマー、割り込み処理、
ロギングなどのAPIが環境にあることを期待します。`env`はこれらの関数を公開する
最小限のカーネルです。ここでは`env`は使用せず、私ちのRustOSカーネルで代用
します。

`kern/src/net/uspi.rs`がUSPiとRustOSの統合を担当します。`extern "C"`ブロック
内の関数がUSPiからRustに公開され、`#[no_mangle]`アノテーションが付いた関数が
RustからUSPiに公開されます。提供されている関数のほとんどは自明です。さっそく
ファイルを読んでみてください。コードの構成は通常の設計に従っています。`USPi`
構造体はUSPiとやりとりするための非スレッドセーフなバージョンを実装しており、
`Usb`構造体は`USPi`をMutexでラップすることにより複数のコアから同時にアクセス
できるようにしています。

このモジュールで注目すべきは`uspi_trace!()`マクロと`start_kernel_timer()`の
2つです。環境変数`VERBOSE_BUILD`はトレースレベルのログを出力するか否かを制御
することを思い出してください。`uspi_trace!()`は`trace!()`マクロをラップし、
`DEBUG_USPI`というもう一つのつまみを提供します。USPi関係の関数を扱う際に
このツマミをオンにし、終わったらオフにします。`start_kernel_timer()`はUSPiの
`TimerStartKernelTimer()`を使ってタイマーコールバック関数を登録します。この
ロジックは私たちのカーネルのタイマーIRQ処理と非常によく似ていますが、ソフト
ウェアタイマーを実装しているので遅延時間の異なる複数のコールバック関数を同じ
割り込みに登録することができます。

USPiをサポートするためにはUSB割り込みとタイマー3割り込みをカーネルで処理する
必要があります。さらに、USB割り込みはカーネルコンテキストで処理する必要が
あります。つまり、カーネルはUSB割り込みを _ネストして処理する_ 必要があります。
ネストされた割り込み処理を一般的に許可する代わりに、USB割り込みをFIQとして
扱い、いくつかの限られたコードでネストされたFIQ割り込みを許可することにします。

#### ネットワークドライバ

Rustで書かれたベアメタルシステム用のミニマルなTCP/IPスタックである
[smoltcp](https://github.com/smoltcp-rs/smoltcp)を私たちのカーネルのネット
ワークスタックとして使用します。smoltcpの3つの重要なトレイト/構造体が
[SocketSet](https://docs.rs/smoltcp/0.6.0/smoltcp/socket/struct.SocketSet.html)、[Device](https://docs.rs/smoltcp/0.6.0/smoltcp/phy/trait.Device.html)、[EthernetInterface](https://docs.rs/smoltcp/0.6.0/smoltcp/iface/struct.EthernetInterface.html)です。

1. `SocketSet`はソケットセットを管理します。ソケットセット内の各ソケットは
  各自のRxバッファとTxバッファを管理し、ソケットの読み書きはこれらのバッファに
  しかアクセスしません。

2. `Device`トレイトを実装した型は生のネットワークパケットを送受信できる
  物理的なハードウェアデバイスを表します。私たちのカーネルではUSPiライブラリを
  使って生の物理パケットを送受信します。

3. `EthernetInterface`は内部で`Device`を管理し、それを使ってパケットを送受信
  します。`EthernetInterface`はソケットセットを使って`poll()`することが
  できます。ポーリングするとソケットのTxバッファにある保留データが送信され、
  受信データがソケットのRxバッファにバッファリングされます。

`kern/src/net.rs`はsmoltcpライブラリを私たちのカーネル設計に統合します。
この統合がどのように行われているかを理解するために以下の構造体のコードを
読んでください。

- **`FremeBuf`と`Frame`**:

    固定サイズの8バイトアラインのバッファと長さ追跡可能なu8バッファです。

- **`EthernetDriver`と`GlobalEthernetDriver`**:

    スレッドアンセーフなEthernetドライバ構造体とそれをMutexでラップした
    構造体です。

- **`UsbEthernet`, `RxToken`, `TxToken`**:

    `UsbEthernet`は生のネットワークフレームを送受信するためのインタフェースで
    ある`smoltcp::phy::Device`トレイトを実装しています。`RxToken`構造体と
    `TxToken`構造体は1つのネットワークパケットがどのように送受信されるべきかを
    定義しているトレイトである`smoltcp::phy::RxToken`と
    `smoltcp::phy::TxToken`をそれぞれ実装しています

ネットワークスタックを管理する際のオペレーティングシステムの重要な役割は
システム上のポート番号を管理することです。通常、OSはどのプロセスがどのポート
番号を使用しているかを追跡し、他のプロセスがその接続を妨害しないようにします。
この動作をサポートするには`kern/src/net.rs`にあるポート管理関数を実装し、
プロセスやスケジューラのコードで適切に使用する必要があります。

#### 実装

これでカーネルにネットワークドライバを実装する準備ができました。以下の順序で
機能を実装することを推奨します。

1. **`kern/src/net/uspi.rs`にあるUSPi環境との統合を完成させる**

    まず、ロギング関数`DoLogWrite()`と`uspi_assertion_failed()`を実装して
    ください。`DoLogWrite()`を実装する際には`_pSource`と`_Severity`は無視し、
    `pMessage`をヌル終端のCスタイルの文字列として変換し、それを`uspi_trace!()`
    マクロで出力してください。`uspi_assertion_failed()`を実装する際には同様に `pExpr`と`pFile`をRust文字列に変換して行番号`nLinePをつけて出力して
    ください。どちらの関数もパニックを起こしてはいけません。

    次に、4つのタイマー関数: `TimerSimpleMsDelay()`, `TimerSimpleusDelay()`,
    `MsDelay()`, `usDelay()`を実装してください。パラメタとして指定された
    ミリ秒とマイクロ秒をRustの`Duration`に変換して`pi::timer::spin_sleep()`を
    使用してください。

    最後に、`malloc()`と`free()`を実装してください。これらはCスタイルの
    アロケーションAPIです。つまり、RustのアロケーションAPIのようにレイアウト
    パラメタを提供しません。`malloc()`と`free()`の定義を注意深く読んで
    パラメタとして提供されているものに加えて、どのような情報を追跡する必要が
    あるかを考えてください。それらの情報を保存するためにチャンクに追加情報の
    領域を割り当ててください。割り当てられるすべてのポインタは16バイト
    アラインである必要があります。

2. **FIQ割り込み処理を有効にする**

    USPiではUSB割り込みとタイマー3割り込みを処理する必要があります。さらに、
    USB割り込みをカーネルコンテキストで処理する必要もあります。ここでは、USB
    割り込みを通常のIRQ割り込みではなくFIQ割り込みとして処理し、ネストされた
    FIQ割り込みの処理を限られた場所でのみ許可することでこの動作をサポート
    します。

    まず、`pi/src/interrupt.rs`にある`enable_fiq()`の実装からはじめて
    ください。割り込みをFIQ割り込みとして選択する方法については
    [BCM2837 ARM Peripherals Manual](https://tc.gts3.org/cs3210/2020/spring/r/BCM2837-ARM-Peripherals.pdf)の
    第7章を再度参照する必要があるでしょう。次に、`kern/src/traps.rs`にある
    `handle_exception()`にFIQ処理ルーチンを追加し、`kern/src/traps/irq.rs`に
    ある`Fiq`用の`Index<()>`を実装してください。

    **ヒント**
    > `Index<()>`を書く際にはFIQ制御レジスタをチェックするとよいでしょう。

    これが終わったら`kern/src/net/uspi.rs`にある`ConnectInterrupt()`関数を
    完成させてください。まず、nIRQがInterrupt::UsbまたはInterrupt::Timer3の
    いずれかであることをアサートします。次に、リクエストがUSB割り込みの
    場合はUSB割り込みのFIQ処理を有効にして、提供された`pHandler`を呼び出す
    ハンドラをFIQハンドラレジストリ（`crate::FIQ`）に登録します。そうで
    なければ、Timer3割り込みのIRQ処理を有効にして、提供された`pHandler`を
    呼び出すハンドラをグローバルIRQハンドラレジストリ(`crate::GLOBAL_IRQ`)に
    登録します。

    例外ハンドラが呼び出される際、すべての例外フラグはデフォルトでマスク
    されていることを思い出してください。FIQ割り込みを処理するには、PSTATE
    レジスタのFフラグのマスクを解除する必要があります。`aarch64`ライブラリの
    `enable_fiq_interrupt()`と`disable_fiq_interrupt()`はFIQ割り込みを
    一時的に有効にする機能を提供しています。これらの関数を使って以下の
    場所でFIQ処理を有効にしてください。

      1. システムコールを処理する際 (`kern/src/traps.rs`)
      2. IRQ割り込みを処理する際（`kern/src/traps.rs`）
      3. `start()`で最初の`switch_to`コールを待っている時
        (`kern/src/process/scheduler.rs`)

3. **Ethernet初期化を実装する**

    `kern/src/net.rs`にある`create_interface()`を完成させてください。
    smoltcpの[EthernetInterfaceBuilder](https://docs.rs/smoltcp/0.6.0/smoltcp/iface/struct.EthernetInterfaceBuilder.html)を
    使うことになるはずです。インタフェースを作成する際、`UsbEthernet`を
    内部物理デバイスとして、USPiから取得したMACアドレスをインタフェースの
    Ethernetアドレスとして各々使用してください。次に、`BTreeMap`を使って
    空の近隣キャッシュを追加してください。最後に、2つのCIDRブロック:
    169.254.32.10/16と127.0.0.1/8 をIPアドレスとして追加してください。
    これが終わったら`create_interface()`を使って`EthernetDriver::new()`を
    実装してください。

    **注記: リンクローカルアドレス**
    > 169.254.0.0/16はローカル通信用に予約されたアドレス空間です。2台の
    > コンピューターがイーサネットケーブルで直接接続されている場合、各々に
    > 異なるリンクローカルアドレスが割り当てられます。今回のケースでは
    > カーネルのネットワークインタフェースに固定のリンクローカルアドレス:
    > 169.254.32.10を割り当てています。

    **注記: ルータとのセットアップ方法**
    > ルータを持っている場合はRPiをコンピューターに直接接続する代わりに
    > 次の手順でルータに接続することができます。
    >   1. RPiボードのMACアドレスを控える
    >   2. ルータの管理ページ（アクセス方法については、ルータのマニュアルを
    >     確認してください）でRPiのMACアドレスにIPを手動で割り当てる
    >   3. ネットワークドライバに割り当てたIPを設定する
    >
    > ルータが管理するIPアドレス範囲は以下の3つのプライベートネットワーク
    > アドレス範囲のいずれかであるはずです。
    >   - 192.168.0.0 - 192.168.255.255
    >   - 172.16.0.0 - 172.31.255.255
    >   - 10.0.0.0 - 10.255.255.255

    次にすることは`kmain()`でUSBとETHERNETを初期化することです。
    スケジューラの初期化の後に以下の初期化ルーチンを記述してください。

      1. FIQ割り込みを有効にする
      2. USB`を初期化する
      3. `ETHERNET`を初期化する
      4. `is_eth_available()`でEthernetが利用できることををアサートする
      5. `is_eth_link_up()`でEthernetをポーリングして`true`を返すまで
        ループする
      6. FIQ割り込みを無効にする

4. **ポート管理APIを実装する**

    次は`EthernetDriver`にポート管理APIを書いてください。カーネルには1から
    65535までの65535個のポートがあります。`EthernetDriver`の`port_map`
    フィールドでポートの可用性を管理します。`u64`の整数変数は64ビットで
    あり、各ビットをポートが使用可能か否かのインジケータとして使用します。

    > **注記: ポートの許可**
    > Linuxオペレーティングシステムでは1024以下のポート番号は予約されて
    > おり、これらのポートのlistenにはroot権限が必要です。RustOSには
    > "ユーザ"という概念がないのでこの制限は適用しません。

    `kern/src/net.rs`の`mark_port()`, `erase_port()`, `get_ephemeral_port()`を
    作成してください。関数のコメントを見て、指示に従ってください。

5. **Ethernetのポーリングを実装する**

    次にするのはEthernetインタフェースのポーリングの実装です。イーサネット
    インタフェースがポーリングされた際、`SocketSet`を使ってソケットバッファの
    保留Txパケットを送信し、Ethernetの保留Rxパケットを対応するソケット
    バッファにキューイングする必要があります。

    `smoltcp`はすでにこのロジックを実装しています。それを使って
    `kern/src/net.rs`にある`EthernetDriver::poll()`と
    `EthernetDriver::poll_delay()`を実装してください。[EthernetInterface](https://docs.rs/smoltcp/0.6.0/smoltcp/iface/struct.EthernetInterface.html) の
    ドキュメントを参照すると良いでしょう。また、`EthernetDriver:poll()`の
    ラッパー関数である`GlobalEthernetDriver::poll()`を実装する必要もあります。
    `GlobalEthernetDriver::poll()`はTimer3処理コンテキストでcore 0だけが
    実行する必要があります。通常のラッパー関数のセマンティクスに加えて
    これらの前提条件も確認してください。

    **ヒント**
    > このチェックを`GlobalEthernetDriver::poll()`で実装する際、コア
    > アフィニティとプリエンプティブカウンタをチェックする必要があります。

6. **Ethernetポーリングコールバックを登録する**

    継続的なネットワーク接続を提供するためにEthernetドライバは定期的に
    ポーリングする必要があります。Timer1割り込みはすでにスケジューラの
    tick用に使用しているのでEthernetのポーリングには
    `Usb::start_kernel_timer()`を使用することにします。

    まず、`kern/src/process/scheduler.rs`に`poll_ethernet()`関数を実装
    してください。`GlobalEthernetDriver::poll()`でEthernetインタフェースを
    ポーリングし、`poll_delay()`で次のポーリング時間を計算し、
    `Usb::start_kernel_timer()`でタイムアウトを登録してください。これが
    終わったら、`Usb::start_kernel_timer()`を使って
    `initialize_global_timer_interrupt()`に最初のタイムアウトを登録して
    ください。

以上を終了したら`kmain()`のUSPiとEthernetの初期化が正しく動作すること、
Ethernetインタフェースが繰り返しポーリングされること、既存のユーザ
プログラムが変わらずに動作することを確認してください。すべてが期待通りに
動作したら、次のサブフェーズに進んでください。

### サブフェーズ C: プロセスリソース管理

このサブフェーズではカーネルにプロセスリソース管理を追加します。OSの
カーネルはどのソケットやファイルがどのプロセスによって使用されているかを
追跡する必要があります。これにより、プロセスの要求や寿命に応じてこれら
リソースを開いたり、更新したり、閉じたりすることができます。Unix OSでは
実際のソケットやファイル（inode）の実装はカーネルに存在し、ディスクリプタと
してユーザプログラムに公開されます。プロセスはカレントプロセスが使用して
いるリソースリストのインデックスであるディスクリプタを使用してシステム
コールを行います。たとえば、プロセスが`open()`システムコールでファイルを
オープンすると"3"を返し、以後そのプロセスは"3"を使ってそのファイルを
参照します（0, 1, 2は標準I/O用に予約されています）。プロセスリソース管理
のコードを実装する際にはこの設計に従います。

**質問 (descriptor-design): ソケットディスクリプタの設計**
> ディスクリプタとしてインデックスを使うことの利点とコストについて
> 述べよ。インデックスの代わりにランダムトークンを使用した場合の
> 利点と欠点を述べよ。

#### 実装

`kern/src/process/process.rs`にある`Process`構造体に`Vec<SocketHandle>`
型の`sockets`フィールドを追加することから始めてください。`new()`を適切に
修正してください。次に、`kern/src/process/scheduler.rs`にある
`Scheduler::release_process_resources()`を実装してください。カレント
プロセスが保持しているすべてのソケットをイテレートしてソケットに接続
されているすべてのローカルポートを閉じ、ソケットハンドルを解放し、
Ethernetソケットセットを削除してください。`Scheduler::kill()`の中で
`Scheduler::release_process_resources()`を呼び出すのを忘れないでください。

**ヒント**
> `process.sockets`のスワップには`mem::replace`を使ってください。

**注記: ネットワークスタックには2つのハンドルがあります**
> smoltcpは`SocketSet`内のソケットの参照には`SocketHandle`を使用します。
> 私たちのカーネルはプロセスが保持する`SocketHandle`の参照にはソケット
> ディスクリプタを使用します。この2つのハンドルを混同しないように注意
> してください。

### サブフェーズ D: ソケットシステムコール

このサブフェーズではユーザプログラムがネットワーク機能を使用できるように
するためにカーネルにいくつかのシステムコールを追加します。全部で6つの
ソケットシステムコールを実装します。以下はその概要です。

- `sock_create()`: 新規ソケットを作成して、カレントプロセスのリソースと
  して登録する
- `sock_status()`: ソケットの状態をチェックする
- `sock_connect()`: ソケットを使ってリモートエンドポイントに接続する
- `sock_listen()`: ソケットを使ってローカルエンドポイントをリッスンする
- `sock_send()`: 接続されたソケットを使ってパケットを送信する
- `sock_recv()`: 接続されたソケットからパケットを受診する

#### 実装

`kern/src/traps/syscall.rs`にあるソケット関連のシステムコールハンドラを
書くことから始めてください。これらの関数が何をするかはコメントを参照して
理解してください。`create()`以外は同じようなコード構成になります。

1. カレントプロセスが保持しているソケットハンドルを検索する
2. ハンドルを使ってEthernetソケットセットからソケットを検索する
3. ソケットを使って操作（`status()`, `connect()`など）を行う
4. スケジューラとEthernetドライバを適宜更新する。たとえば、`listen()`や
  `connect()`の際に使用するローカルポート番号をマークする
5. 結果をシステムコールのセマンティクスに従って変換する

このサブフェーズに必要なAPIを見つけるためにスケジューラとEthernet
ドライバのコードを見直す必要があります。また、便利な関数を見つける
ためにsmoltcpドキュメントの[TcpSocket](https://docs.rs/smoltcp/0.6.0/smoltcp/socket/struct.TcpSocket.html)の
ページも参照してください。

**警告: ユーザアドレスの検証**
> ユーザからのアドレスを読み書きする場合、その内容が本当にユーザ
> アドレス空間内にあることを確認しなければなりません。syscallを通じて
> カーネルアドレスを渡してカーネルメモリを上書きするようにカーネルを
> 騙すことはOSカーネルに対する古典的な攻撃です。

**注記: `close()`システムコールは存在しません**
> `close()`システムコールは必須ではありませんが、実装したい場合は
> 実装してください。

**注記: smoltcpのソケットAPIはノンブロッキング**
> BerkeleyのソケットAPIと異なり、私たちのソケットシステムコールは
> デフォルトではノンブロッキングです。これはsmoltcpのAPIをシステム
> コールとして直接ラップしているためです。そのため、新規コネクションが
> 確立された際にカーネルから通知を受けとるのではなく、ユーザプログラムは
> コネクションが確立されたか否かを確認するためにloop内でソケットの
> ステータスをチェックする必要があります。

**質問 (berkeley-socket): BerkeleyライクなソケットAPIの実装**
> 私たちのカーネル設計においてBerkeleyライクなソケットAPIを実装する
> にはどうすればよいか。たとえば、ユーザプログラムが`sock_listen()`
> システムコールを呼び出したとする。新規コネクションが確立されるまで
> カーネルはどのようにユーザプログラムを中断させることができるか。

カーネルにソケット関連のシステムコールハンドラを実装し終わったら、
対応するユーザ側のシステムコールを`kernel_api/src/syscalls.rs`に
書いてください。実装する際にはカーネル側のハンドラコードのコメントを
読んでシステムコールの引数や戻り値の仕様を確認してください。それらを
実装する際にはラッパー型（`SocketDescriptor`、`IpAddr`など）を`u64`に
変換・逆変換することで、ユーザプログラムがより自然な型でシステム
コールを呼び出せるようにしてください。

## フェーズ 3: Echoサーバ

長い旅の最後はネットワークスタックをテストする簡単なユーザプログラムを
実装することです。このフェーズではクライアントから読み取ったメッセージを
送り返すエコーサーバを書きます。これは最も単純なネットワーク
アプリケーションの一つです。主に`user/echo/src/main.rs`で作業します。

### 実装

`main()`には非常に基本的なエラー処理コードが提供されています。ここでの
作業は`main_inner()`でエコーサーバを実装することです。

1. まず、`sock_create()`でソケットを作成します
2. 次に、そのソケットをポート番号 80 でリッスンします
3. ソケットを使ってパケットを送信できるようになるまでループします。
  ソケットのステータスの`can_send`フィールドをチェックする必要が
  あります。ループの中でメッセージを表示し、短い時間（たとえば1秒）
  スリープします
4. クライアントにウェルカムメッセージを送信します
5. 別のループ内でパケットを受信し、ソケットを通して送り返します。
  また、`print!()`を使ってコンソールにメッセージを表示します

エコーサーバの実装が終わったら、スケジューラの初期化コードに"/echo"を
追加してください。

### テスト方法

`user/echo`で`make`を実行してプログラムをビルドし、
`user/echo/build/echo.bin`をSDカードにコピーしてください。次に、
（`kern`ディレクトリで）`make transmit`を実行してカーネルを転送して
ください。これによりカーネルにはシリアル接続とEthernet接続の2つの
接続があることになります。カーネルイメージを転送した後、`screen`コマンドで
シリアル接続するとサーバはクライアント接続を待っているというメッセージが
繰り返し表示されるはずです。次のステップはnetcat (`nc`)コマンドで
エコー・サーバに接続することです。

**警告: ユーザプログラムをSDカードにコピーすることを忘れないこと**
> `make transmit`はカーネルイメージしか転送しません。カーネルがユーザ
> プログラムを検出できるようにユーザプログラムをSDカードにコピーする
> ことを忘れないでください。

VMを使用している場合は、VMでは`make transmit`を行い、ホストOSでは
netcatを使用することを勧めます。リンクローカルアドレスの使用は最近では
ちょっと珍しい通信方法であり、リンクローカルアドレス空間はローカル
設定だけで使用されるものなので仮想マシンのネットワークトランスレーション
レイヤがうまく動作しない可能性があります。

netcatコマンドをホストシステムにインストールする必要があるかもしれません。
Windowsでは[netcat](https://eternallybored.org/misc/netcat/)がうまく
動作するようです。Linuxではネットワークマネージャか`ifconfig`でEthernet
インタフェースを`Link-Local Only`に設定する必要があるかもしれません。
Netcatはたいていプリインストールされていますが、そうでない場合は
`sudo apt install netcat`でインストールできます。MacOSでは
`brew install nmap`コマンドでnetcatをインストールできます。RPiサーバが
起動したら、`System Preference - Network`内の`USB 10/100/1000 LAN`
（またはそれに相当する名前）のランプが赤から黄色に変わり、IPアドレスが
表示されているのを確認できます。

準備ができたら手元のコンピュータで`nc 169.254.32.10 80`（MacOSでは
`ncat`）と入力してエコーサーバに接続してください。RPiがOSに認識される
には時間がかかるので最初の数回は失敗するかもしれません。接続が完了すると
エコーサーバはウェルカムメッセージを表示し、シェルに入力した内容が
Ethernetケーブルを経由してしばらくすると戻ってきます。
